{"index":"<h1>React Documentation</h1>  <h2 id=\"jsfiddle\">\nJSFiddle </h2> <p>The easiest way to start hacking on React is using the following JSFiddle Hello World examples:</p> <ul> <li><strong><a href=\"https://jsfiddle.net/reactjs/69z2wepo/\">React JSFiddle</a></strong></li> <li><a href=\"https://jsfiddle.net/reactjs/5vjqabv3/\">React JSFiddle without JSX</a></li> </ul> <h2 id=\"starter-pack\">\nStarter Pack </h2> <p>If you're just getting started, you can download the starter kit. The starter kit includes prebuilt copies of React and React DOM for the browser, as well as a collection of usage examples to help you get started.</p>  <a href=\"https://facebook.github.io/react/downloads/react-15.3.0.zip\" class=\"button\"> Download Starter Kit 15.3.0 </a>  <p>In the root directory of the starter kit, create a <code>helloworld.html</code> with the following contents.</p> <pre class=\"highlight\" data-language=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;title&gt;Hello React!&lt;/title&gt;\n    &lt;script src=\"build/react.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"build/react-dom.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.34/browser.min.js\"&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"example\"&gt;&lt;/div&gt;\n    &lt;script type=\"text/babel\"&gt;\n      ReactDOM.render(\n        &lt;h1&gt;Hello, world!&lt;/h1&gt;,\n        document.getElementById('example')\n      );\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</pre> <p>The XML syntax inside of JavaScript is called JSX; check out the <a href=\"docs/jsx-in-depth\">JSX syntax</a> to learn more about it. In order to translate it to vanilla JavaScript we use <code>&lt;script type=\"text/babel\"&gt;</code> and include Babel to actually perform the transformation in the browser. Open the html from a browser and you should already be able to see the greeting!</p> <h3 id=\"separate-file\">\nSeparate File </h3> <p>Your React JSX code can live in a separate file. Create the following <code>src/helloworld.js</code>.</p> <pre class=\"highlight\" data-language=\"javascript\">ReactDOM.render(\n  &lt;h1&gt;Hello, world!&lt;/h1&gt;,\n  document.getElementById('example')\n);\n</pre> <p>Then reference it from <code>helloworld.html</code>:</p> <pre class=\"highlight\" data-language=\"html\">&lt;script type=\"text/babel\" src=\"src/helloworld.js\"&gt;&lt;/script&gt;\n</pre> <p>Note that some browsers (Chrome, e.g.) will fail to load the file unless it's served via HTTP.</p> <h2 id=\"using-react-with-npm-or-bower\">\nUsing React with npm or Bower </h2> <p>You can also use React with package managers like npm or Bower. You can learn more in our <a href=\"docs/package-management\">Package Managers</a> section.</p> <h2 id=\"next-steps\">\nNext Steps </h2> <p>Check out <a href=\"docs/tutorial\">the tutorial</a> and the other examples in the starter kit's <code>examples</code> directory to learn more.</p> <p>Good luck, and welcome!</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/getting-started.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/getting-started.html</a>\n  </p>\n</div>\n","docs/tutorial":"<h1> Tutorial </h1>  <p>We'll be building a simple but realistic comments box that you can drop into a blog, a basic version of the realtime comments offered by Disqus, LiveFyre or Facebook comments.</p> <p>We'll provide:</p> <ul> <li>A view of all of the comments</li> <li>A form to submit a comment</li> <li>Hooks for you to provide a custom backend</li> </ul> <p>It'll also have a few neat features:</p> <ul> <li>\n<strong>Optimistic commenting:</strong> comments appear in the list before they're saved on the server so it feels fast.</li> <li>\n<strong>Live updates:</strong> other users' comments are popped into the comment view in real time.</li> <li>\n<strong>Markdown formatting:</strong> users can use Markdown to format their text.</li> </ul> <h3 id=\"want-to-skip-all-this-and-just-see-the-source\">\nWant to skip all this and just see the source? </h3> <p><a href=\"https://github.com/reactjs/react-tutorial\">It's all on GitHub.</a></p> <h3 id=\"running-a-server\">\nRunning a server </h3> <p>In order to start this tutorial, we're going to require a running server. This will serve purely as an API endpoint which we'll use for getting and saving data. In order to make this as easy as possible, we've created a simple server in a number of scripting languages that does exactly what we need it to do. <strong>You can <a href=\"https://github.com/reactjs/react-tutorial/\">view the source</a> or <a href=\"https://github.com/reactjs/react-tutorial/archive/master.zip\">download a zip file</a> containing everything needed to get started.</strong></p> <p>For sake of simplicity, the server we will run uses a <code>JSON</code> file as a database. You would not run this in production but it makes it easy to simulate what you might do when consuming an API. Once you <a href=\"https://github.com/reactjs/react-tutorial/#to-use\">start the server</a>, it will support our API endpoint and it will also serve the static pages we need.</p> <h3 id=\"getting-started\">\nGetting started </h3> <p>For this tutorial, we're going to make it as easy as possible. Included in the server package discussed above is an HTML file which we'll work in. Open up <code>public/index.html</code> in your favorite editor. It should look something like this:</p> <pre class=\"highlight\" data-language=\"html\">&lt;!-- index.html --&gt;\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\" /&gt;\n    &lt;title&gt;React Tutorial&lt;/title&gt;\n    &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.3.0/react.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/react/15.3.0/react-dom.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.34/browser.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.0/jquery.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/remarkable/1.6.2/remarkable.min.js\"&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"content\"&gt;&lt;/div&gt;\n    &lt;script type=\"text/babel\" src=\"scripts/example.js\"&gt;&lt;/script&gt;\n    &lt;script type=\"text/babel\"&gt;\n      // To get started with this tutorial running your own code, simply remove\n      // the script tag loading scripts/example.js and start writing code here.\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</pre> <p>For the remainder of this tutorial, we'll be writing our JavaScript code in this script tag. We don't have any advanced live-reloading so you'll need to refresh your browser to see updates after saving. Follow your progress by opening <code>http://localhost:3000</code> in your browser (after starting the server). When you load this for the first time without any changes, you'll see the finished product of what we're going to build. When you're ready to start working, just delete the preceding <code>&lt;script&gt;</code> tag and then you can continue.</p> <blockquote>  <p>We included jQuery here because we want to simplify the code of our future ajax calls, but it's <strong>NOT</strong> mandatory for React to work.</p> </blockquote> <h3 id=\"your-first-component\">\nYour first component </h3> <p>React is all about modular, composable components. For our comment box example, we'll have the following component structure:</p> <pre class=\"highlight\" data-language=\"text\">- CommentBox\n  - CommentList\n    - Comment\n  - CommentForm\n</pre> <p>Let's build the <code>CommentBox</code> component, which is just a simple <code>&lt;div&gt;</code>:</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial1.js\nvar CommentBox = React.createClass({\n  render: function() {\n    return (\n      &lt;div className=\"commentBox\"&gt;\n        Hello, world! I am a CommentBox.\n      &lt;/div&gt;\n    );\n  }\n});\nReactDOM.render(\n  &lt;CommentBox /&gt;,\n  document.getElementById('content')\n);\n</pre> <p>Note that native HTML element names start with a lowercase letter, while custom React class names begin with an uppercase letter.</p> <h4 id=\"jsx-syntax\">\nJSX Syntax </h4> <p>The first thing you'll notice is the XML-ish syntax in your JavaScript. We have a simple precompiler that translates the syntactic sugar to this plain JavaScript:</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial1-raw.js\nvar CommentBox = React.createClass({displayName: 'CommentBox',\n  render: function() {\n    return (\n      React.createElement('div', {className: \"commentBox\"},\n        \"Hello, world! I am a CommentBox.\"\n      )\n    );\n  }\n});\nReactDOM.render(\n  React.createElement(CommentBox, null),\n  document.getElementById('content')\n);\n</pre> <p>Its use is optional but we've found JSX syntax easier to use than plain JavaScript. Read more on the <a href=\"jsx-in-depth\">JSX Syntax article</a>.</p> <h4 id=\"whats-going-on\">\nWhat's going on </h4> <p>We pass some methods in a JavaScript object to <code>React.createClass()</code> to create a new React component. The most important of these methods is called <code>render</code> which returns a tree of React components that will eventually render to HTML.</p> <p>The <code>&lt;div&gt;</code> tags are not actual DOM nodes; they are instantiations of React <code>div</code> components. You can think of these as markers or pieces of data that React knows how to handle. React is <strong>safe</strong>. We are not generating HTML strings so XSS protection is the default.</p> <p>You do not have to return basic HTML. You can return a tree of components that you (or someone else) built. This is what makes React <strong>composable</strong>: a key tenet of maintainable frontends.</p> <p><code>ReactDOM.render()</code> instantiates the root component, starts the framework, and injects the markup into a raw DOM element, provided as the second argument.</p> <p>The <code>ReactDOM</code> module exposes DOM-specific methods, while <code>React</code> has the core tools shared by React on different platforms (e.g., <a href=\"http://facebook.github.io/react-native/\">React Native</a>).</p> <p>It is important that <code>ReactDOM.render</code> remain at the bottom of the script for this tutorial. <code>ReactDOM.render</code> should only be called after the composite components have been defined.</p> <h2 id=\"composing-components\">\nComposing components </h2> <p>Let's build skeletons for <code>CommentList</code> and <code>CommentForm</code> which will, again, be simple <code>&lt;div&gt;</code>s. Add these two components to your file, keeping the existing <code>CommentBox</code> declaration and <code>ReactDOM.render</code> call:</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial2.js\nvar CommentList = React.createClass({\n  render: function() {\n    return (\n      &lt;div className=\"commentList\"&gt;\n        Hello, world! I am a CommentList.\n      &lt;/div&gt;\n    );\n  }\n});\n\nvar CommentForm = React.createClass({\n  render: function() {\n    return (\n      &lt;div className=\"commentForm\"&gt;\n        Hello, world! I am a CommentForm.\n      &lt;/div&gt;\n    );\n  }\n});\n</pre> <p>Next, update the <code>CommentBox</code> component to use these new components:</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial3.js\nvar CommentBox = React.createClass({\n  render: function() {\n    return (\n      &lt;div className=\"commentBox\"&gt;\n        &lt;h1&gt;Comments&lt;/h1&gt;\n        &lt;CommentList /&gt;\n        &lt;CommentForm /&gt;\n      &lt;/div&gt;\n    );\n  }\n});\n</pre> <p>Notice how we're mixing HTML tags and components we've built. HTML components are regular React components, just like the ones you define, with one difference. The JSX compiler will automatically rewrite HTML tags to <code>React.createElement(tagName)</code> expressions and leave everything else alone. This is to prevent the pollution of the global namespace.</p> <h3 id=\"using-props\">\nUsing props </h3> <p>Let's create the <code>Comment</code> component, which will depend on data passed in from its parent. Data passed in from a parent component is available as a 'property' on the child component. These 'properties' are accessed through <code>this.props</code>. Using props, we will be able to read the data passed to the <code>Comment</code> from the <code>CommentList</code>, and render some markup:</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial4.js\nvar Comment = React.createClass({\n  render: function() {\n    return (\n      &lt;div className=\"comment\"&gt;\n        &lt;h2 className=\"commentAuthor\"&gt;\n          {this.props.author}\n        &lt;/h2&gt;\n        {this.props.children}\n      &lt;/div&gt;\n    );\n  }\n});\n</pre> <p>By surrounding a JavaScript expression in braces inside JSX (as either an attribute or child), you can drop text or React components into the tree. We access named attributes passed to the component as keys on <code>this.props</code> and any nested elements as <code>this.props.children</code>.</p> <h3 id=\"component-properties\">\nComponent Properties </h3> <p>Now that we have defined the <code>Comment</code> component, we will want to pass it the author name and comment text. This allows us to reuse the same code for each unique comment. Now let's add some comments within our <code>CommentList</code>:</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial5.js\nvar CommentList = React.createClass({\n  render: function() {\n    return (\n      &lt;div className=\"commentList\"&gt;\n        &lt;Comment author=\"Pete Hunt\"&gt;This is one comment&lt;/Comment&gt;\n        &lt;Comment author=\"Jordan Walke\"&gt;This is *another* comment&lt;/Comment&gt;\n      &lt;/div&gt;\n    );\n  }\n});\n</pre> <p>Note that we have passed some data from the parent <code>CommentList</code> component to the child <code>Comment</code> components. For example, we passed <em>Pete Hunt</em> (via an attribute) and <em>This is one comment</em> (via an XML-like child node) to the first <code>Comment</code>. As noted above, the <code>Comment</code> component will access these 'properties' through <code>this.props.author</code>, and <code>this.props.children</code>.</p> <h3 id=\"adding-markdown\">\nAdding Markdown </h3> <p>Markdown is a simple way to format your text inline. For example, surrounding text with asterisks will make it emphasized.</p> <p>In this tutorial we use a third-party library <strong>remarkable</strong> which takes Markdown text and converts it to raw HTML. We already included this library with the original markup for the page, so we can just start using it. Let's convert the comment text to Markdown and output it:</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial6.js\nvar Comment = React.createClass({\n  render: function() {\n    var md = new Remarkable();\n    return (\n      &lt;div className=\"comment\"&gt;\n        &lt;h2 className=\"commentAuthor\"&gt;\n          {this.props.author}\n        &lt;/h2&gt;\n        {md.render(this.props.children.toString())}\n      &lt;/div&gt;\n    );\n  }\n});\n</pre> <p>All we're doing here is calling the remarkable library. We need to convert <code>this.props.children</code> from React's wrapped text to a raw string that remarkable will understand so we explicitly call <code>toString()</code>.</p> <p>But there's a problem! Our rendered comments look like this in the browser: \"<code>&lt;p&gt;</code>This is <code>&lt;em&gt;</code>another<code>&lt;/em&gt;</code> comment<code>&lt;/p&gt;</code>\". We want those tags to actually render as HTML.</p> <p>That's React protecting you from an <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\">XSS attack</a>. There's a way to get around it but the framework warns you not to use it:</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial7.js\nvar Comment = React.createClass({\n  rawMarkup: function() {\n    var md = new Remarkable();\n    var rawMarkup = md.render(this.props.children.toString());\n    return { __html: rawMarkup };\n  },\n\n  render: function() {\n    return (\n      &lt;div className=\"comment\"&gt;\n        &lt;h2 className=\"commentAuthor\"&gt;\n          {this.props.author}\n        &lt;/h2&gt;\n        &lt;span dangerouslySetInnerHTML={this.rawMarkup()} /&gt;\n      &lt;/div&gt;\n    );\n  }\n});\n</pre> <p>This is a special API that intentionally makes it difficult to insert raw HTML, but for remarkable we'll take advantage of this backdoor.</p> <p><strong>Remember:</strong> by using this feature you're relying on remarkable to be secure. In this case, remarkable automatically strips HTML markup and insecure links from the output.</p> <h3 id=\"hook-up-the-data-model\">\nHook up the data model </h3> <p>So far we've been inserting the comments directly in the source code. Instead, let's render a blob of JSON data into the comment list. Eventually this will come from the server, but for now, write it in your source:</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial8.js\nvar data = [\n  {id: 1, author: \"Pete Hunt\", text: \"This is one comment\"},\n  {id: 2, author: \"Jordan Walke\", text: \"This is *another* comment\"}\n];\n</pre> <p>We need to get this data into <code>CommentList</code> in a modular way. Modify <code>CommentBox</code> and the <code>ReactDOM.render()</code> call to pass this data into the <code>CommentList</code> via props:</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial9.js\nvar CommentBox = React.createClass({\n  render: function() {\n    return (\n      &lt;div className=\"commentBox\"&gt;\n        &lt;h1&gt;Comments&lt;/h1&gt;\n        &lt;CommentList data={this.props.data} /&gt;\n        &lt;CommentForm /&gt;\n      &lt;/div&gt;\n    );\n  }\n});\n\nReactDOM.render(\n  &lt;CommentBox data={data} /&gt;,\n  document.getElementById('content')\n);\n</pre> <p>Now that the data is available in the <code>CommentList</code>, let's render the comments dynamically:</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial10.js\nvar CommentList = React.createClass({\n  render: function() {\n    var commentNodes = this.props.data.map(function(comment) {\n      return (\n        &lt;Comment author={comment.author} key={comment.id}&gt;\n          {comment.text}\n        &lt;/Comment&gt;\n      );\n    });\n    return (\n      &lt;div className=\"commentList\"&gt;\n        {commentNodes}\n      &lt;/div&gt;\n    );\n  }\n});\n</pre> <p>That's it!</p> <h3 id=\"fetching-from-the-server\">\nFetching from the server </h3> <p>Let's replace the hard-coded data with some dynamic data from the server. We will remove the data prop and replace it with a URL to fetch:</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial11.js\nReactDOM.render(\n  &lt;CommentBox url=\"/api/comments\" /&gt;,\n  document.getElementById('content')\n);\n</pre> <p>This component is different from the prior components because it will have to re-render itself. The component won't have any data until the request from the server comes back, at which point the component may need to render some new comments.</p> <p>Note: the code will not be working at this step.</p> <h3 id=\"reactive-state\">\nReactive state </h3> <p>So far, based on its props, each component has rendered itself once. <code>props</code> are immutable: they are passed from the parent and are \"owned\" by the parent. To implement interactions, we introduce mutable <strong>state</strong> to the component. <code>this.state</code> is private to the component and can be changed by calling <code>this.setState()</code>. When the state updates, the component re-renders itself.</p> <p><code>render()</code> methods are written declaratively as functions of <code>this.props</code> and <code>this.state</code>. The framework guarantees the UI is always consistent with the inputs.</p> <p>When the server fetches data, we will be changing the comment data we have. Let's add an array of comment data to the <code>CommentBox</code> component as its state:</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial12.js\nvar CommentBox = React.createClass({\n  getInitialState: function() {\n    return {data: []};\n  },\n  render: function() {\n    return (\n      &lt;div className=\"commentBox\"&gt;\n        &lt;h1&gt;Comments&lt;/h1&gt;\n        &lt;CommentList data={this.state.data} /&gt;\n        &lt;CommentForm /&gt;\n      &lt;/div&gt;\n    );\n  }\n});\n</pre> <p><code>getInitialState()</code> executes exactly once during the lifecycle of the component and sets up the initial state of the component.</p> <h4 id=\"updating-state\">\nUpdating state </h4> <p>When the component is first created, we want to GET some JSON from the server and update the state to reflect the latest data. We're going to use jQuery to make an asynchronous request to the server we started earlier to fetch the data we need. The data is already included in the server you started (based on the <code>comments.json</code> file), so once it's fetched, <code>this.state.data</code> will look something like this:</p> <pre class=\"highlight\" data-language=\"json\">[\n  {\"id\": \"1\", \"author\": \"Pete Hunt\", \"text\": \"This is one comment\"},\n  {\"id\": \"2\", \"author\": \"Jordan Walke\", \"text\": \"This is *another* comment\"}\n]\n</pre>\n<pre class=\"highlight\" data-language=\"javascript\">// tutorial13.js\nvar CommentBox = React.createClass({\n  getInitialState: function() {\n    return {data: []};\n  },\n  componentDidMount: function() {\n    $.ajax({\n      url: this.props.url,\n      dataType: 'json',\n      cache: false,\n      success: function(data) {\n        this.setState({data: data});\n      }.bind(this),\n      error: function(xhr, status, err) {\n        console.error(this.props.url, status, err.toString());\n      }.bind(this)\n    });\n  },\n  render: function() {\n    return (\n      &lt;div className=\"commentBox\"&gt;\n        &lt;h1&gt;Comments&lt;/h1&gt;\n        &lt;CommentList data={this.state.data} /&gt;\n        &lt;CommentForm /&gt;\n      &lt;/div&gt;\n    );\n  }\n});\n</pre> <p>Here, <code>componentDidMount</code> is a method called automatically by React after a component is rendered for the first time. The key to dynamic updates is the call to <code>this.setState()</code>. We replace the old array of comments with the new one from the server and the UI automatically updates itself. Because of this reactivity, it is only a minor change to add live updates. We will use simple polling here but you could easily use WebSockets or other technologies.</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial14.js\nvar CommentBox = React.createClass({\n  loadCommentsFromServer: function() {\n    $.ajax({\n      url: this.props.url,\n      dataType: 'json',\n      cache: false,\n      success: function(data) {\n        this.setState({data: data});\n      }.bind(this),\n      error: function(xhr, status, err) {\n        console.error(this.props.url, status, err.toString());\n      }.bind(this)\n    });\n  },\n  getInitialState: function() {\n    return {data: []};\n  },\n  componentDidMount: function() {\n    this.loadCommentsFromServer();\n    setInterval(this.loadCommentsFromServer, this.props.pollInterval);\n  },\n  render: function() {\n    return (\n      &lt;div className=\"commentBox\"&gt;\n        &lt;h1&gt;Comments&lt;/h1&gt;\n        &lt;CommentList data={this.state.data} /&gt;\n        &lt;CommentForm /&gt;\n      &lt;/div&gt;\n    );\n  }\n});\n\nReactDOM.render(\n  &lt;CommentBox url=\"/api/comments\" pollInterval={2000} /&gt;,\n  document.getElementById('content')\n);\n</pre> <p>All we have done here is move the AJAX call to a separate method and call it when the component is first loaded and every 2 seconds after that. Try running this in your browser and changing the <code>comments.json</code> file (in the same directory as your server); within 2 seconds, the changes will show!</p> <h3 id=\"adding-new-comments\">\nAdding new comments </h3> <p>Now it's time to build the form. Our <code>CommentForm</code> component should ask the user for their name and comment text and send a request to the server to save the comment.</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial15.js\nvar CommentForm = React.createClass({\n  render: function() {\n    return (\n      &lt;form className=\"commentForm\"&gt;\n        &lt;input type=\"text\" placeholder=\"Your name\" /&gt;\n        &lt;input type=\"text\" placeholder=\"Say something...\" /&gt;\n        &lt;input type=\"submit\" value=\"Post\" /&gt;\n      &lt;/form&gt;\n    );\n  }\n});\n</pre>\n<h4 id=\"controlled-components\">\nControlled components </h4> <p>With the traditional DOM, <code>input</code> elements are rendered and the browser manages the state (its rendered value). As a result, the state of the actual DOM will differ from that of the component. This is not ideal as the state of the view will differ from that of the component. In React, components should always represent the state of the view and not only at the point of initialization.</p> <p>Hence, we will be using <code>this.state</code> to save the user's input as it is entered. We define an initial <code>state</code> with two properties <code>author</code> and <code>text</code> and set them to be empty strings. In our <code>&lt;input&gt;</code> elements, we set the <code>value</code> prop to reflect the <code>state</code> of the component and attach <code>onChange</code> handlers to them. These <code>&lt;input&gt;</code> elements with a <code>value</code> set are called controlled components. Read more about controlled components on the <a href=\"forms#controlled-components\">Forms article</a>.</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial16.js\nvar CommentForm = React.createClass({\n  getInitialState: function() {\n    return {author: '', text: ''};\n  },\n  handleAuthorChange: function(e) {\n    this.setState({author: e.target.value});\n  },\n  handleTextChange: function(e) {\n    this.setState({text: e.target.value});\n  },\n  render: function() {\n    return (\n      &lt;form className=\"commentForm\"&gt;\n        &lt;input\n          type=\"text\"\n          placeholder=\"Your name\"\n          value={this.state.author}\n          onChange={this.handleAuthorChange}\n        /&gt;\n        &lt;input\n          type=\"text\"\n          placeholder=\"Say something...\"\n          value={this.state.text}\n          onChange={this.handleTextChange}\n        /&gt;\n        &lt;input type=\"submit\" value=\"Post\" /&gt;\n      &lt;/form&gt;\n    );\n  }\n});\n</pre>\n<h4 id=\"events\">\nEvents </h4> <p>React attaches event handlers to components using a camelCase naming convention. We attach <code>onChange</code> handlers to the two <code>&lt;input&gt;</code> elements. Now, as the user enters text into the <code>&lt;input&gt;</code> fields, the attached <code>onChange</code> callbacks are fired and the <code>state</code> of the component is modified. Subsequently, the rendered value of the <code>input</code> element will be updated to reflect the current component <code>state</code>.</p> <p>(The astute reader may be surprised that these event handlers work as described, given that the method references are not explicitly bound to <code>this</code>. <code>React.createClass(...)</code> <a href=\"interactivity-and-dynamic-uis#under-the-hood-autobinding-and-event-delegation\">automatically binds</a> each method to its component instance, obviating the need for explicit binding.)</p> <h4 id=\"submitting-the-form\">\nSubmitting the form </h4> <p>Let's make the form interactive. When the user submits the form, we should clear it, submit a request to the server, and refresh the list of comments. To start, let's listen for the form's submit event and clear it.</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial17.js\nvar CommentForm = React.createClass({\n  getInitialState: function() {\n    return {author: '', text: ''};\n  },\n  handleAuthorChange: function(e) {\n    this.setState({author: e.target.value});\n  },\n  handleTextChange: function(e) {\n    this.setState({text: e.target.value});\n  },\n  handleSubmit: function(e) {\n    e.preventDefault();\n    var author = this.state.author.trim();\n    var text = this.state.text.trim();\n    if (!text || !author) {\n      return;\n    }\n    // TODO: send request to the server\n    this.setState({author: '', text: ''});\n  },\n  render: function() {\n    return (\n      &lt;form className=\"commentForm\" onSubmit={this.handleSubmit}&gt;\n        &lt;input\n          type=\"text\"\n          placeholder=\"Your name\"\n          value={this.state.author}\n          onChange={this.handleAuthorChange}\n        /&gt;\n        &lt;input\n          type=\"text\"\n          placeholder=\"Say something...\"\n          value={this.state.text}\n          onChange={this.handleTextChange}\n        /&gt;\n        &lt;input type=\"submit\" value=\"Post\" /&gt;\n      &lt;/form&gt;\n    );\n  }\n});\n</pre> <p>We attach an <code>onSubmit</code> handler to the form that clears the form fields when the form is submitted with valid input.</p> <p>Call <code>preventDefault()</code> on the event to prevent the browser's default action of submitting the form.</p> <h4 id=\"callbacks-as-props\">\nCallbacks as props </h4> <p>When a user submits a comment, we will need to refresh the list of comments to include the new one. It makes sense to do all of this logic in <code>CommentBox</code> since <code>CommentBox</code> owns the state that represents the list of comments.</p> <p>We need to pass data from the child component back up to its parent. We do this in our parent's <code>render</code> method by passing a new callback (<code>handleCommentSubmit</code>) into the child, binding it to the child's <code>onCommentSubmit</code> event. Whenever the event is triggered, the callback will be invoked:</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial18.js\nvar CommentBox = React.createClass({\n  loadCommentsFromServer: function() {\n    $.ajax({\n      url: this.props.url,\n      dataType: 'json',\n      cache: false,\n      success: function(data) {\n        this.setState({data: data});\n      }.bind(this),\n      error: function(xhr, status, err) {\n        console.error(this.props.url, status, err.toString());\n      }.bind(this)\n    });\n  },\n  handleCommentSubmit: function(comment) {\n    // TODO: submit to the server and refresh the list\n  },\n  getInitialState: function() {\n    return {data: []};\n  },\n  componentDidMount: function() {\n    this.loadCommentsFromServer();\n    setInterval(this.loadCommentsFromServer, this.props.pollInterval);\n  },\n  render: function() {\n    return (\n      &lt;div className=\"commentBox\"&gt;\n        &lt;h1&gt;Comments&lt;/h1&gt;\n        &lt;CommentList data={this.state.data} /&gt;\n        &lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&gt;\n      &lt;/div&gt;\n    );\n  }\n});\n</pre> <p>Now that <code>CommentBox</code> has made the callback available to <code>CommentForm</code> via the <code>onCommentSubmit</code> prop, the <code>CommentForm</code> can call the callback when the user submits the form:</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial19.js\nvar CommentForm = React.createClass({\n  getInitialState: function() {\n    return {author: '', text: ''};\n  },\n  handleAuthorChange: function(e) {\n    this.setState({author: e.target.value});\n  },\n  handleTextChange: function(e) {\n    this.setState({text: e.target.value});\n  },\n  handleSubmit: function(e) {\n    e.preventDefault();\n    var author = this.state.author.trim();\n    var text = this.state.text.trim();\n    if (!text || !author) {\n      return;\n    }\n    this.props.onCommentSubmit({author: author, text: text});\n    this.setState({author: '', text: ''});\n  },\n  render: function() {\n    return (\n      &lt;form className=\"commentForm\" onSubmit={this.handleSubmit}&gt;\n        &lt;input\n          type=\"text\"\n          placeholder=\"Your name\"\n          value={this.state.author}\n          onChange={this.handleAuthorChange}\n        /&gt;\n        &lt;input\n          type=\"text\"\n          placeholder=\"Say something...\"\n          value={this.state.text}\n          onChange={this.handleTextChange}\n        /&gt;\n        &lt;input type=\"submit\" value=\"Post\" /&gt;\n      &lt;/form&gt;\n    );\n  }\n});\n</pre> <p>Now that the callbacks are in place, all we have to do is submit to the server and refresh the list:</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial20.js\nvar CommentBox = React.createClass({\n  loadCommentsFromServer: function() {\n    $.ajax({\n      url: this.props.url,\n      dataType: 'json',\n      cache: false,\n      success: function(data) {\n        this.setState({data: data});\n      }.bind(this),\n      error: function(xhr, status, err) {\n        console.error(this.props.url, status, err.toString());\n      }.bind(this)\n    });\n  },\n  handleCommentSubmit: function(comment) {\n    $.ajax({\n      url: this.props.url,\n      dataType: 'json',\n      type: 'POST',\n      data: comment,\n      success: function(data) {\n        this.setState({data: data});\n      }.bind(this),\n      error: function(xhr, status, err) {\n        console.error(this.props.url, status, err.toString());\n      }.bind(this)\n    });\n  },\n  getInitialState: function() {\n    return {data: []};\n  },\n  componentDidMount: function() {\n    this.loadCommentsFromServer();\n    setInterval(this.loadCommentsFromServer, this.props.pollInterval);\n  },\n  render: function() {\n    return (\n      &lt;div className=\"commentBox\"&gt;\n        &lt;h1&gt;Comments&lt;/h1&gt;\n        &lt;CommentList data={this.state.data} /&gt;\n        &lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&gt;\n      &lt;/div&gt;\n    );\n  }\n});\n</pre>\n<h3 id=\"optimization-optimistic-updates\">\nOptimization: optimistic updates </h3> <p>Our application is now feature complete but it feels slow to have to wait for the request to complete before your comment appears in the list. We can optimistically add this comment to the list to make the app feel faster.</p> <pre class=\"highlight\" data-language=\"javascript\">// tutorial21.js\nvar CommentBox = React.createClass({\n  loadCommentsFromServer: function() {\n    $.ajax({\n      url: this.props.url,\n      dataType: 'json',\n      cache: false,\n      success: function(data) {\n        this.setState({data: data});\n      }.bind(this),\n      error: function(xhr, status, err) {\n        console.error(this.props.url, status, err.toString());\n      }.bind(this)\n    });\n  },\n  handleCommentSubmit: function(comment) {\n    var comments = this.state.data;\n    // Optimistically set an id on the new comment. It will be replaced by an\n    // id generated by the server. In a production application you would likely\n    // not use Date.now() for this and would have a more robust system in place.\n    comment.id = Date.now();\n    var newComments = comments.concat([comment]);\n    this.setState({data: newComments});\n    $.ajax({\n      url: this.props.url,\n      dataType: 'json',\n      type: 'POST',\n      data: comment,\n      success: function(data) {\n        this.setState({data: data});\n      }.bind(this),\n      error: function(xhr, status, err) {\n        this.setState({data: comments});\n        console.error(this.props.url, status, err.toString());\n      }.bind(this)\n    });\n  },\n  getInitialState: function() {\n    return {data: []};\n  },\n  componentDidMount: function() {\n    this.loadCommentsFromServer();\n    setInterval(this.loadCommentsFromServer, this.props.pollInterval);\n  },\n  render: function() {\n    return (\n      &lt;div className=\"commentBox\"&gt;\n        &lt;h1&gt;Comments&lt;/h1&gt;\n        &lt;CommentList data={this.state.data} /&gt;\n        &lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&gt;\n      &lt;/div&gt;\n    );\n  }\n});\n</pre>\n<h3 id=\"congrats\">\nCongrats! </h3> <p>You have just built a comment box in a few simple steps. Learn more about <a href=\"why-react\">why to use React</a>, or dive into the <a href=\"top-level-api\">API reference</a> and start hacking! Good luck!</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/tutorial.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/tutorial.html</a>\n  </p>\n</div>\n","docs/tooling-integration":"<h1> Tooling Integration </h1>  <p>We've tried to make React as environment-agnostic as possible. People use React in a variety of languages (JavaScript, TypeScript, ClojureScript, etc) and in a variety of environments (web, iOS, Android, NodeJS, Nashorn, etc). There are many tools to help you build great applications. In these sections we introduce some of the tools that are most commonly used together with React.</p> <ul> <li>\n<a href=\"language-tooling\">Language Tooling</a> describes how to set up tools like Babel to transpile JSX for a better development experience.</li> <li>\n<a href=\"package-management\">Package Management</a> describes how to configure React as a dependency of your project.</li> <li>\n<a href=\"environments\">Server-side Environments</a> describes how to configure your environment for server-side rendering with React.</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/tooling-integration.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/tooling-integration.html</a>\n  </p>\n</div>\n","docs/addons":"<h1> Add-ons </h1>  <p>The React add-ons are a collection of useful utility modules for building React apps. <strong>These should be considered experimental</strong> and tend to change more often than the core.</p> <ul> <li>\n<a href=\"animation\"><code>TransitionGroup</code> and <code>CSSTransitionGroup</code></a>, for dealing with animations and transitions that are usually not simple to implement, such as before a component's removal.</li> <li>\n<a href=\"two-way-binding-helpers\"><code>LinkedStateMixin</code></a>, to simplify the coordination between user's form input data and the component's state.</li> <li>\n<a href=\"clone-with-props\"><code>cloneWithProps</code></a>, to make shallow copies of React components and change their props.</li> <li>\n<a href=\"create-fragment\"><code>createFragment</code></a>, to create a set of externally-keyed children.</li> <li>\n<a href=\"update\"><code>update</code></a>, a helper function that makes dealing with immutable data in JavaScript easier.</li> <li>\n<a href=\"pure-render-mixin\"><code>PureRenderMixin</code></a>, a performance booster under certain situations.</li> <li>\n<a href=\"shallow-compare\"><code>shallowCompare</code></a>, a helper function that performs a shallow comparison for props and state in a component to decide if a component should update.</li> </ul> <p>The add-ons below are in the development (unminified) version of React only:</p> <ul> <li>\n<a href=\"test-utils\"><code>TestUtils</code></a>, simple helpers for writing test cases.</li> <li>\n<a href=\"perf\"><code>Perf</code></a>, a performance profiling tool for finding optimization opportunities.</li> </ul> <p>To get the add-ons, install them individually from npm (e.g., <code>npm install react-addons-pure-render-mixin</code>). We don't support using the addons if you're not using npm.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/addons.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/addons.html</a>\n  </p>\n</div>\n","docs/jsx-spread":"<h1> JSX Spread Attributes </h1>  <p>If you know all the properties that you want to place on a component ahead of time, it is easy to use JSX:</p> <pre class=\"highlight\" data-language=\"javascript\">  var component = &lt;Component foo={x} bar={y} /&gt;;\n</pre>\n<h2 id=\"mutating-props-is-bad\">\nMutating Props is Bad </h2> <p>If you don't know which properties you want to set, you might be tempted to add them onto the object later:</p> <pre class=\"highlight\" data-language=\"javascript\">  var component = &lt;Component /&gt;;\n  component.props.foo = x; // bad\n  component.props.bar = y; // also bad\n</pre> <p>This is an anti-pattern because it means that we can't help you check the right propTypes until way later. This means that your propTypes errors end up with a cryptic stack trace.</p> <p>The props should be considered immutable. Mutating the props object somewhere else could cause unexpected consequences so ideally it would be a frozen object at this point.</p> <h2 id=\"spread-attributes\">\nSpread Attributes </h2> <p>Now you can use a new feature of JSX called spread attributes:</p> <pre class=\"highlight\" data-language=\"javascript\">  var props = {};\n  props.foo = x;\n  props.bar = y;\n  var component = &lt;Component {...props} /&gt;;\n</pre> <p>The properties of the object that you pass in are copied onto the component's props.</p> <p>You can use this multiple times or combine it with other attributes. The specification order is important. Later attributes override previous ones.</p> <pre class=\"highlight\" data-language=\"javascript\">  var props = { foo: 'default' };\n  var component = &lt;Component {...props} foo={'override'} /&gt;;\n  console.log(component.props.foo); // 'override'\n</pre>\n<h2 id=\"whats-with-the-weird-...-notation\">\nWhat's with the weird <code>...</code> notation? </h2> <p>The <code>...</code> operator (or spread operator) is already supported for <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator\">arrays in ES6</a>. There is also an ECMAScript proposal for <a href=\"https://github.com/sebmarkbage/ecmascript-rest-spread\">Object Rest and Spread Properties</a>. We're taking advantage of these supported and developing standards in order to provide a cleaner syntax in JSX.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/jsx-spread.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/jsx-spread.html</a>\n  </p>\n</div>\n","docs/jsx-gotchas":"<h1> JSX Gotchas </h1>  <p>JSX looks like HTML but there are some important differences you may run into.</p> <blockquote>  <p>For DOM differences, such as the inline <code>style</code> attribute, check <a href=\"dom-differences\">here</a>.</p> </blockquote> <h2 id=\"html-entities\">\nHTML Entities </h2> <p>You can insert HTML entities within literal text in JSX:</p> <pre class=\"highlight\" data-language=\"javascript\">&lt;div&gt;First &amp;middot; Second&lt;/div&gt;\n</pre> <p>If you want to display an HTML entity within dynamic content, you will run into double escaping issues as React escapes all the strings you are displaying in order to prevent a wide range of XSS attacks by default.</p> <pre class=\"highlight\" data-language=\"javascript\">// Bad: It displays \"First &amp;middot; Second\"\n&lt;div&gt;{'First &amp;middot; Second'}&lt;/div&gt;\n</pre> <p>There are various ways to work-around this issue. The easiest one is to write Unicode characters directly in JavaScript. You need to make sure that the file is saved as UTF-8 and that the proper UTF-8 directives are set so the browser will display it correctly.</p> <pre class=\"highlight\" data-language=\"javascript\">&lt;div&gt;{'First Â· Second'}&lt;/div&gt;\n</pre> <p>A safer alternative is to find the <a href=\"http://www.fileformat.info/info/unicode/char/b7/index.htm\">unicode number corresponding to the entity</a> and use it inside of a JavaScript string.</p> <pre class=\"highlight\" data-language=\"javascript\">&lt;div&gt;{'First \\u00b7 Second'}&lt;/div&gt;\n&lt;div&gt;{'First ' + String.fromCharCode(183) + ' Second'}&lt;/div&gt;\n</pre> <p>You can use mixed arrays with strings and JSX elements. Each JSX element in the array needs a unique key.</p> <pre class=\"highlight\" data-language=\"javascript\">&lt;div&gt;{['First ', &lt;span key=\"middot\"&gt;&amp;middot;&lt;/span&gt;, ' Second']}&lt;/div&gt;\n</pre> <p>As a last resort, you always have the ability to <a href=\"../tips/dangerously-set-inner-html\">insert raw HTML</a>.</p> <pre class=\"highlight\" data-language=\"javascript\">&lt;div dangerouslySetInnerHTML={{__html: 'First &amp;middot; Second'}} /&gt;\n</pre>\n<h2 id=\"custom-html-attributes\">\nCustom HTML Attributes </h2> <p>If you pass properties to native HTML elements that do not exist in the HTML specification, React will not render them. If you want to use a custom attribute, you should prefix it with <code>data-</code>.</p> <pre class=\"highlight\" data-language=\"javascript\">&lt;div data-custom-attribute=\"foo\" /&gt;\n</pre> <p>However, arbitrary attributes are supported on custom elements (those with a hyphen in the tag name or an <code>is=\"...\"</code> attribute).</p> <pre class=\"highlight\" data-language=\"javascript\">&lt;x-my-component custom-attribute=\"foo\" /&gt;\n</pre> <p><a href=\"http://www.w3.org/WAI/intro/aria\">Web Accessibility</a> attributes starting with <code>aria-</code> will be rendered properly.</p> <pre class=\"highlight\" data-language=\"javascript\">&lt;div aria-hidden={true} /&gt;\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/jsx-gotchas.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/jsx-gotchas.html</a>\n  </p>\n</div>\n","docs/working-with-the-browser":"<h1> Working With the Browser </h1>  <p>React provides powerful abstractions that free you from touching the DOM directly in most cases, but sometimes you simply need to access the underlying API, perhaps to work with a third-party library or existing code.</p> <h2 id=\"the-virtual-dom\">\nThe Virtual DOM </h2> <p>React is very fast because it never talks to the DOM directly. React maintains a fast in-memory representation of the DOM. <code>render()</code> methods actually return a <em>description</em> of the DOM, and React can compare this description with the in-memory representation to compute the fastest way to update the browser.</p> <p>Additionally, React implements a full synthetic event system such that all event objects are guaranteed to conform to the W3C spec despite browser quirks, and everything bubbles consistently and efficiently across browsers. You can even use some HTML5 events in older browsers that don't ordinarily support them!</p> <p>Most of the time you should stay within React's \"faked browser\" world since it's more performant and easier to reason about. However, sometimes you simply need to access the underlying API, perhaps to work with a third-party library like a jQuery plugin. React provides escape hatches for you to use the underlying DOM API directly.</p> <h2 id=\"refs-and-finddomnode\">\nRefs and findDOMNode() </h2> <p>To interact with the browser, you'll need a reference to a DOM node. You can attach a <code>ref</code> to any element, which allows you to reference the <strong>backing instance</strong> of the component. This is useful if you need to invoke imperative functions on the component, or want to access the underlying DOM nodes. To learn more about refs, including ways to use them effectively, see our <a href=\"more-about-refs\">refs to components</a> documentation.</p> <h2 id=\"component-lifecycle\">\nComponent Lifecycle </h2> <p>Components have three main parts of their lifecycle:</p> <ul> <li>\n<strong>Mounting:</strong> A component is being inserted into the DOM.</li> <li>\n<strong>Updating:</strong> A component is being re-rendered to determine if the DOM should be updated.</li> <li>\n<strong>Unmounting:</strong> A component is being removed from the DOM.</li> </ul> <p>React provides lifecycle methods that you can specify to hook into this process. We provide <strong>will</strong> methods, which are called right before something happens, and <strong>did</strong> methods which are called right after something happens.</p> <h3 id=\"mounting\">\nMounting </h3> <ul> <li>\n<code>getInitialState(): object</code> is invoked before a component is mounted. Stateful components should implement this and return the initial state data.</li> <li>\n<code>componentWillMount()</code> is invoked immediately before mounting occurs.</li> <li>\n<code>componentDidMount()</code> is invoked immediately after mounting occurs. Initialization that requires DOM nodes should go here.</li> </ul> <h3 id=\"updating\">\nUpdating </h3> <ul> <li>\n<code>componentWillReceiveProps(object nextProps)</code> is invoked when a mounted component receives new props. This method should be used to compare <code>this.props</code> and <code>nextProps</code> to perform state transitions using <code>this.setState()</code>.</li> <li>\n<code>shouldComponentUpdate(object nextProps, object nextState): boolean</code> is invoked when a component decides whether any changes warrant an update to the DOM. Implement this as an optimization to compare <code>this.props</code> with <code>nextProps</code> and <code>this.state</code> with <code>nextState</code> and return <code>false</code> if React should skip updating.</li> <li>\n<code>componentWillUpdate(object nextProps, object nextState)</code> is invoked immediately before updating occurs. You cannot call <code>this.setState()</code> here.</li> <li>\n<code>componentDidUpdate(object prevProps, object prevState)</code> is invoked immediately after updating occurs.</li> </ul> <h3 id=\"unmounting\">\nUnmounting </h3> <ul> <li>\n<code>componentWillUnmount()</code> is invoked immediately before a component is unmounted and destroyed. Cleanup should go here.</li> </ul> <h3 id=\"mounted-methods\">\nMounted Methods </h3> <p><em>Mounted</em> composite components also support the following method:</p> <ul> <li>\n<code>component.forceUpdate()</code> can be invoked on any mounted component when you know that some deeper aspect of the component's state has changed without using <code>this.setState()</code>.</li> </ul> <h2 id=\"browser-support\">\nBrowser Support </h2> <p>React supports most popular browsers, including Internet Explorer 9 and above.</p> <p>(We don't support older browsers that don't support ES5 methods, but you may find that your apps do work in older browsers if polyfills such as <a href=\"https://github.com/es-shims/es5-shim\">es5-shim and es5-sham</a> are included in the page. You're on your own if you choose to take this path.)</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/working-with-the-browser.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/working-with-the-browser.html</a>\n  </p>\n</div>\n","docs/package-management":"<h1> Package Management </h1>  <h2 id=\"cdn-hosted-react\">\nCDN-hosted React </h2> <p>We provide CDN-hosted versions of React <a href=\"https://facebook.github.io/react/downloads.html\">on our download page</a>. These pre-built files use the UMD module format. Dropping them in with a simple <code>&lt;script&gt;</code> tag will inject the <code>React</code> and <code>ReactDOM</code> globals into your environment. It should also work out-of-the-box in CommonJS and AMD environments.</p> <h2 id=\"using-react-from-npm\">\nUsing React from npm </h2> <p>You can use React with a CommonJS module system like <a href=\"http://browserify.org/\">browserify</a> or <a href=\"https://webpack.github.io/\">webpack</a>. Use the <a href=\"https://www.npmjs.com/package/react\"><code>react</code></a> and <a href=\"https://www.npmjs.com/package/react-dom\"><code>react-dom</code></a> npm packages.</p> <pre class=\"highlight\" data-language=\"js\">// main.js\nvar React = require('react');\nvar ReactDOM = require('react-dom');\n\nReactDOM.render(\n  &lt;h1&gt;Hello, world!&lt;/h1&gt;,\n  document.getElementById('example')\n);\n</pre> <p>Configure <a href=\"https://babeljs.io/\">babel</a> with a <code>.babelrc</code> file:</p> <pre class=\"highlight\" data-language=\"json\"> { \"presets\": [\"react\"] }\n</pre> <blockquote>  <p>If you are using ES2015, you will want to also use the <code>babel-preset-es2015</code> package.</p> </blockquote> <p>To install React DOM and build your bundle with browserify:</p> <pre class=\"highlight\" data-language=\"sh\">$ npm install --save react react-dom babelify babel-preset-react\n$ browserify -t [ babelify ] main.js -o bundle.js\n</pre> <p>To install React DOM and build your bundle with webpack:</p> <pre class=\"highlight\" data-language=\"sh\">$ npm install --save react react-dom babel-preset-react babel-loader babel-core\n$ webpack main.js bundle.js --module-bind 'js=babel-loader'\n</pre> <blockquote>  <p>If you are using ES2015, you will want to also use the <code>babel-preset-es2015</code> package.</p> </blockquote> <p><strong>Note:</strong> by default, React will be in development mode, which is slower, and not advised for production. To use React in production mode, set the environment variable <code>NODE_ENV</code> to <code>production</code> (using envify or webpack's DefinePlugin). For example:</p> <pre class=\"highlight\" data-language=\"js\">new webpack.DefinePlugin({\n  \"process.env\": {\n    NODE_ENV: JSON.stringify(\"production\")\n  }\n});\n</pre> <p>Update your HTML file as below:</p> <pre class=\"highlight\" data-language=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;title&gt;Hello React!&lt;/title&gt;\n    &lt;script src=\"build/react.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"build/react-dom.js\"&gt;&lt;/script&gt;\n    &lt;!-- No need for Babel! --&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"example\"&gt;&lt;/div&gt;\n    &lt;script src=\"build/helloworld.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</pre>\n<h2 id=\"using-react-from-bower\">\nUsing React from Bower </h2> <p>Bower is a package manager optimized for the front-end development. If multiple packages depend on a package - jQuery for example - Bower will download jQuery just once. This is known as a flat dependency graph and it helps reduce page load. For more info, visit http://bower.io/</p> <p>If you'd like to use bower, it's as easy as:</p> <pre class=\"highlight\" data-language=\"text\">bower install --save react\n</pre>\n<pre class=\"highlight\" data-language=\"html\">&lt;!DOCTYPE html&gt;\n\n\n\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;title&gt;Hello React!&lt;/title&gt;\n    &lt;script src=\"bower_components/react/react.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"bower_components/react/react-dom.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.34/browser.min.js\"&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"example\"&gt;&lt;/div&gt;\n    &lt;script type=\"text/babel\"&gt;\n      ReactDOM.render(\n        &lt;h1&gt;Hello, world!&lt;/h1&gt;,\n        document.getElementById('example')\n      );\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</pre>\n<h2 id=\"using-master\">\nUsing master </h2> <p>We have instructions for building from <code>master</code> <a href=\"https://github.com/facebook/react\">in our GitHub repository</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/package-management.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/package-management.html</a>\n  </p>\n</div>\n","docs/environments":"<h1> Server-side Environments </h1>  <p>One of the great things about React is that it doesn't require the DOM as a dependency, which means it is possible to render a React application on the server and send the HTML markup down to the client. There are a few things that React expects, so this guide will help you get started in your preferred environment.</p> <h2 id=\"node.js\">\nNode.js </h2> <p><a href=\"http://nodejs.org/\">Node.js</a> is a popular JavaScript runtime that comes with an extensive core library and support for installing packages from npm to expand on the basic functionality. As we've described elsewhere in the documentation, you can install <code>react</code> and <code>react-dom</code> from npm.</p> <p>Example:</p> <pre class=\"highlight\" data-language=\"js\">var React = require('react');\nvar ReactDOMServer = require('react-dom/server');\n\nvar element = React.createElement('div', null, 'Hello World!');\nconsole.log(ReactDOMServer.renderToString(element));\n</pre> <p>If you use JSX, you may want to pre-compile your components. Alternatively you may want to consider using <a href=\"https://babeljs.io/docs/usage/require/\">Babel's require hook</a> or <a href=\"https://babeljs.io/docs/usage/cli/#babel-node\"><code>babel-node</code></a>.</p> <blockquote>  <p>Some versions of Node.js have an <code>Object.assign</code> implementation that does not preserve key order. This can cause errors when validating the markup, creating a warning that says \"React attempted to reuse markup in a container but the checksum was invalid\". If you run into this issue, you can override <code>Object.assign</code> to use a polyfill that preserves key order. For more details, see <a href=\"https://github.com/facebook/react/issues/6451\">Issue #6451</a>.</p> </blockquote> <h1 id=\"c\">\nC# </h1> <p>Support for server-side component rendering and JSX compilation (via Babel) in a .NET Framework / ASP.NET environment is provided through our <a href=\"http://reactjs.net/\">ReactJS.NET</a> project.</p> <h2 id=\"nashorn\">\nNashorn </h2> <p>Nashorn is a lightweight high-performance JavaScript runtime that runs within the JVM. React should run out of the box in Java 8+.</p> <p>Example:</p> <pre class=\"highlight\" data-language=\"java\">import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.FileReader;\n\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptException;\n\npublic class ReactRender\n{\n  public static void main(String[] args) throws ScriptException, IOException {\n    ScriptEngine nashorn = new ScriptEngineManager().getEngineByName(\"nashorn\");\n\n    // These files can be downloaded as a part of the starter kit\n    // from https://facebook.github.io/react\n    nashorn.eval(new FileReader(\"path/to/react.js\"));\n    nashorn.eval(new FileReader(\"path/to/react-dom-server.js\"));\n\n    System.out.println(nashorn.eval(\n      \"ReactDOMServer.renderToString(\" +\n        \"React.createElement('div', null, 'Hello World!')\" +\n      \");\"\n    ));\n  }\n}\n</pre> <p>If your application uses npm packages, or you want to transform JSX in Nashorn, you will need to do some additional environment setup. The following resources may be helpful in getting you started:</p> <ul> <li><a href=\"http://winterbe.com/posts/2015/02/16/isomorphic-react-webapps-on-the-jvm/\">http://winterbe.com/posts/2015/02/16/isomorphic-react-webapps-on-the-jvm/</a></li> <li><a href=\"https://github.com/nodyn/jvm-npm\">https://github.com/nodyn/jvm-npm</a></li> <li><a href=\"https://gist.github.com/aesteve/883e0fd33390451cb8eb\">https://gist.github.com/aesteve/883e0fd33390451cb8eb</a></li> </ul> <blockquote>  <p>Using Babel within Nashorn will require Java 8u72+, as update 72 fixed <a href=\"https://bugs.openjdk.java.net/browse/JDK-8135190\">JDK-8135190</a>.</p> </blockquote><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/environments.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/environments.html</a>\n  </p>\n</div>\n","docs/interactivity-and-dynamic-uis":"<h1> Interactivity and Dynamic UIs </h1>  <p>You've already <a href=\"displaying-data\">learned how to display data</a> with React. Now let's look at how to make our UIs interactive.</p> <h2 id=\"a-simple-example\">\nA Simple Example </h2>\n<pre class=\"highlight\" data-language=\"javascript\">class LikeButton extends React.Component {\n  constructor() {\n    super();\n    this.state = {\n      liked: false\n    };\n    this.handleClick = this.handleClick.bind(this);\n  }\n  handleClick() {\n    this.setState({liked: !this.state.liked});\n  }\n  render() {\n    const text = this.state.liked ? 'liked' : 'haven\\'t liked';\n    return (\n      &lt;div onClick={this.handleClick}&gt;\n        You {text} this. Click to toggle.\n      &lt;/div&gt;\n    );\n  }\n}\n\nReactDOM.render(\n  &lt;LikeButton /&gt;,\n  document.getElementById('example')\n);\n</pre>\n<h2 id=\"event-handling-and-synthetic-events\">\nEvent Handling and Synthetic Events </h2> <p>With React you simply pass your event handler as a camelCased prop similar to how you'd do it in normal HTML. React ensures that all events behave similarly in all browsers by implementing a synthetic event system. That is, React knows how to bubble and capture events according to the spec, and the events passed to your event handler are guaranteed to be consistent with <a href=\"http://www.w3.org/TR/DOM-Level-3-Events/\">the W3C spec</a>, regardless of which browser you're using.</p> <h2 id=\"under-the-hood-autobinding-and-event-delegation\">\nUnder the Hood: Autobinding and Event Delegation </h2> <p>Under the hood, React does a few things to keep your code performant and easy to understand.</p> <p><strong>Autobinding:</strong> When creating callbacks in JavaScript, you usually need to explicitly bind a method to its instance such that the value of <code>this</code> is correct. With React, every method is automatically bound to its component instance (<a href=\"reusable-components#no-autobinding\">except when using ES6 class syntax</a>). React caches the bound method such that it's extremely CPU and memory efficient. It's also less typing!</p> <p><strong>Event delegation:</strong> React doesn't actually attach event handlers to the nodes themselves. When React starts up, it starts listening for all events at the top level using a single event listener. When a component is mounted or unmounted, the event handlers are simply added or removed from an internal mapping. When an event occurs, React knows how to dispatch it using this mapping. When there are no event handlers left in the mapping, React's event handlers are simple no-ops. To learn more about why this is fast, see <a href=\"http://davidwalsh.name/event-delegate\">David Walsh's excellent blog post</a>.</p> <h2 id=\"components-are-just-state-machines\">\nComponents are Just State Machines </h2> <p>React thinks of UIs as simple state machines. By thinking of a UI as being in various states and rendering those states, it's easy to keep your UI consistent.</p> <p>In React, you simply update a component's state, and then render a new UI based on this new state. React takes care of updating the DOM for you in the most efficient way.</p> <h2 id=\"how-state-works\">\nHow State Works </h2> <p>A common way to inform React of a data change is by calling <code>setState(data, callback)</code>. This method merges <code>data</code> into <code>this.state</code> and re-renders the component. When the component finishes re-rendering, the optional <code>callback</code> is called. Most of the time you'll never need to provide a <code>callback</code> since React will take care of keeping your UI up-to-date for you.</p> <h2 id=\"what-components-should-have-state\">\nWhat Components Should Have State? </h2> <p>Most of your components should simply take some data from <code>props</code> and render it. However, sometimes you need to respond to user input, a server request or the passage of time. For this you use state.</p> <p><strong>Try to keep as many of your components as possible stateless.</strong> By doing this you'll isolate the state to its most logical place and minimize redundancy, making it easier to reason about your application.</p> <p>A common pattern is to create several stateless components that just render data, and have a stateful component above them in the hierarchy that passes its state to its children via <code>props</code>. The stateful component encapsulates all of the interaction logic, while the stateless components take care of rendering data in a declarative way.</p> <h2 id=\"what-should-go-in-state\">\nWhat <em>Should</em> Go in State? </h2> <p><strong>State should contain data that a component's event handlers may change to trigger a UI update.</strong> In real apps this data tends to be very small and JSON-serializable. When building a stateful component, think about the minimal possible representation of its state, and only store those properties in <code>this.state</code>. Inside of <code>render()</code> simply compute any other information you need based on this state. You'll find that thinking about and writing applications in this way tends to lead to the most correct application, since adding redundant or computed values to state means that you need to explicitly keep them in sync rather than rely on React computing them for you.</p> <h2 id=\"what-shouldnt-go-in-state\">\nWhat <em>Shouldn't</em> Go in State? </h2> <p><code>this.state</code> should only contain the minimal amount of data needed to represent your UI's state. As such, it should not contain:</p> <ul> <li>\n<strong>Computed data:</strong> Don't worry about precomputing values based on state â it's easier to ensure that your UI is consistent if you do all computation within <code>render()</code>. For example, if you have an array of list items in state and you want to render the count as a string, simply render <code>this.state.listItems.length + ' list items'</code> in your <code>render()</code> method rather than storing it on state.</li> <li>\n<strong>React components:</strong> Build them in <code>render()</code> based on underlying props and state.</li> <li>\n<strong>Duplicated data from props:</strong> Try to use props as the source of truth where possible. One valid use to store props in state is to be able to know its previous values, because props may change as the result of a parent component re-rendering.</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html</a>\n  </p>\n</div>\n","docs/two-way-binding-helpers":"<h1> Two-Way Binding Helpers </h1>  <p><code>ReactLink</code> is an easy way to express two-way binding with React.</p> <blockquote>  <p>ReactLink is deprecated as of React v15. The recommendation is to explicitly set the value and change handler, instead of using ReactLink.</p> </blockquote> <p>In React, data flows one way: from owner to child. This is because data only flows one direction in <a href=\"https://en.wikipedia.org/wiki/Von_Neumann_architecture\">the Von Neumann model of computing</a>. You can think of it as \"one-way data binding.\"</p> <p>However, there are lots of applications that require you to read some data and flow it back into your program. For example, when developing forms, you'll often want to update some React <code>state</code> when you receive user input. Or perhaps you want to perform layout in JavaScript and react to changes in some DOM element size.</p> <p>In React, you would implement this by listening to a \"change\" event, read from your data source (usually the DOM) and call <code>setState()</code> on one of your components. \"Closing the data flow loop\" explicitly leads to more understandable and easier-to-maintain programs. See <a href=\"forms\">our forms documentation</a> for more information.</p> <p>Two-way binding -- implicitly enforcing that some value in the DOM is always consistent with some React <code>state</code> -- is concise and supports a wide variety of applications. We've provided <code>ReactLink</code>: syntactic sugar for setting up the common data flow loop pattern described above, or \"linking\" some data source to React <code>state</code>.</p> <blockquote>  <p><code>ReactLink</code> is just a thin wrapper and convention around the <code>onChange</code>/<code>setState()</code> pattern. It doesn't fundamentally change how data flows in your React application.</p> </blockquote> <h2 id=\"reactlink-before-and-after\">\nReactLink: Before and After </h2> <p>Here's a simple form example without using <code>ReactLink</code>:</p> <pre class=\"highlight\" data-language=\"javascript\">var NoLink = React.createClass({\n  getInitialState: function() {\n    return {message: 'Hello!'};\n  },\n  handleChange: function(event) {\n    this.setState({message: event.target.value});\n  },\n  render: function() {\n    var message = this.state.message;\n    return &lt;input type=\"text\" value={message} onChange={this.handleChange} /&gt;;\n  }\n});\n</pre> <p>This works really well and it's very clear how data is flowing, however, with a lot of form fields it could get a bit verbose. Let's use <code>ReactLink</code> to save us some typing:</p> <pre class=\"highlight\" data-language=\"javascript\">var LinkedStateMixin = require('react-addons-linked-state-mixin');\n\nvar WithLink = React.createClass({\n  mixins: [LinkedStateMixin],\n  getInitialState: function() {\n    return {message: 'Hello!'};\n  },\n  render: function() {\n    return &lt;input type=\"text\" valueLink={this.linkState('message')} /&gt;;\n  }\n});\n</pre> <p><code>LinkedStateMixin</code> adds a method to your React component called <code>linkState()</code>. <code>linkState()</code> returns a <code>ReactLink</code> object which contains the current value of the React state and a callback to change it.</p> <p><code>ReactLink</code> objects can be passed up and down the tree as props, so it's easy (and explicit) to set up two-way binding between a component deep in the hierarchy and state that lives higher in the hierarchy.</p> <p>Note that checkboxes have a special behavior regarding their <code>value</code> attribute, which is the value that will be sent on form submit if the checkbox is checked (defaults to <code>on</code>). The <code>value</code> attribute is not updated when the checkbox is checked or unchecked. For checkboxes, you should use <code>checkedLink</code> instead of <code>valueLink</code>: <code>\n&lt;input type=\"checkbox\" checkedLink={this.linkState('booleanValue')} /&gt;\n</code></p> <h2 id=\"under-the-hood\">\nUnder the Hood </h2> <p>There are two sides to <code>ReactLink</code>: the place where you create the <code>ReactLink</code> instance and the place where you use it. To prove how simple <code>ReactLink</code> is, let's rewrite each side separately to be more explicit.</p> <h3 id=\"reactlink-without-linkedstatemixin\">\nReactLink Without LinkedStateMixin </h3>\n<pre class=\"highlight\" data-language=\"javascript\">var WithoutMixin = React.createClass({\n  getInitialState: function() {\n    return {message: 'Hello!'};\n  },\n  handleChange: function(newValue) {\n    this.setState({message: newValue});\n  },\n  render: function() {\n    var valueLink = {\n      value: this.state.message,\n      requestChange: this.handleChange\n    };\n    return &lt;input type=\"text\" valueLink={valueLink} /&gt;;\n  }\n});\n</pre> <p>As you can see, <code>ReactLink</code> objects are very simple objects that just have a <code>value</code> and <code>requestChange</code> prop. And <code>LinkedStateMixin</code> is similarly simple: it just populates those fields with a value from <code>this.state</code> and a callback that calls <code>this.setState()</code>.</p> <h3 id=\"reactlink-without-valuelink\">\nReactLink Without valueLink </h3>\n<pre class=\"highlight\" data-language=\"javascript\">var LinkedStateMixin = require('react-addons-linked-state-mixin');\n\nvar WithoutLink = React.createClass({\n  mixins: [LinkedStateMixin],\n  getInitialState: function() {\n    return {message: 'Hello!'};\n  },\n  render: function() {\n    var valueLink = this.linkState('message');\n    var handleChange = function(e) {\n      valueLink.requestChange(e.target.value);\n    };\n    return &lt;input type=\"text\" value={valueLink.value} onChange={handleChange} /&gt;;\n  }\n});\n</pre> <p>The <code>valueLink</code> prop is also quite simple. It simply handles the <code>onChange</code> event and calls <code>this.props.valueLink.requestChange()</code> and also uses <code>this.props.valueLink.value</code> instead of <code>this.props.value</code>. That's it!</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/two-way-binding-helpers.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/two-way-binding-helpers.html</a>\n  </p>\n</div>\n","docs/displaying-data":"<h1> Displaying Data </h1>  <p>The most basic thing you can do with a UI is display some data. React makes it easy to display data and automatically keeps the interface up-to-date when the data changes.</p> <h2 id=\"getting-started\">\nGetting Started </h2> <p>Let's look at a really simple example. Create a <code>hello-react.html</code> file with the following code:</p> <pre class=\"highlight\" data-language=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;title&gt;Hello React&lt;/title&gt;\n    &lt;script src=\"https://fb.me/react-15.3.0.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://fb.me/react-dom-15.3.0.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.34/browser.min.js\"&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"example\"&gt;&lt;/div&gt;\n    &lt;script type=\"text/babel\"&gt;\n\n      // ** Your code goes here! **\n\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</pre> <p>For the rest of the documentation, we'll just focus on the JavaScript code and assume it's inserted into a template like the one above. Replace the placeholder comment above with the following JSX:</p> <pre class=\"highlight\" data-language=\"javascript\">var HelloWorld = React.createClass({\n  render: function() {\n    return (\n      &lt;p&gt;\n        Hello, &lt;input type=\"text\" placeholder=\"Your name here\" /&gt;!\n        It is {this.props.date.toTimeString()}\n      &lt;/p&gt;\n    );\n  }\n});\n\nsetInterval(function() {\n  ReactDOM.render(\n    &lt;HelloWorld date={new Date()} /&gt;,\n    document.getElementById('example')\n  );\n}, 500);\n</pre>\n<h2 id=\"reactive-updates\">\nReactive Updates </h2> <p>Open <code>hello-react.html</code> in a web browser and type your name into the text field. Notice that React is only changing the time string in the UI â any input you put in the text field remains, even though you haven't written any code to manage this behavior. React figures it out for you and does the right thing.</p> <p>The way we are able to figure this out is that React does not manipulate the DOM unless it needs to. <strong>It uses a fast, internal mock DOM to perform diffs and computes the most efficient DOM mutation for you.</strong></p> <p>The inputs to this component are called <code>props</code> â short for \"properties\". They're passed as attributes in JSX syntax. You should think of these as immutable within the component, that is, <strong>never write to <code>this.props</code></strong>.</p> <h2 id=\"components-are-just-like-functions\">\nComponents are Just Like Functions </h2> <p>React components are very simple. You can think of them as simple functions that take in <code>props</code> and <code>state</code> (discussed later) and render HTML. With this in mind, components are easy to reason about.</p> <blockquote>  <p><strong>One limitation</strong>: React components can only render a single root node. If you want to return multiple nodes they <em>must</em> be wrapped in a single root.</p> </blockquote> <h2 id=\"jsx-syntax\">\nJSX Syntax </h2> <p>We strongly believe that components are the right way to separate concerns rather than \"templates\" and \"display logic.\" We think that markup and the code that generates it are intimately tied together. Additionally, display logic is often very complex and using template languages to express it becomes cumbersome.</p> <p>We've found that the best solution for this problem is to generate HTML and component trees directly from the JavaScript code such that you can use all of the expressive power of a real programming language to build UIs.</p> <p>In order to make this easier, we've added a very simple, <strong>optional</strong> HTML-like syntax to create these React tree nodes.</p> <p><strong>JSX lets you create JavaScript objects using HTML syntax.</strong> To generate a link in React using pure JavaScript you'd write:</p> <p><code>React.createElement('a', {href: 'https://facebook.github.io/react/'}, 'Hello!')</code></p> <p>With JSX this becomes:</p> <p><code>&lt;a href=\"https://facebook.github.io/react/\"&gt;Hello!&lt;/a&gt;</code></p> <p>We've found this has made building React apps easier and designers tend to prefer the syntax, but everyone has their own workflow, so <strong>JSX is not required to use React.</strong></p> <p>JSX is very small. To learn more about it, see <a href=\"jsx-in-depth\">JSX in depth</a>. Or see the transform in action in <a href=\"https://babeljs.io/repl/\">the Babel REPL</a>.</p> <p>JSX is similar to HTML, but not exactly the same. See <a href=\"jsx-gotchas\">JSX gotchas</a> for some key differences.</p> <p><a href=\"http://babeljs.io/docs/setup/\">Babel exposes a number of ways to get started using JSX</a>, ranging from command line tools to Ruby on Rails integrations. Choose the tool that works best for you.</p> <h2 id=\"react-without-jsx\">\nReact without JSX </h2> <p>JSX is completely optional; you don't have to use JSX with React. You can create React elements in plain JavaScript using <code>React.createElement</code>, which takes a tag name or component, a properties object, and variable number of optional child arguments.</p> <pre class=\"highlight\" data-language=\"javascript\">var child1 = React.createElement('li', null, 'First Text Content');\nvar child2 = React.createElement('li', null, 'Second Text Content');\nvar root = React.createElement('ul', { className: 'my-list' }, child1, child2);\nReactDOM.render(root, document.getElementById('example'));\n</pre> <p>For convenience, you can create short-hand factory functions to create elements from custom components.</p> <pre class=\"highlight\" data-language=\"javascript\">var Factory = React.createFactory(ComponentClass);\n...\nvar root = Factory({ custom: 'prop' });\nReactDOM.render(root, document.getElementById('example'));\n</pre> <p>React already has built-in factories for common HTML tags:</p> <pre class=\"highlight\" data-language=\"javascript\">var root = React.DOM.ul({ className: 'my-list' },\n             React.DOM.li(null, 'Text Content')\n           );\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/displaying-data.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/displaying-data.html</a>\n  </p>\n</div>\n","docs/thinking-in-react":"<h1> Thinking in React </h1>  <p>by Pete Hunt</p> <p>React is, in my opinion, the premier way to build big, fast Web apps with JavaScript. It has scaled very well for us at Facebook and Instagram.</p> <p>One of the many great parts of React is how it makes you think about apps as you build them. In this post, I'll walk you through the thought process of building a searchable product data table using React.</p> <h2 id=\"start-with-a-mock\">\nStart with a mock </h2> <p>Imagine that we already have a JSON API and a mock from our designer. Our designer apparently isn't very good because the mock looks like this:</p> <p><img src=\"https://facebook.github.io/react/img/blog/thinking-in-react-mock.png\" alt=\"Mockup\"></p> <p>Our JSON API returns some data that looks like this:</p> <pre class=\"highlight\" data-language=\"text\">[\n  {category: \"Sporting Goods\", price: \"$49.99\", stocked: true, name: \"Football\"},\n  {category: \"Sporting Goods\", price: \"$9.99\", stocked: true, name: \"Baseball\"},\n  {category: \"Sporting Goods\", price: \"$29.99\", stocked: false, name: \"Basketball\"},\n  {category: \"Electronics\", price: \"$99.99\", stocked: true, name: \"iPod Touch\"},\n  {category: \"Electronics\", price: \"$399.99\", stocked: false, name: \"iPhone 5\"},\n  {category: \"Electronics\", price: \"$199.99\", stocked: true, name: \"Nexus 7\"}\n];\n</pre>\n<h2 id=\"step-1-break-the-ui-into-a-component-hierarchy\">\nStep 1: Break the UI into a component hierarchy </h2> <p>The first thing you'll want to do is to draw boxes around every component (and subcomponent) in the mock and give them all names. If you're working with a designer, they may have already done this, so go talk to them! Their Photoshop layer names may end up being the names of your React components!</p> <p>But how do you know what should be its own component? Just use the same techniques for deciding if you should create a new function or object. One such technique is the <a href=\"https://en.wikipedia.org/wiki/Single_responsibility_principle\">single responsibility principle</a>, that is, a component should ideally only do one thing. If it ends up growing, it should be decomposed into smaller subcomponents.</p> <p>Since you're often displaying a JSON data model to a user, you'll find that if your model was built correctly, your UI (and therefore your component structure) will map nicely. That's because UI and data models tend to adhere to the same <em>information architecture</em>, which means the work of separating your UI into components is often trivial. Just break it up into components that represent exactly one piece of your data model.</p> <p><img src=\"https://facebook.github.io/react/img/blog/thinking-in-react-components.png\" alt=\"Component diagram\"></p> <p>You'll see here that we have five components in our simple app. I've italicized the data each component represents.</p> <ol> <li>\n<strong><code>FilterableProductTable</code> (orange):</strong> contains the entirety of the example</li> <li>\n<strong><code>SearchBar</code> (blue):</strong> receives all <em>user input</em>\n</li> <li>\n<strong><code>ProductTable</code> (green):</strong> displays and filters the <em>data collection</em> based on <em>user input</em>\n</li> <li>\n<strong><code>ProductCategoryRow</code> (turquoise):</strong> displays a heading for each <em>category</em>\n</li> <li>\n<strong><code>ProductRow</code> (red):</strong> displays a row for each <em>product</em>\n</li> </ol> <p>If you look at <code>ProductTable</code>, you'll see that the table header (containing the \"Name\" and \"Price\" labels) isn't its own component. This is a matter of preference, and there's an argument to be made either way. For this example, I left it as part of <code>ProductTable</code> because it is part of rendering the <em>data collection</em> which is <code>ProductTable</code>'s responsibility. However, if this header grows to be complex (i.e. if we were to add affordances for sorting), it would certainly make sense to make this its own <code>ProductTableHeader</code> component.</p> <p>Now that we've identified the components in our mock, let's arrange them into a hierarchy. This is easy. Components that appear within another component in the mock should appear as a child in the hierarchy:</p> <ul> <li>\n<code>FilterableProductTable</code> <ul> <li><code>SearchBar</code></li> <li>\n<code>ProductTable</code> <ul> <li><code>ProductCategoryRow</code></li> <li><code>ProductRow</code></li> </ul>\n</li> </ul>\n</li> </ul> <h2 id=\"step-2-build-a-static-version-in-react\">\nStep 2: Build a static version in React </h2> <iframe width=\"100%\" height=\"600\" src=\"https://jsfiddle.net/reactjs/yun1vgqb/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe> <p>Now that you have your component hierarchy, it's time to implement your app. The easiest way is to build a version that takes your data model and renders the UI but has no interactivity. It's best to decouple these processes because building a static version requires a lot of typing and no thinking, and adding interactivity requires a lot of thinking and not a lot of typing. We'll see why.</p> <p>To build a static version of your app that renders your data model, you'll want to build components that reuse other components and pass data using <em>props</em>. <em>props</em> are a way of passing data from parent to child. If you're familiar with the concept of <em>state</em>, <strong>don't use state at all</strong> to build this static version. State is reserved only for interactivity, that is, data that changes over time. Since this is a static version of the app, you don't need it.</p> <p>You can build top-down or bottom-up. That is, you can either start with building the components higher up in the hierarchy (i.e. starting with <code>FilterableProductTable</code>) or with the ones lower in it (<code>ProductRow</code>). In simpler examples, it's usually easier to go top-down, and on larger projects, it's easier to go bottom-up and write tests as you build.</p> <p>At the end of this step, you'll have a library of reusable components that render your data model. The components will only have <code>render()</code> methods since this is a static version of your app. The component at the top of the hierarchy (<code>FilterableProductTable</code>) will take your data model as a prop. If you make a change to your underlying data model and call <code>ReactDOM.render()</code> again, the UI will be updated. It's easy to see how your UI is updated and where to make changes since there's nothing complicated going on. React's <strong>one-way data flow</strong> (also called <em>one-way binding</em>) keeps everything modular and fast.</p> <p>Simply refer to the <a href=\"https://facebook.github.io/react/docs/\">React docs</a> if you need help executing this step.</p> <h3 id=\"a-brief-interlude-props-vs-state\">\nA brief interlude: props vs state </h3> <p>There are two types of \"model\" data in React: props and state. It's important to understand the distinction between the two; skim <a href=\"interactivity-and-dynamic-uis\">the official React docs</a> if you aren't sure what the difference is.</p> <h2 id=\"step-3-identify-the-minimal-but-complete-representation-of-ui-state\">\nStep 3: Identify the minimal (but complete) representation of UI state </h2> <p>To make your UI interactive, you need to be able to trigger changes to your underlying data model. React makes this easy with <strong>state</strong>.</p> <p>To build your app correctly, you first need to think of the minimal set of mutable state that your app needs. The key here is DRY: <em>Don't Repeat Yourself</em>. Figure out the absolute minimal representation of the state your application needs and compute everything else you need on-demand. For example, if you're building a TODO list, just keep an array of the TODO items around; don't keep a separate state variable for the count. Instead, when you want to render the TODO count, simply take the length of the TODO items array.</p> <p>Think of all of the pieces of data in our example application. We have:</p> <ul> <li>The original list of products</li> <li>The search text the user has entered</li> <li>The value of the checkbox</li> <li>The filtered list of products</li> </ul> <p>Let's go through each one and figure out which one is state. Simply ask three questions about each piece of data:</p> <ol> <li>Is it passed in from a parent via props? If so, it probably isn't state.</li> <li>Does it remain unchanged over time? If so, it probably isn't state.</li> <li>Can you compute it based on any other state or props in your component? If so, it isn't state.</li> </ol> <p>The original list of products is passed in as props, so that's not state. The search text and the checkbox seem to be state since they change over time and can't be computed from anything. And finally, the filtered list of products isn't state because it can be computed by combining the original list of products with the search text and value of the checkbox.</p> <p>So finally, our state is:</p> <ul> <li>The search text the user has entered</li> <li>The value of the checkbox</li> </ul> <h2 id=\"step-4-identify-where-your-state-should-live\">\nStep 4: Identify where your state should live </h2> <iframe width=\"100%\" height=\"600\" src=\"https://jsfiddle.net/reactjs/zafjbw1e/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe> <p>OK, so we've identified what the minimal set of app state is. Next, we need to identify which component mutates, or <em>owns</em>, this state.</p> <p>Remember: React is all about one-way data flow down the component hierarchy. It may not be immediately clear which component should own what state. <strong>This is often the most challenging part for newcomers to understand,</strong> so follow these steps to figure it out:</p> <p>For each piece of state in your application:</p> <ul> <li>Identify every component that renders something based on that state.</li> <li>Find a common owner component (a single component above all the components that need the state in the hierarchy).</li> <li>Either the common owner or another component higher up in the hierarchy should own the state.</li> <li>If you can't find a component where it makes sense to own the state, create a new component simply for holding the state and add it somewhere in the hierarchy above the common owner component.</li> </ul> <p>Let's run through this strategy for our application:</p> <ul> <li>\n<code>ProductTable</code> needs to filter the product list based on state and <code>SearchBar</code> needs to display the search text and checked state.</li> <li>The common owner component is <code>FilterableProductTable</code>.</li> <li>It conceptually makes sense for the filter text and checked value to live in <code>FilterableProductTable</code>\n</li> </ul> <p>Cool, so we've decided that our state lives in <code>FilterableProductTable</code>. First, add a <code>getInitialState()</code> method to <code>FilterableProductTable</code> that returns <code>{filterText: '', inStockOnly: false}</code> to reflect the initial state of your application. Then, pass <code>filterText</code> and <code>inStockOnly</code> to <code>ProductTable</code> and <code>SearchBar</code> as a prop. Finally, use these props to filter the rows in <code>ProductTable</code> and set the values of the form fields in <code>SearchBar</code>.</p> <p>You can start seeing how your application will behave: set <code>filterText</code> to <code>\"ball\"</code> and refresh your app. You'll see that the data table is updated correctly.</p> <h2 id=\"step-5-add-inverse-data-flow\">\nStep 5: Add inverse data flow </h2> <iframe width=\"100%\" height=\"600\" src=\"https://jsfiddle.net/reactjs/n47gckhr/embedded/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe> <p>So far, we've built an app that renders correctly as a function of props and state flowing down the hierarchy. Now it's time to support data flowing the other way: the form components deep in the hierarchy need to update the state in <code>FilterableProductTable</code>.</p> <p>React makes this data flow explicit to make it easy to understand how your program works, but it does require a little more typing than traditional two-way data binding.</p> <p>If you try to type or check the box in the current version of the example, you'll see that React ignores your input. This is intentional, as we've set the <code>value</code> prop of the <code>input</code> to always be equal to the <code>state</code> passed in from <code>FilterableProductTable</code>.</p> <p>Let's think about what we want to happen. We want to make sure that whenever the user changes the form, we update the state to reflect the user input. Since components should only update their own state, <code>FilterableProductTable</code> will pass a callback to <code>SearchBar</code> that will fire whenever the state should be updated. We can use the <code>onChange</code> event on the inputs to be notified of it. And the callback passed by <code>FilterableProductTable</code> will call <code>setState()</code>, and the app will be updated.</p> <p>Though this sounds complex, it's really just a few lines of code. And it's really explicit how your data is flowing throughout the app.</p> <h2 id=\"and-thats-it\">\nAnd that's it </h2> <p>Hopefully, this gives you an idea of how to think about building components and applications with React. While it may be a little more typing than you're used to, remember that code is read far more than it's written, and it's extremely easy to read this modular, explicit code. As you start to build large libraries of components, you'll appreciate this explicitness and modularity, and with code reuse, your lines of code will start to shrink. :)</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/thinking-in-react.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/thinking-in-react.html</a>\n  </p>\n</div>\n","docs/transferring-props":"<h1> Transferring Props </h1>  <p>It's a common pattern in React to wrap a component in an abstraction. The outer component exposes a simple property to do something that might have more complex implementation details.</p> <p>You can use <a href=\"jsx-spread\">JSX spread attributes</a> to merge the old props with additional values:</p> <pre class=\"highlight\" data-language=\"javascript\">&lt;Component {...this.props} more=\"values\" /&gt;\n</pre> <p>If you don't use JSX, you can use any object helper such as ES6 <code>Object.assign</code> or Underscore <code>_.extend</code>:</p> <pre class=\"highlight\" data-language=\"javascript\">React.createElement(Component, Object.assign({}, this.props, { more: 'values' }));\n</pre> <p>The rest of this tutorial explains best practices. It uses JSX and experimental ECMAScript syntax.</p> <h2 id=\"manual-transfer\">\nManual Transfer </h2> <p>Most of the time you should explicitly pass the properties down. This ensures that you only expose a subset of the inner API, one that you know will work.</p> <pre class=\"highlight\" data-language=\"javascript\">function FancyCheckbox(props) {\n  var fancyClass = props.checked ? 'FancyChecked' : 'FancyUnchecked';\n  return (\n    &lt;div className={fancyClass} onClick={props.onClick}&gt;\n      {props.children}\n    &lt;/div&gt;\n  );\n}\nReactDOM.render(\n  &lt;FancyCheckbox checked={true} onClick={console.log.bind(console)}&gt;\n    Hello world!\n  &lt;/FancyCheckbox&gt;,\n  document.getElementById('example')\n);\n</pre> <p>But what about the <code>name</code> prop? Or the <code>title</code> prop? Or <code>onMouseOver</code>?</p> <h2 id=\"transferring-with-...-in-jsx\">\nTransferring with <code>...</code> in JSX </h2> <blockquote> <p>NOTE:</p> <p>The <code>...</code> syntax is part of the Object Rest Spread proposal. This proposal is on track to become a standard. See the <a href=\"transferring-props#rest-and-spread-properties-...\">Rest and Spread Properties ...</a> section below for more details.</p> </blockquote> <p>Sometimes it's fragile and tedious to pass every property along. In that case you can use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\">destructuring assignment</a> with rest properties to extract a set of unknown properties.</p> <p>List out all the properties that you would like to consume, followed by <code>...other</code>.</p> <pre class=\"highlight\" data-language=\"javascript\">var { checked, ...other } = props;\n</pre> <p>This ensures that you pass down all the props EXCEPT the ones you're consuming yourself.</p> <pre class=\"highlight\" data-language=\"javascript\">function FancyCheckbox(props) {\n  var { checked, ...other } = props;\n  var fancyClass = checked ? 'FancyChecked' : 'FancyUnchecked';\n  // `other` contains { onClick: console.log } but not the checked property\n  return (\n    &lt;div {...other} className={fancyClass} /&gt;\n  );\n}\nReactDOM.render(\n  &lt;FancyCheckbox checked={true} onClick={console.log.bind(console)}&gt;\n    Hello world!\n  &lt;/FancyCheckbox&gt;,\n  document.getElementById('example')\n);\n</pre> <blockquote> <p>NOTE:</p> <p>In the example above, the <code>checked</code> prop is also a valid DOM attribute. If you didn't use destructuring in this way you might inadvertently pass it along.</p> </blockquote> <p>Always use the destructuring pattern when transferring unknown <code>other</code> props.</p> <pre class=\"highlight\" data-language=\"javascript\">function FancyCheckbox(props) {\n  var fancyClass = props.checked ? 'FancyChecked' : 'FancyUnchecked';\n  // ANTI-PATTERN: `checked` would be passed down to the inner component\n  return (\n    &lt;div {...props} className={fancyClass} /&gt;\n  );\n}\n</pre>\n<h2 id=\"consuming-and-transferring-the-same-prop\">\nConsuming and Transferring the Same Prop </h2> <p>If your component wants to consume a property but also wants to pass it along, you can repass it explicitly with <code>checked={checked}</code>. This is preferable to passing the full <code>props</code> object since it's easier to refactor and lint.</p> <pre class=\"highlight\" data-language=\"javascript\">function FancyCheckbox(props) {\n  var { checked, title, ...other } = props;\n  var fancyClass = checked ? 'FancyChecked' : 'FancyUnchecked';\n  var fancyTitle = checked ? 'X ' + title : 'O ' + title;\n  return (\n    &lt;label&gt;\n      &lt;input {...other}\n        checked={checked}\n        className={fancyClass}\n        type=\"checkbox\"\n      /&gt;\n      {fancyTitle}\n    &lt;/label&gt;\n  );\n}\n</pre> <blockquote> <p>NOTE:</p> <p>Order matters. By putting the <code>{...other}</code> before your JSX props you ensure that the consumer of your component can't override them. In the example above we have guaranteed that the input will be of type <code>\"checkbox\"</code>.</p> </blockquote> <h2 id=\"rest-and-spread-properties-...\">\nRest and Spread Properties <code>...</code> </h2> <p>Rest properties allow you to extract the remaining properties from an object into a new object. It excludes every other property listed in the destructuring pattern.</p> <p>This is an experimental implementation of an <a href=\"https://github.com/sebmarkbage/ecmascript-rest-spread\">ECMAScript proposal</a>.</p> <pre class=\"highlight\" data-language=\"javascript\">var { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nx; // 1\ny; // 2\nz; // { a: 3, b: 4 }\n</pre> <blockquote>  <p>To transform rest and spread properties using Babel 6, you need to install the <a href=\"https://babeljs.io/docs/plugins/preset-es2015/\"><code>es2015</code></a> preset, the <a href=\"https://babeljs.io/docs/plugins/transform-object-rest-spread/\"><code>transform-object-rest-spread</code></a> plugin and configure them in the <code>.babelrc</code> file.</p> </blockquote> <h2 id=\"transferring-with-underscore\">\nTransferring with Underscore </h2> <p>If you don't use JSX, you can use a library to achieve the same pattern. Underscore supports <code>_.omit</code> to filter out properties and <code>_.extend</code> to copy properties onto a new object.</p> <pre class=\"highlight\" data-language=\"javascript\">function FancyCheckbox(props) {\n  var checked = props.checked;\n  var other = _.omit(props, 'checked');\n  var fancyClass = checked ? 'FancyChecked' : 'FancyUnchecked';\n  return (\n    React.DOM.div(_.extend({}, other, { className: fancyClass }))\n  );\n}\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/transferring-props.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/transferring-props.html</a>\n  </p>\n</div>\n","docs/forms":"<h1> Forms </h1>  <p>Form components such as <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, and <code>&lt;option&gt;</code> differ from other native components because they can be mutated via user interactions. These components provide interfaces that make it easier to manage forms in response to user interactions.</p> <p>For information on events on <code>&lt;form&gt;</code> see <a href=\"events#form-events\">Form Events</a>.</p> <h2 id=\"interactive-props\">\nInteractive Props </h2> <p>Form components support a few props that are affected via user interactions:</p> <ul> <li>\n<code>value</code>, supported by <code>&lt;input&gt;</code> and <code>&lt;textarea&gt;</code> components.</li> <li>\n<code>checked</code>, supported by <code>&lt;input&gt;</code> components of type <code>checkbox</code> or <code>radio</code>.</li> <li>\n<code>selected</code>, supported by <code>&lt;option&gt;</code> components.</li> </ul> <p>In HTML, the value of <code>&lt;textarea&gt;</code> is set via children. In React, you should use <code>value</code> instead.</p> <p>Form components allow listening for changes by setting a callback to the <code>onChange</code> prop. The <code>onChange</code> prop works across browsers to fire in response to user interactions when:</p> <ul> <li>The <code>value</code> of <code>&lt;input&gt;</code> or <code>&lt;textarea&gt;</code> changes.</li> <li>The <code>checked</code> state of <code>&lt;input&gt;</code> changes.</li> <li>The <code>selected</code> state of <code>&lt;option&gt;</code> changes.</li> </ul> <p>Like all DOM events, the <code>onChange</code> prop is supported on all native components and can be used to listen to bubbled change events.</p> <blockquote>  <p>For <code>&lt;input&gt;</code> and <code>&lt;textarea&gt;</code>, <code>onChange</code> supersedes â and should generally be used instead of â the DOM's built-in <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/oninput\"><code>oninput</code></a> event handler.</p> </blockquote> <h2 id=\"controlled-components\">\nControlled Components </h2> <p>A <strong>controlled</strong> <code>&lt;input&gt;</code> has a <code>value</code> prop. Rendering a controlled <code>&lt;input&gt;</code> will reflect the value of the <code>value</code> prop.</p> <pre class=\"highlight\" data-language=\"javascript\">  render: function() {\n    return &lt;input type=\"text\" value=\"Hello!\" /&gt;;\n  }\n</pre> <p>User input will have no effect on the rendered element because React has declared the value to be <code>Hello!</code>. To update the value in response to user input, you could use the <code>onChange</code> event:</p> <pre class=\"highlight\" data-language=\"javascript\">  getInitialState: function() {\n    return {value: 'Hello!'};\n  },\n  handleChange: function(event) {\n    this.setState({value: event.target.value});\n  },\n  render: function() {\n    return (\n      &lt;input\n        type=\"text\"\n        value={this.state.value}\n        onChange={this.handleChange}\n      /&gt;\n    );\n  }\n</pre> <p>In this example, we are accepting the value provided by the user and updating the <code>value</code> prop of the <code>&lt;input&gt;</code> component. This pattern makes it easy to implement interfaces that respond to or validate user interactions. For example:</p> <pre class=\"highlight\" data-language=\"javascript\">  handleChange: function(event) {\n    this.setState({value: event.target.value.substr(0, 140)});\n  }\n</pre> <p>This would accept user input and truncate the value to the first 140 characters.</p> <p>A <strong>Controlled</strong> component does not maintain its own internal state; the component renders purely based on props.</p> <h3 id=\"potential-issues-with-checkboxes-and-radio-buttons\">\nPotential Issues With Checkboxes and Radio Buttons </h3> <p>Be aware that, in an attempt to normalize change handling for checkbox and radio inputs, React uses a <code>click</code> event in place of a <code>change</code> event. For the most part this behaves as expected, except when calling <code>preventDefault</code> in a <code>change</code> handler. <code>preventDefault</code> stops the browser from visually updating the input, even if <code>checked</code> gets toggled. This can be worked around either by removing the call to <code>preventDefault</code>, or putting the toggle of <code>checked</code> in a <code>setTimeout</code>.</p> <h2 id=\"uncontrolled-components\">\nUncontrolled Components </h2> <p>An <code>&lt;input&gt;</code> without a <code>value</code> property is an <em>uncontrolled</em> component:</p> <pre class=\"highlight\" data-language=\"javascript\">  render: function() {\n    return &lt;input type=\"text\" /&gt;;\n  }\n</pre> <p>This will render an input that starts off with an empty value. Any user input will be immediately reflected by the rendered element. If you wanted to listen to updates to the value, you could use the <code>onChange</code> event just like you can with controlled components.</p> <p>An <strong>uncontrolled</strong> component maintains its own internal state.</p> <h3 id=\"default-value\">\nDefault Value </h3> <p>If you want to initialize the component with a non-empty value, you can supply a <code>defaultValue</code> prop. For example:</p> <pre class=\"highlight\" data-language=\"javascript\">  render: function() {\n    return &lt;input type=\"text\" defaultValue=\"Hello!\" /&gt;;\n  }\n</pre> <p>This example will function much like the <strong>Controlled Components</strong> example above.</p> <p>Likewise, <code>&lt;input type=\"checkbox\"&gt;</code> and <code>&lt;input type=\"radio\"&gt;</code> support <code>defaultChecked</code>, and <code>&lt;select&gt;</code> supports <code>defaultValue</code>.</p> <blockquote>  <p>The <code>defaultValue</code> and <code>defaultChecked</code> props are only used during initial render. If you need to update the value in a subsequent render, you will need to use a <a href=\"#controlled-components\">controlled component</a>.</p> </blockquote> <h2 id=\"advanced-topics\">\nAdvanced Topics </h2>\n<h3 id=\"why-controlled-components\">\nWhy Controlled Components? </h3> <p>Using form components such as <code>&lt;input&gt;</code> in React presents a challenge that is absent when writing traditional form HTML. For example, in HTML:</p> <pre class=\"highlight\" data-language=\"html\">  &lt;input type=\"text\" name=\"title\" value=\"Untitled\" /&gt;\n</pre> <p>This renders an input <em>initialized</em> with the value, <code>Untitled</code>. When the user updates the input, the node's <code>value</code> <em>property</em> will change. However, <code>node.getAttribute('value')</code> will still return the value used at initialization time, <code>Untitled</code>.</p> <p>Unlike HTML, React components must represent the state of the view at any point in time and not only at initialization time. For example, in React:</p> <pre class=\"highlight\" data-language=\"javascript\">  render: function() {\n    return &lt;input type=\"text\" name=\"title\" value=\"Untitled\" /&gt;;\n  }\n</pre> <p>Since this method describes the view at any point in time, the value of the text input should <em>always</em> be <code>Untitled</code>.</p> <h3 id=\"why-textarea-value\">\nWhy Textarea Value? </h3> <p>In HTML, the value of <code>&lt;textarea&gt;</code> is usually set using its children:</p> <pre class=\"highlight\" data-language=\"html\">  &lt;!-- antipattern: DO NOT DO THIS! --&gt;\n  &lt;textarea name=\"description\"&gt;This is the description.&lt;/textarea&gt;\n</pre> <p>For HTML, this easily allows developers to supply multiline values. However, since React is JavaScript, we do not have string limitations and can use <code>\\n</code> if we want newlines. In a world where we have <code>value</code> and <code>defaultValue</code>, it is ambiguous what role children play. For this reason, you should not use children when setting <code>&lt;textarea&gt;</code> values:</p> <pre class=\"highlight\" data-language=\"javascript\">  &lt;textarea name=\"description\" value=\"This is a description.\" /&gt;\n</pre> <p>If you <em>do</em> decide to use children, they will behave like <code>defaultValue</code>.</p> <h3 id=\"why-select-value\">\nWhy Select Value? </h3> <p>The selected <code>&lt;option&gt;</code> in an HTML <code>&lt;select&gt;</code> is normally specified through that option's <code>selected</code> attribute. In React, in order to make components easier to manipulate, the following format is adopted instead:</p> <pre class=\"highlight\" data-language=\"javascript\">  &lt;select value=\"B\"&gt;\n    &lt;option value=\"A\"&gt;Apple&lt;/option&gt;\n    &lt;option value=\"B\"&gt;Banana&lt;/option&gt;\n    &lt;option value=\"C\"&gt;Cranberry&lt;/option&gt;\n  &lt;/select&gt;\n</pre> <p>To make an uncontrolled component, <code>defaultValue</code> is used instead.</p> <blockquote>  <p>You can pass an array into the <code>value</code> attribute, allowing you to select multiple options in a <code>select</code> tag: <code>&lt;select multiple={true} value={['B', 'C']}&gt;</code>.</p> </blockquote> <h3 id=\"imperative-operations\">\nImperative operations </h3> <p>If you need to imperatively perform an operation, you have to obtain a <a href=\"more-about-refs#the-ref-callback-attribute\">reference to the DOM node</a>. For instance, if you want to imperatively submit a form, one approach would be to attach a <code>ref</code> to the <code>form</code> element and manually call <code>form.submit()</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/forms.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/forms.html</a>\n  </p>\n</div>\n","docs/more-about-refs":"<h1> Refs to Components </h1>  <p>After building your component, you may find yourself wanting to \"reach out\" and invoke methods on component instances returned from <code>render()</code>. In most cases, this should be unnecessary because the reactive data flow always ensures that the most recent props are sent to each child that is output from <code>render()</code>. However, there are a few cases where it still might be necessary or beneficial, so React provides an escape hatch known as <code>refs</code>. These <code>refs</code> (references) are especially useful when you need to find the DOM markup rendered by a component (for instance, to position it absolutely), use React components in a larger non-React application, or transition your existing codebase to React.</p> <p>Let's look at how to get a ref, and then dive into a complete example.</p> <h2 id=\"the-ref-returned-from-reactdom.render\">\nThe ref returned from ReactDOM.render </h2> <p>Not to be confused with the <code>render()</code> function that you define on your component (and which returns a virtual DOM element), <a href=\"top-level-api#reactdom.render\">ReactDOM.render()</a> will return a reference to your component's <strong>backing instance</strong> (or <code>null</code> for <a href=\"reusable-components#stateless-functions\">stateless components</a>).</p> <pre class=\"highlight\" data-language=\"js\">var myComponent = ReactDOM.render(&lt;MyComponent /&gt;, myContainer);\n</pre> <p>Keep in mind, however, that the JSX doesn't return a component instance! It's just a <strong>ReactElement</strong>: a lightweight representation that tells React what the mounted component should look like.</p> <pre class=\"highlight\" data-language=\"js\">var myComponentElement = &lt;MyComponent /&gt;; // This is just a ReactElement.\n\n// Some code here...\n\nvar myComponentInstance = ReactDOM.render(myComponentElement, myContainer);\nmyComponentInstance.doSomething();\n</pre> <blockquote>  <p>This should only ever be used at the top level. Inside components, let your <code>props</code> and <code>state</code> handle communication with child components, or use one of the other methods of getting a ref (string attribute or callbacks).</p> </blockquote> <h2 id=\"the-ref-callback-attribute\">\nThe ref Callback Attribute </h2> <p>React supports a special attribute that you can attach to any component. The <code>ref</code> attribute can be a callback function, and this callback will be executed immediately after the component is mounted. The referenced component will be passed in as a parameter, and the callback function may use the component immediately, or save the reference for future use (or both).</p> <p>It's as simple as adding a <code>ref</code> attribute to anything returned from <code>render</code>:</p> <pre class=\"highlight\" data-language=\"js\">  render: function() {\n    return (\n      &lt;TextInput\n        ref={function(input) {\n          if (input != null) {\n            input.focus();\n          }\n        }} /&gt;\n    );\n  },\n</pre> <p>or using an ES6 arrow function:</p> <pre class=\"highlight\" data-language=\"js\">  render: function() {\n    return &lt;TextInput ref={(c) =&gt; this._input = c} /&gt;;\n  },\n  componentDidMount: function() {\n    this._input.focus();\n  },\n</pre> <p>When attaching a ref to a DOM component like <code>&lt;div /&gt;</code>, you get the DOM node back; when attaching a ref to a composite component like <code>&lt;TextInput /&gt;</code>, you'll get the React class instance. In the latter case, you can call methods on that component if any are exposed in its class definition.</p> <p>Note that when the referenced component is unmounted and whenever the ref changes, the old ref will be called with <code>null</code> as an argument. This prevents memory leaks in the case that the instance is stored, as in the second example. Also note that when writing refs with inline function expressions as in the examples here, React sees a different function object each time so on every update, ref will be called with <code>null</code> immediately before it's called with the component instance.</p> <h2 id=\"the-ref-string-attribute\">\nThe ref String Attribute </h2> <blockquote>  <p>Although string refs are not deprecated, they are considered legacy, and will likely be deprecated at some point in the future. Callback refs are preferred.</p> </blockquote> <p>React also supports using a string (instead of a callback) as a ref prop on any component.</p> <ol> <li>\n<p>Assign a <code>ref</code> attribute to anything returned from <code>render</code> such as:</p> <pre class=\"highlight\" data-language=\"html\">&lt;input ref=\"myInput\" /&gt;\n</pre>\n</li> <li>\n<p>In some other code (typically event handler code), access the <strong>backing instance</strong> via <code>this.refs</code> as in:</p> <pre class=\"highlight\" data-language=\"javascript\">var input = this.refs.myInput;\nvar inputValue = input.value;\nvar inputRect = input.getBoundingClientRect();\n</pre>\n</li> </ol> <h2 id=\"a-complete-example\">\nA Complete Example </h2> <p>In order to get a reference to a React component, you can either use <code>this</code> to get the current React component, or you can use a ref to get a reference to a component you own. They work like this:</p> <pre class=\"highlight\" data-language=\"javascript\">var MyComponent = React.createClass({\n  handleClick: function() {\n    // Explicitly focus the text input using the raw DOM API.\n    if (this.myTextInput !== null) {\n      this.myTextInput.focus();\n    }\n  },\n  render: function() {\n    // The ref attribute is a callback that saves a reference to the\n    // component to this.myTextInput when the component is mounted.\n    return (\n      &lt;div&gt;\n        &lt;input type=\"text\" ref={(ref) =&gt; this.myTextInput = ref} /&gt;\n        &lt;input\n          type=\"button\"\n          value=\"Focus the text input\"\n          onClick={this.handleClick}\n        /&gt;\n      &lt;/div&gt;\n    );\n  }\n});\n\nReactDOM.render(\n  &lt;MyComponent /&gt;,\n  document.getElementById('example')\n);\n</pre> <p>In this example, we get a reference to the text input <strong>backing instance</strong> and we call <code>focus()</code> when the button is clicked.</p> <p>For composite components, the reference will refer to an instance of the component class so you can invoke any methods that are defined on that class. If you need access to the underlying DOM node for that component, you can use <a href=\"top-level-api#reactdom.finddomnode\">ReactDOM.findDOMNode</a> as an \"escape hatch\" but we don't recommend it since it breaks encapsulation and in almost every case there's a clearer way to structure your code within the React model.</p> <h2 id=\"summary\">\nSummary </h2> <p>Refs are a great way to send a message to a particular child instance in a way that would be inconvenient to do via streaming Reactive <code>props</code> and <code>state</code>. They should, however, not be your go-to abstraction for flowing data through your application. By default, use the Reactive data flow and save <code>ref</code>s for use cases that are inherently non-reactive.</p> <h3 id=\"benefits\">\nBenefits: </h3> <ul> <li>You can define any public method on your component classes (such as a reset method on a Typeahead) and call those public methods through refs (such as <code>this.refs.myTypeahead.reset()</code>). In most cases, it's clearer to use the built-in React data flow instead of using refs imperatively.</li> <li>Performing DOM measurements almost always requires reaching out to a \"native\" component such as <code>&lt;input /&gt;</code> and accessing its underlying DOM node using a ref. Refs are one of the only practical ways of doing this reliably.</li> <li>Refs are automatically managed for you! If that child is destroyed, its ref is also destroyed for you. No worrying about memory here (unless you do something crazy to retain a reference yourself).</li> </ul> <h3 id=\"cautions\">\nCautions: </h3> <ul> <li>\n<em>Never</em> access refs inside of any component's render method â or while any component's render method is even running anywhere in the call stack.</li> <li>If you want to preserve Google Closure Compiler advanced-mode crushing resilience, make sure to never access as a property what was specified as a string. This means you must access using <code>this.refs['myRefString']</code> if your ref was defined as <code>ref=\"myRefString\"</code>.</li> <li>If you have not programmed several apps with React, your first inclination is usually going to be to try to use refs to \"make things happen\" in your app. If this is the case, take a moment and think more critically about where state should be owned in the component hierarchy. Often, it becomes clear that the proper place to \"own\" that state is at a higher level in the hierarchy. Placing the state there often eliminates any desire to use <code>ref</code>s to \"make things happen\" â instead, the data flow will usually accomplish your goal.</li> <li>Refs may not be attached to a <a href=\"reusable-components#stateless-functions\">stateless function</a>, because the component does not have a backing instance. You can always wrap a stateless component in a standard composite component and attach a ref to the composite component.</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/more-about-refs.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/more-about-refs.html</a>\n  </p>\n</div>\n","docs/animation":"<h1> Animation </h1>  <p>React provides a <code>ReactTransitionGroup</code> add-on component as a low-level API for animation, and a <code>ReactCSSTransitionGroup</code> for easily implementing basic CSS animations and transitions.</p> <h2 id=\"high-level-api-reactcsstransitiongroup\">\nHigh-level API: <code>ReactCSSTransitionGroup</code> </h2> <p><code>ReactCSSTransitionGroup</code> is based on <code>ReactTransitionGroup</code> and is an easy way to perform CSS transitions and animations when a React component enters or leaves the DOM. It's inspired by the excellent <a href=\"http://www.nganimate.org/\">ng-animate</a> library.</p> <h3 id=\"getting-started\">\nGetting Started </h3> <p><code>ReactCSSTransitionGroup</code> is the interface to <code>ReactTransitions</code>. This is a simple element that wraps all of the components you are interested in animating. Here's an example where we fade list items in and out.</p> <pre class=\"highlight\" data-language=\"javascript\">var ReactCSSTransitionGroup = require('react-addons-css-transition-group');\n\nvar TodoList = React.createClass({\n  getInitialState: function() {\n    return {items: ['hello', 'world', 'click', 'me']};\n  },\n  handleAdd: function() {\n    var newItems =\n      this.state.items.concat([prompt('Enter some text')]);\n    this.setState({items: newItems});\n  },\n  handleRemove: function(i) {\n    var newItems = this.state.items.slice();\n    newItems.splice(i, 1);\n    this.setState({items: newItems});\n  },\n  render: function() {\n    var items = this.state.items.map(function(item, i) {\n      return (\n        &lt;div key={item} onClick={this.handleRemove.bind(this, i)}&gt;\n          {item}\n        &lt;/div&gt;\n      );\n    }.bind(this));\n    return (\n      &lt;div&gt;\n        &lt;button onClick={this.handleAdd}&gt;Add Item&lt;/button&gt;\n        &lt;ReactCSSTransitionGroup transitionName=\"example\" transitionEnterTimeout={500} transitionLeaveTimeout={300}&gt;\n          {items}\n        &lt;/ReactCSSTransitionGroup&gt;\n      &lt;/div&gt;\n    );\n  }\n});\n</pre> <blockquote>  <p>You must provide <a href=\"multiple-components#dynamic-children\">the <code>key</code> attribute</a> for all children of <code>ReactCSSTransitionGroup</code>, even when only rendering a single item. This is how React will determine which children have entered, left, or stayed.</p> </blockquote> <p>In this component, when a new item is added to <code>ReactCSSTransitionGroup</code> it will get the <code>example-enter</code> CSS class and the <code>example-enter-active</code> CSS class added in the next tick. This is a convention based on the <code>transitionName</code> prop.</p> <p>You can use these classes to trigger a CSS animation or transition. For example, try adding this CSS and adding a new list item:</p> <pre class=\"highlight\" data-language=\"css\">.example-enter {\n  opacity: 0.01;\n}\n\n.example-enter.example-enter-active {\n  opacity: 1;\n  transition: opacity 500ms ease-in;\n}\n\n.example-leave {\n  opacity: 1;\n}\n\n.example-leave.example-leave-active {\n  opacity: 0.01;\n  transition: opacity 300ms ease-in;\n}\n</pre> <p>You'll notice that animation durations need to be specified in both the CSS and the render method; this tells React when to remove the animation classes from the element and -- if it's leaving -- when to remove the element from the DOM.</p> <h3 id=\"animate-initial-mounting\">\nAnimate Initial Mounting </h3> <p><code>ReactCSSTransitionGroup</code> provides the optional prop <code>transitionAppear</code>, to add an extra transition phase at the initial mount of the component. There is generally no transition phase at the initial mount as the default value of <code>transitionAppear</code> is <code>false</code>. The following is an example which passes the prop <code>transitionAppear</code> with the value <code>true</code>.</p> <pre class=\"highlight\" data-language=\"javascript\">  render: function() {\n    return (\n      &lt;ReactCSSTransitionGroup transitionName=\"example\" transitionAppear={true} transitionAppearTimeout={500}&gt;\n        &lt;h1&gt;Fading at Initial Mount&lt;/h1&gt;\n      &lt;/ReactCSSTransitionGroup&gt;\n    );\n  }\n</pre> <p>During the initial mount <code>ReactCSSTransitionGroup</code> will get the <code>example-appear</code> CSS class and the <code>example-appear-active</code> CSS class added in the next tick.</p> <pre class=\"highlight\" data-language=\"css\">.example-appear {\n  opacity: 0.01;\n}\n\n.example-appear.example-appear-active {\n  opacity: 1;\n  transition: opacity .5s ease-in;\n}\n</pre> <p>At the initial mount, all children of the <code>ReactCSSTransitionGroup</code> will <code>appear</code> but not <code>enter</code>. However, all children later added to an existing <code>ReactCSSTransitionGroup</code> will <code>enter</code> but not <code>appear</code>.</p> <blockquote>  <p>The prop <code>transitionAppear</code> was added to <code>ReactCSSTransitionGroup</code> in version <code>0.13</code>. To maintain backwards compatibility, the default value is set to <code>false</code>.</p> </blockquote> <h3 id=\"custom-classes\">\nCustom Classes </h3> <p>It is also possible to use custom class names for each of the steps in your transitions. Instead of passing a string into transitionName you can pass an object containing either the <code>enter</code> and <code>leave</code> class names, or an object containing the <code>enter</code>, <code>enter-active</code>, <code>leave-active</code>, and <code>leave</code> class names. If only the enter and leave classes are provided, the enter-active and leave-active classes will be determined by appending '-active' to the end of the class name. Here are two examples using custom classes:</p> <pre class=\"highlight\" data-language=\"javascript\">  ...\n  &lt;ReactCSSTransitionGroup\n    transitionName={ {\n      enter: 'enter',\n      enterActive: 'enterActive',\n      leave: 'leave',\n      leaveActive: 'leaveActive',\n      appear: 'appear',\n      appearActive: 'appearActive'\n    } }&gt;\n    {item}\n  &lt;/ReactCSSTransitionGroup&gt;\n\n  &lt;ReactCSSTransitionGroup\n    transitionName={ {\n      enter: 'enter',\n      leave: 'leave',\n      appear: 'appear'\n    } }&gt;\n    {item2}\n  &lt;/ReactCSSTransitionGroup&gt;\n  ...\n</pre>\n<h3 id=\"animation-group-must-be-mounted-to-work\">\nAnimation Group Must Be Mounted To Work </h3> <p>In order for it to apply transitions to its children, the <code>ReactCSSTransitionGroup</code> must already be mounted in the DOM or the prop <code>transitionAppear</code> must be set to <code>true</code>. The example below would not work, because the <code>ReactCSSTransitionGroup</code> is being mounted along with the new item, instead of the new item being mounted within it. Compare this to the <a href=\"#getting-started\">Getting Started</a> section above to see the difference.</p> <pre class=\"highlight\" data-language=\"javascript\">  render: function() {\n    var items = this.state.items.map(function(item, i) {\n      return (\n        &lt;div key={item} onClick={this.handleRemove.bind(this, i)}&gt;\n          &lt;ReactCSSTransitionGroup transitionName=\"example\"&gt;\n            {item}\n          &lt;/ReactCSSTransitionGroup&gt;\n        &lt;/div&gt;\n      );\n    }, this);\n    return (\n      &lt;div&gt;\n        &lt;button onClick={this.handleAdd}&gt;Add Item&lt;/button&gt;\n        {items}\n      &lt;/div&gt;\n    );\n  }\n</pre>\n<h3 id=\"animating-one-or-zero-items\">\nAnimating One or Zero Items </h3> <p>In the example above, we rendered a list of items into <code>ReactCSSTransitionGroup</code>. However, the children of <code>ReactCSSTransitionGroup</code> can also be one or zero items. This makes it possible to animate a single element entering or leaving. Similarly, you can animate a new element replacing the current element. For example, we can implement a simple image carousel like this:</p> <pre class=\"highlight\" data-language=\"javascript\">var ReactCSSTransitionGroup = require('react-addons-css-transition-group');\n\nvar ImageCarousel = React.createClass({\n  propTypes: {\n    imageSrc: React.PropTypes.string.isRequired\n  },\n  render: function() {\n    return (\n      &lt;div&gt;\n        &lt;ReactCSSTransitionGroup transitionName=\"carousel\" transitionEnterTimeout={300} transitionLeaveTimeout={300}&gt;\n          &lt;img src={this.props.imageSrc} key={this.props.imageSrc} /&gt;\n        &lt;/ReactCSSTransitionGroup&gt;\n      &lt;/div&gt;\n    );\n  }\n});\n</pre>\n<h3 id=\"disabling-animations\">\nDisabling Animations </h3> <p>You can disable animating <code>enter</code> or <code>leave</code> animations if you want. For example, sometimes you may want an <code>enter</code> animation and no <code>leave</code> animation, but <code>ReactCSSTransitionGroup</code> waits for an animation to complete before removing your DOM node. You can add <code>transitionEnter={false}</code> or <code>transitionLeave={false}</code> props to <code>ReactCSSTransitionGroup</code> to disable these animations.</p> <blockquote>  <p>When using <code>ReactCSSTransitionGroup</code>, there's no way for your components to be notified when a transition has ended or to perform any more complex logic around animation. If you want more fine-grained control, you can use the lower-level <code>ReactTransitionGroup</code> API which provides the hooks you need to do custom transitions.</p> </blockquote> <h2 id=\"low-level-api-reacttransitiongroup\">\nLow-level API: <code>ReactTransitionGroup</code> </h2> <p><code>ReactTransitionGroup</code> is the basis for animations. It is accessible from <code>require('react-addons-transition-group')</code>. When children are declaratively added or removed from it (as in the example above) special lifecycle hooks are called on them.</p> <h3 id=\"componentwillappearcallback\">\n<code>componentWillAppear(callback)</code> </h3> <p>This is called at the same time as <code>componentDidMount()</code> for components that are initially mounted in a <code>TransitionGroup</code>. It will block other animations from occurring until <code>callback</code> is called. It is only called on the initial render of a <code>TransitionGroup</code>.</p> <h3 id=\"componentdidappear\">\n<code>componentDidAppear()</code> </h3> <p>This is called after the <code>callback</code> function that was passed to <code>componentWillAppear</code> is called.</p> <h3 id=\"componentwillentercallback\">\n<code>componentWillEnter(callback)</code> </h3> <p>This is called at the same time as <code>componentDidMount()</code> for components added to an existing <code>TransitionGroup</code>. It will block other animations from occurring until <code>callback</code> is called. It will not be called on the initial render of a <code>TransitionGroup</code>.</p> <h3 id=\"componentdidenter\">\n<code>componentDidEnter()</code> </h3> <p>This is called after the <code>callback</code> function that was passed to <code>componentWillEnter</code> is called.</p> <h3 id=\"componentwillleavecallback\">\n<code>componentWillLeave(callback)</code> </h3> <p>This is called when the child has been removed from the <code>ReactTransitionGroup</code>. Though the child has been removed, <code>ReactTransitionGroup</code> will keep it in the DOM until <code>callback</code> is called.</p> <h3 id=\"componentdidleave\">\n<code>componentDidLeave()</code> </h3> <p>This is called when the <code>willLeave</code> <code>callback</code> is called (at the same time as <code>componentWillUnmount</code>).</p> <h3 id=\"rendering-a-different-component\">\nRendering a Different Component </h3> <p>By default <code>ReactTransitionGroup</code> renders as a <code>span</code>. You can change this behavior by providing a <code>component</code> prop. For example, here's how you would render a <code>&lt;ul&gt;</code>:</p> <pre class=\"highlight\" data-language=\"javascript\">&lt;ReactTransitionGroup component=\"ul\"&gt;\n  ...\n&lt;/ReactTransitionGroup&gt;\n</pre> <p>Any additional, user-defined, properties will become properties of the rendered component. For example, here's how you would render a <code>&lt;ul&gt;</code> with CSS class:</p> <pre class=\"highlight\" data-language=\"javascript\">&lt;ReactTransitionGroup component=\"ul\" className=\"animated-list\"&gt;\n  ...\n&lt;/ReactTransitionGroup&gt;\n</pre> <p>Every DOM component that React can render is available for use. However, <code>component</code> does not need to be a DOM component. It can be any React component you want; even ones you've written yourself! Just write <code>component={List}</code> and your component will receive <code>this.props.children</code>.</p> <h3 id=\"rendering-a-single-child\">\nRendering a Single Child </h3> <p>People often use <code>ReactTransitionGroup</code> to animate mounting and unmounting of a single child such as a collapsible panel. Normally <code>ReactTransitionGroup</code> wraps all its children in a <code>span</code> (or a custom <code>component</code> as described above). This is because any React component has to return a single root element, and <code>ReactTransitionGroup</code> is no exception to this rule.</p> <p>However if you only need to render a single child inside <code>ReactTransitionGroup</code>, you can completely avoid wrapping it in a <code>&lt;span&gt;</code> or any other DOM component. To do this, create a custom component that renders the first child passed to it directly:</p> <pre class=\"highlight\" data-language=\"javascript\">var FirstChild = React.createClass({\n  render: function() {\n    var children = React.Children.toArray(this.props.children);\n    return children[0] || null;\n  }\n});\n</pre> <p>Now you can specify <code>FirstChild</code> as the <code>component</code> prop in <code>&lt;ReactTransitionGroup&gt;</code> props and avoid any wrappers in the result DOM:</p> <pre class=\"highlight\" data-language=\"javascript\">&lt;ReactTransitionGroup component={FirstChild}&gt;\n  {someCondition ? &lt;MyComponent /&gt; : null}\n&lt;/ReactTransitionGroup&gt;\n</pre> <p>This only works when you are animating a single child in and out, such as a collapsible panel. This approach wouldn't work when animating multiple children or replacing the single child with another child, such as an image carousel. For an image carousel, while the current image is animating out, another image will animate in, so <code>&lt;ReactTransitionGroup&gt;</code> needs to give them a common DOM parent. You can't avoid the wrapper for multiple children, but you can customize the wrapper with the <code>component</code> prop as described above.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/animation.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/animation.html</a>\n  </p>\n</div>\n","docs/why-react":"<h1> Why React? </h1>  <p>React is a JavaScript library for creating user interfaces by Facebook and Instagram. Many people choose to think of React as the <strong>V</strong> in <strong><a href=\"https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller\">MVC</a></strong>.</p> <p>We built React to solve one problem: <strong>building large applications with data that changes over time</strong>.</p> <h2 id=\"simple\">\nSimple </h2> <p>Simply express how your app should look at any given point in time, and React will automatically manage all UI updates when your underlying data changes.</p> <h2 id=\"declarative\">\nDeclarative </h2> <p>When the data changes, React conceptually hits the \"refresh\" button, and knows to only update the changed parts.</p> <h2 id=\"build-composable-components\">\nBuild Composable Components </h2> <p>React is all about building reusable components. In fact, with React the <em>only</em> thing you do is build components. Since they're so encapsulated, components make code reuse, testing, and separation of concerns easy.</p> <h2 id=\"give-it-five-minutes\">\nGive It Five Minutes </h2> <p>React challenges a lot of conventional wisdom, and at first glance some of the ideas may seem crazy. <a href=\"https://signalvnoise.com/posts/3124-give-it-five-minutes\">Give it five minutes</a> while reading this guide; those crazy ideas have worked for building thousands of components both inside and outside of Facebook and Instagram.</p> <h2 id=\"learn-more\">\nLearn More </h2> <p>You can learn more about our motivations behind building React in <a href=\"https://facebook.github.io/react/blog/2013/06/05/why-react.html\">this blog post</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/why-react.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/why-react.html</a>\n  </p>\n</div>\n","docs/jsx-in-depth":"<h1> JSX in Depth </h1>  <p><a href=\"https://facebook.github.io/jsx/\">JSX</a> is a JavaScript syntax extension that looks similar to XML. You can use a simple JSX syntactic transform with React.</p> <h2 id=\"why-jsx\">\nWhy JSX? </h2> <p>You don't have to use JSX with React. You can just use plain JS. However, we recommend using JSX because it is a concise and familiar syntax for defining tree structures with attributes.</p> <p>It's more familiar for casual developers such as designers.</p> <p>XML has the benefit of balanced opening and closing tags. This helps make large trees easier to read than function calls or object literals.</p> <p>It doesn't alter the semantics of JavaScript.</p> <h2 id=\"html-tags-vs.-react-components\">\nHTML Tags vs. React Components </h2> <p>React can either render HTML tags (strings) or React components (classes).</p> <p>To render an HTML tag, just use lower-case tag names in JSX:</p> <pre class=\"highlight\" data-language=\"javascript\">var myDivElement = &lt;div className=\"foo\" /&gt;;\nReactDOM.render(myDivElement, document.getElementById('example'));\n</pre> <p>To render a React Component, just create a local variable that starts with an upper-case letter:</p> <pre class=\"highlight\" data-language=\"javascript\">var MyComponent = React.createClass({/*...*/});\nvar myElement = &lt;MyComponent someProperty={true} /&gt;;\nReactDOM.render(myElement, document.getElementById('example'));\n</pre> <p>React's JSX uses the upper vs. lower case convention to distinguish between local component classes and HTML tags.</p> <blockquote>  <p>Since JSX is JavaScript, identifiers such as <code>class</code> and <code>for</code> are discouraged as XML attribute names. Instead, React DOM components expect DOM property names like <code>className</code> and <code>htmlFor</code>, respectively.</p> </blockquote> <h2 id=\"the-transform\">\nThe Transform </h2> <p>React JSX transforms from an XML-like syntax into native JavaScript. XML elements, attributes and children are transformed into arguments that are passed to <code>React.createElement</code>.</p> <pre class=\"highlight\" data-language=\"javascript\">var Nav;\n// Input (JSX):\nvar app = &lt;Nav color=\"blue\" /&gt;;\n// Output (JS):\nvar app = React.createElement(Nav, {color:\"blue\"});\n</pre> <p>Notice that in order to use <code>&lt;Nav /&gt;</code>, the <code>Nav</code> variable must be in scope.</p> <p>JSX also allows specifying children using XML syntax:</p> <pre class=\"highlight\" data-language=\"javascript\">var Nav, Profile;\n// Input (JSX):\nvar app = &lt;Nav color=\"blue\"&gt;&lt;Profile&gt;click&lt;/Profile&gt;&lt;/Nav&gt;;\n// Output (JS):\nvar app = React.createElement(\n  Nav,\n  {color:\"blue\"},\n  React.createElement(Profile, null, \"click\")\n);\n</pre> <p>JSX will infer the class's <a href=\"component-specs#displayname\">displayName</a> from the variable assignment when the displayName is undefined:</p> <pre class=\"highlight\" data-language=\"javascript\">// Input (JSX):\nvar Nav = React.createClass({ });\n// Output (JS):\nvar Nav = React.createClass({displayName: \"Nav\", });\n</pre> <p>Use the <a href=\"https://babeljs.io/repl/\">Babel REPL</a> to try out JSX and see how it desugars into native JavaScript, and the <a href=\"http://magic.reactjs.net/htmltojsx.htm\">HTML to JSX converter</a> to convert your existing HTML to JSX.</p> <p>If you want to use JSX, the <a href=\"../index\">Getting Started</a> guide shows how to set up compilation.</p> <blockquote>  <p>The JSX expression always evaluates to a ReactElement. The actual implementation details may vary. An optimized mode could inline the ReactElement as an object literal to bypass the validation code in <code>React.createElement</code>.</p> </blockquote> <h2 id=\"namespaced-components\">\nNamespaced Components </h2> <p>If you are building a component that has many children, like a form, you might end up with something with a lot of variable declarations:</p> <pre class=\"highlight\" data-language=\"javascript\">// Awkward block of variable declarations\nvar Form = MyFormComponent;\nvar FormRow = Form.Row;\nvar FormLabel = Form.Label;\nvar FormInput = Form.Input;\n\nvar App = (\n  &lt;Form&gt;\n    &lt;FormRow&gt;\n      &lt;FormLabel /&gt;\n      &lt;FormInput /&gt;\n    &lt;/FormRow&gt;\n  &lt;/Form&gt;\n);\n</pre> <p>To make it simpler and easier, <em>namespaced components</em> let you use one component that has other components as attributes:</p> <pre class=\"highlight\" data-language=\"javascript\">var Form = MyFormComponent;\n\nvar App = (\n  &lt;Form&gt;\n    &lt;Form.Row&gt;\n      &lt;Form.Label /&gt;\n      &lt;Form.Input /&gt;\n    &lt;/Form.Row&gt;\n  &lt;/Form&gt;\n);\n</pre> <p>To do this, you just need to create your <em>\"sub-components\"</em> as attributes of the main component:</p> <pre class=\"highlight\" data-language=\"javascript\">var MyFormComponent = React.createClass({ ... });\n\nMyFormComponent.Row = React.createClass({ ... });\nMyFormComponent.Label = React.createClass({ ... });\nMyFormComponent.Input = React.createClass({ ... });\n</pre> <p>JSX will handle this properly when compiling your code.</p> <pre class=\"highlight\" data-language=\"javascript\">var App = (\n  React.createElement(Form, null,\n    React.createElement(Form.Row, null,\n      React.createElement(Form.Label, null),\n      React.createElement(Form.Input, null)\n    )\n  )\n);\n</pre> <blockquote>  <p>This feature is available in <a href=\"https://facebook.github.io/react/blog/2014/07/17/react-v0.11.html#jsx\">v0.11</a> and above.</p> </blockquote> <h2 id=\"javascript-expressions\">\nJavaScript Expressions </h2>\n<h3 id=\"attribute-expressions\">\nAttribute Expressions </h3> <p>To use a JavaScript expression as an attribute value, wrap the expression in a pair of curly braces (<code>{}</code>) instead of quotes (<code>\"\"</code>).</p> <pre class=\"highlight\" data-language=\"javascript\">// Input (JSX):\nvar person = &lt;Person name={window.isLoggedIn ? window.name : ''} /&gt;;\n// Output (JS):\nvar person = React.createElement(\n  Person,\n  {name: window.isLoggedIn ? window.name : ''}\n);\n</pre>\n<h3 id=\"boolean-attributes\">\nBoolean Attributes </h3> <p>Omitting the value of an attribute causes JSX to treat it as <code>true</code>. To pass <code>false</code> an attribute expression must be used. This often comes up when using HTML form elements, with attributes like <code>disabled</code>, <code>required</code>, <code>checked</code> and <code>readOnly</code>.</p> <pre class=\"highlight\" data-language=\"javascript\">// These two are equivalent in JSX for disabling a button\n&lt;input type=\"button\" disabled /&gt;;\n&lt;input type=\"button\" disabled={true} /&gt;;\n\n// And these two are equivalent in JSX for not disabling a button\n&lt;input type=\"button\" /&gt;;\n&lt;input type=\"button\" disabled={false} /&gt;;\n</pre>\n<h3 id=\"child-expressions\">\nChild Expressions </h3> <p>Likewise, JavaScript expressions may be used to express children:</p> <pre class=\"highlight\" data-language=\"javascript\">// Input (JSX):\nvar content = &lt;Container&gt;{window.isLoggedIn ? &lt;Nav /&gt; : &lt;Login /&gt;}&lt;/Container&gt;;\n// Output (JS):\nvar content = React.createElement(\n  Container,\n  null,\n  window.isLoggedIn ? React.createElement(Nav) : React.createElement(Login)\n);\n</pre>\n<h3 id=\"comments\">\nComments </h3> <p>It's easy to add comments within your JSX; they're just JS expressions. You just need to be careful to put <code>{}</code> around the comments when you are within the children section of a tag.</p> <pre class=\"highlight\" data-language=\"javascript\">var content = (\n  &lt;Nav&gt;\n    {/* child comment, put {} around */}\n    &lt;Person\n      /* multi\n         line\n         comment */\n      name={window.isLoggedIn ? window.name : ''} // end of line comment\n    /&gt;\n  &lt;/Nav&gt;\n);\n</pre> <blockquote> <p>NOTE:</p> <p>JSX is similar to HTML, but not exactly the same. See <a href=\"jsx-gotchas\">JSX gotchas</a> for some key differences.</p> </blockquote><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/jsx-in-depth.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/jsx-in-depth.html</a>\n  </p>\n</div>\n","docs/reusable-components":"<h1> Reusable Components </h1>  <p>When designing interfaces, break down the common design elements (buttons, form fields, layout components, etc.) into reusable components with well-defined interfaces. That way, the next time you need to build some UI, you can write much less code. This means faster development time, fewer bugs, and fewer bytes down the wire.</p> <h2 id=\"prop-validation\">\nProp Validation </h2> <p>As your app grows it's helpful to ensure that your components are used correctly. We do this by allowing you to specify <code>propTypes</code>. <code>React.PropTypes</code> exports a range of validators that can be used to make sure the data you receive is valid. When an invalid value is provided for a prop, a warning will be shown in the JavaScript console. Note that for performance reasons <code>propTypes</code> is only checked in development mode. Here is an example documenting the different validators provided:</p> <pre class=\"highlight\" data-language=\"javascript\">React.createClass({\n  propTypes: {\n    // You can declare that a prop is a specific JS primitive. By default, these\n    // are all optional.\n    optionalArray: React.PropTypes.array,\n    optionalBool: React.PropTypes.bool,\n    optionalFunc: React.PropTypes.func,\n    optionalNumber: React.PropTypes.number,\n    optionalObject: React.PropTypes.object,\n    optionalString: React.PropTypes.string,\n    optionalSymbol: React.PropTypes.symbol,\n\n    // Anything that can be rendered: numbers, strings, elements or an array\n    // (or fragment) containing these types.\n    optionalNode: React.PropTypes.node,\n\n    // A React element.\n    optionalElement: React.PropTypes.element,\n\n    // You can also declare that a prop is an instance of a class. This uses\n    // JS's instanceof operator.\n    optionalMessage: React.PropTypes.instanceOf(Message),\n\n    // You can ensure that your prop is limited to specific values by treating\n    // it as an enum.\n    optionalEnum: React.PropTypes.oneOf(['News', 'Photos']),\n\n    // An object that could be one of many types\n    optionalUnion: React.PropTypes.oneOfType([\n      React.PropTypes.string,\n      React.PropTypes.number,\n      React.PropTypes.instanceOf(Message)\n    ]),\n\n    // An array of a certain type\n    optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),\n\n    // An object with property values of a certain type\n    optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),\n\n    // An object taking on a particular shape\n    optionalObjectWithShape: React.PropTypes.shape({\n      color: React.PropTypes.string,\n      fontSize: React.PropTypes.number\n    }),\n\n    // You can chain any of the above with `isRequired` to make sure a warning\n    // is shown if the prop isn't provided.\n    requiredFunc: React.PropTypes.func.isRequired,\n\n    // A value of any data type\n    requiredAny: React.PropTypes.any.isRequired,\n\n    // You can also specify a custom validator. It should return an Error\n    // object if the validation fails. Don't `console.warn` or throw, as this\n    // won't work inside `oneOfType`.\n    customProp: function(props, propName, componentName) {\n      if (!/matchme/.test(props[propName])) {\n        return new Error(\n          'Invalid prop `' + propName + '` supplied to' +\n          ' `' + componentName + '`. Validation failed.'\n        );\n      }\n    },\n\n    // You can also supply a custom validator to `arrayOf` and `objectOf`.\n    // It should return an Error object if the validation fails. The validator\n    // will be called for each key in the array or object. The first two\n    // arguments of the validator are the array or object itself, and the\n    // current item's key.\n    customArrayProp: React.PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {\n      if (!/matchme/.test(propValue[key])) {\n        return new Error(\n          'Invalid prop `' + propFullName + '` supplied to' +\n          ' `' + componentName + '`. Validation failed.'\n        );\n      }\n    })\n  },\n  /* ... */\n});\n</pre>\n<h3 id=\"single-child\">\nSingle Child </h3> <p>With <code>React.PropTypes.element</code> you can specify that only a single child can be passed to a component as children.</p> <pre class=\"highlight\" data-language=\"javascript\">var MyComponent = React.createClass({\n  propTypes: {\n    children: React.PropTypes.element.isRequired\n  },\n\n  render: function() {\n    return (\n      &lt;div&gt;\n        {this.props.children} // This must be exactly one element or it will warn.\n      &lt;/div&gt;\n    );\n  }\n\n});\n</pre>\n<h2 id=\"default-prop-values\">\nDefault Prop Values </h2> <p>React lets you define default values for your <code>props</code> in a very declarative way:</p> <pre class=\"highlight\" data-language=\"javascript\">var ComponentWithDefaultProps = React.createClass({\n  getDefaultProps: function() {\n    return {\n      value: 'default value'\n    };\n  }\n  /* ... */\n});\n</pre> <p>The result of <code>getDefaultProps()</code> will be cached and used to ensure that <code>this.props.value</code> will have a value if it was not specified by the owner component. This allows you to safely just use your props without having to write repetitive and fragile code to handle that yourself.</p> <h2 id=\"transferring-props-a-shortcut\">\nTransferring Props: A Shortcut </h2> <p>A common type of React component is one that extends a basic HTML element in a simple way. Often you'll want to copy any HTML attributes passed to your component to the underlying HTML element. To save typing, you can use the JSX <em>spread</em> syntax to achieve this:</p> <pre class=\"highlight\" data-language=\"javascript\">var CheckLink = React.createClass({\n  render: function() {\n    // This takes any props passed to CheckLink and copies them to &lt;a&gt;\n    return &lt;a {...this.props}&gt;{'â '}{this.props.children}&lt;/a&gt;;\n  }\n});\n\nReactDOM.render(\n  &lt;CheckLink href=\"/checked.html\"&gt;\n    Click here!\n  &lt;/CheckLink&gt;,\n  document.getElementById('example')\n);\n</pre>\n<h2 id=\"mixins\">\nMixins </h2> <p>Components are the best way to reuse code in React, but sometimes very different components may share some common functionality. These are sometimes called <a href=\"https://en.wikipedia.org/wiki/Cross-cutting_concern\">cross-cutting concerns</a>. React provides <code>mixins</code> to solve this problem.</p> <p>One common use case is a component wanting to update itself on a time interval. It's easy to use <code>setInterval()</code>, but it's important to cancel your interval when you don't need it anymore to save memory. React provides <a href=\"working-with-the-browser#component-lifecycle\">lifecycle methods</a> that let you know when a component is about to be created or destroyed. Let's create a simple mixin that uses these methods to provide an easy <code>setInterval()</code> function that will automatically get cleaned up when your component is destroyed.</p> <pre class=\"highlight\" data-language=\"javascript\">var SetIntervalMixin = {\n  componentWillMount: function() {\n    this.intervals = [];\n  },\n  setInterval: function() {\n    this.intervals.push(setInterval.apply(null, arguments));\n  },\n  componentWillUnmount: function() {\n    this.intervals.forEach(clearInterval);\n  }\n};\n\nvar TickTock = React.createClass({\n  mixins: [SetIntervalMixin], // Use the mixin\n  getInitialState: function() {\n    return {seconds: 0};\n  },\n  componentDidMount: function() {\n    this.setInterval(this.tick, 1000); // Call a method on the mixin\n  },\n  tick: function() {\n    this.setState({seconds: this.state.seconds + 1});\n  },\n  render: function() {\n    return (\n      &lt;p&gt;\n        React has been running for {this.state.seconds} seconds.\n      &lt;/p&gt;\n    );\n  }\n});\n\nReactDOM.render(\n  &lt;TickTock /&gt;,\n  document.getElementById('example')\n);\n</pre> <p>A nice feature of mixins is that if a component is using multiple mixins and several mixins define the same lifecycle method (i.e. several mixins want to do some cleanup when the component is destroyed), all of the lifecycle methods are guaranteed to be called. Methods defined on mixins run in the order mixins were listed, followed by a method call on the component.</p> <h2 id=\"es6-classes\">\nES6 Classes </h2> <p>You may also define your React classes as a plain JavaScript class. For example using ES6 class syntax:</p> <pre class=\"highlight\" data-language=\"javascript\">class HelloMessage extends React.Component {\n  render() {\n    return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;;\n  }\n}\nReactDOM.render(&lt;HelloMessage name=\"Sebastian\" /&gt;, mountNode);\n</pre> <p>The API is similar to <code>React.createClass</code> with the exception of <code>getInitialState</code>. Instead of providing a separate <code>getInitialState</code> method, you set up your own <code>state</code> property in the constructor. Just like the return value of <code>getInitialState</code>, the value you assign to <code>this.state</code> will be used as the initial state for your component.</p> <p>Another difference is that <code>propTypes</code> and <code>defaultProps</code> are defined as properties on the constructor instead of in the class body.</p> <pre class=\"highlight\" data-language=\"javascript\">export class Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {count: props.initialCount};\n    this.tick = this.tick.bind(this);\n  }\n  tick() {\n    this.setState({count: this.state.count + 1});\n  }\n  render() {\n    return (\n      &lt;div onClick={this.tick}&gt;\n        Clicks: {this.state.count}\n      &lt;/div&gt;\n    );\n  }\n}\nCounter.propTypes = { initialCount: React.PropTypes.number };\nCounter.defaultProps = { initialCount: 0 };\n</pre>\n<h3 id=\"no-autobinding\">\nNo Autobinding </h3> <p>Methods follow the same semantics as regular ES6 classes, meaning that they don't automatically bind <code>this</code> to the instance. You'll have to explicitly use <code>.bind(this)</code> or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">arrow functions</a> <code>=&gt;</code>:</p> <pre class=\"highlight\" data-language=\"javascript\">// You can use bind() to preserve `this`\n&lt;div onClick={this.tick.bind(this)}&gt;\n\n// Or you can use arrow functions\n&lt;div onClick={() =&gt; this.tick()}&gt;\n</pre> <p>We recommend that you bind your event handlers in the constructor so they are only bound once for every instance:</p> <pre class=\"highlight\" data-language=\"javascript\">constructor(props) {\n  super(props);\n  this.state = {count: props.initialCount};\n  this.tick = this.tick.bind(this);\n}\n</pre> <p>Now you can use <code>this.tick</code> directly as it was bound once in the constructor:</p> <pre class=\"highlight\" data-language=\"javascript\">// It is already bound in the constructor\n&lt;div onClick={this.tick}&gt;\n</pre> <p>This is better for performance of your application, especially if you implement <a href=\"component-specs#updating-shouldcomponentupdate\">shouldComponentUpdate()</a> with a <a href=\"shallow-compare\">shallow comparison</a> in the child components.</p> <h3 id=\"no-mixins\">\nNo Mixins </h3> <p>Unfortunately ES6 launched without any mixin support. Therefore, there is no support for mixins when you use React with ES6 classes. Instead, we're working on making it easier to support such use cases without resorting to mixins.</p> <h2 id=\"stateless-functions\">\nStateless Functions </h2> <p>You may also define your React classes as a plain JavaScript function. For example using the stateless function syntax:</p> <pre class=\"highlight\" data-language=\"javascript\">function HelloMessage(props) {\n  return &lt;div&gt;Hello {props.name}&lt;/div&gt;;\n}\nReactDOM.render(&lt;HelloMessage name=\"Sebastian\" /&gt;, mountNode);\n</pre> <p>Or using the new ES6 arrow syntax:</p> <pre class=\"highlight\" data-language=\"javascript\">const HelloMessage = (props) =&gt; &lt;div&gt;Hello {props.name}&lt;/div&gt;;\nReactDOM.render(&lt;HelloMessage name=\"Sebastian\" /&gt;, mountNode);\n</pre> <p>This simplified component API is intended for components that are pure functions of their props. These components must not retain internal state, do not have backing instances, and do not have the component lifecycle methods. They are pure functional transforms of their input, with zero boilerplate. However, you may still specify <code>.propTypes</code> and <code>.defaultProps</code> by setting them as properties on the function, just as you would set them on an ES6 class.</p> <blockquote> <p>NOTE:</p> <p>Because stateless functions don't have a backing instance, you can't attach a ref to a stateless function component. Normally this isn't an issue, since stateless functions do not provide an imperative API. Without an imperative API, there isn't much you could do with an instance anyway. However, if a user wants to find the DOM node of a stateless function component, they must wrap the component in a stateful component (eg. ES6 class component) and attach the ref to the stateful wrapper component.</p> <p>NOTE:</p> <p>In React v0.14, stateless functional components were not permitted to return <code>null</code> or <code>false</code> (a workaround is to return a <code>&lt;noscript /&gt;</code> instead). This was fixed in React v15, and stateless functional components are now permitted to return <code>null</code>.</p> </blockquote> <p>In an ideal world, most of your components would be stateless functions because in the future weâll also be able to make performance optimizations specific to these components by avoiding unnecessary checks and memory allocations. This is the recommended pattern, when possible.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/reusable-components.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/reusable-components.html</a>\n  </p>\n</div>\n","docs/perf":"<h1> Performance Tools </h1>  <p>React is usually quite fast out of the box. However, in situations where you need to squeeze every ounce of performance out of your app, it provides a <a href=\"component-specs#updating-shouldcomponentupdate\">shouldComponentUpdate</a> hook where you can add optimization hints to React's diff algorithm.</p> <p>In addition to giving you an overview of your app's overall performance, ReactPerf is a profiling tool that tells you exactly where you need to put these hooks.</p> <p>See these two articles by the <a href=\"http://benchling.engineering\">Benchling Engineering Team</a> for a in-depth introduction to performance tooling: <a href=\"http://benchling.engineering/performance-engineering-with-react/\">\"Performance Engineering with React\"</a> and <a href=\"http://benchling.engineering/deep-dive-react-perf-debugging/\">\"A Deep Dive into React Perf Debugging\"</a>!</p> <h2 id=\"development-vs.-production-builds\">\nDevelopment vs. Production Builds </h2> <p>If you're benchmarking or seeing performance problems in your React apps, make sure you're testing with the <a href=\"https://facebook.github.io/react/downloads.html\">minified production build</a>. The development build includes extra warnings that are helpful when building your apps, but it is slower due to the extra bookkeeping it does.</p> <p>However, the perf tools described on this page only work when using the development build of React. Therefore, the profiler only serves to indicate the <em>relatively</em> expensive parts of your app.</p> <h2 id=\"general-api\">\nGeneral API </h2> <p>The <code>Perf</code> object documented here is exposed as <code>require('react-addons-perf')</code> and can be used with React in development mode only. You should not include this bundle when building your app for production.</p> <h3 id=\"perf.start-and-perf.stop\">\n<code>Perf.start()</code> and <code>Perf.stop()</code> </h3> <p>Start/stop the measurement. The React operations in-between are recorded for analyses below. Operations that took an insignificant amount of time are ignored.</p> <p>After stopping, you will need <code>Perf.getLastMeasurements()</code> (described below) to get the measurements.</p> <h3 id=\"perf.printinclusivemeasurements\">\n<code>Perf.printInclusive(measurements)</code> </h3> <p>Prints the overall time taken. If no argument's passed, defaults to all the measurements from the last recording. This prints a nicely formatted table in the console, like so:</p> <p><img src=\"https://facebook.github.io/react/img/docs/perf-inclusive.png\" alt=\"\"></p> <h3 id=\"perf.printexclusivemeasurements\">\n<code>Perf.printExclusive(measurements)</code> </h3> <p>\"Exclusive\" times don't include the times taken to mount the components: processing props, <code>getInitialState</code>, call <code>componentWillMount</code> and <code>componentDidMount</code>, etc.</p> <p><img src=\"https://facebook.github.io/react/img/docs/perf-exclusive.png\" alt=\"\"></p> <h3 id=\"perf.printwastedmeasurements\">\n<code>Perf.printWasted(measurements)</code> </h3> <p><strong>The most useful part of the profiler</strong>.</p> <p>\"Wasted\" time is spent on components that didn't actually render anything, e.g. the render stayed the same, so the DOM wasn't touched.</p> <p><img src=\"https://facebook.github.io/react/img/docs/perf-wasted.png\" alt=\"\"></p> <h3 id=\"perf.printoperationsmeasurements\">\n<code>Perf.printOperations(measurements)</code> </h3> <p>Prints the underlying DOM manipulations, e.g. \"set innerHTML\" and \"remove\".</p> <p><img src=\"https://facebook.github.io/react/img/docs/perf-dom.png\" alt=\"\"></p> <h3 id=\"perf.printdommeasurements\">\n<code>Perf.printDOM(measurements)</code> </h3> <p>This method has been renamed to <code>printOperations()</code> which is described in the previous paragraph. Currently <code>printDOM()</code> still exists as an alias but it prints a deprecation warning and will eventually be removed.</p> <h2 id=\"advanced-api\">\nAdvanced API </h2> <p>The above print methods use <code>Perf.getLastMeasurements()</code> to pretty-print the result.</p> <h3 id=\"perf.getlastmeasurements\">\n<code>Perf.getLastMeasurements()</code> </h3> <p>Get the opaque data structure describing measurements from the last start-stop session. You can save it and pass it to the methods above to analyze past measurements.</p> <p>Don't rely on the exact format of the return value because it may change in minor releases. We will update the documentation if the return value format becomes a supported part of the public API.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/perf.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/perf.html</a>\n  </p>\n</div>\n","docs/shallow-compare":"<h1> Shallow Compare </h1>  <p><code>shallowCompare</code> is a helper function to achieve the same functionality as <code>PureRenderMixin</code> while using ES6 classes with React.</p> <p>If your React component's render function is \"pure\" (in other words, it renders the same result given the same props and state), you can use this helper function for a performance boost in some cases.</p> <p>Example:</p> <pre class=\"highlight\" data-language=\"js\">var shallowCompare = require('react-addons-shallow-compare');\nexport class SampleComponent extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    return shallowCompare(this, nextProps, nextState);\n  }\n\n  render() {\n    return &lt;div className={this.props.className}&gt;foo&lt;/div&gt;;\n  }\n}\n</pre> <p><code>shallowCompare</code> performs a shallow equality check on the current <code>props</code> and <code>nextProps</code> objects as well as the current <code>state</code> and <code>nextState</code> objects.<br> It does this by iterating on the keys of the objects being compared and returning true when the values of a key in each object are not strictly equal.</p> <p><code>shallowCompare</code> returns <code>true</code> if the shallow comparison for props or state fails and therefore the component should update.<br> <code>shallowCompare</code> returns <code>false</code> if the shallow comparison for props and state both pass and therefore the component does not need to update.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/shallow-compare.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/shallow-compare.html</a>\n  </p>\n</div>\n","docs/top-level-api":"<h1> Top-Level API </h1>  <h2 id=\"react\">\nReact </h2> <p><code>React</code> is the entry point to the React library. If you're using one of the prebuilt packages it's available as a global; if you're using CommonJS modules you can <code>require()</code> it.</p> <h3 id=\"react.component\">\nReact.Component </h3>\n<pre class=\"highlight\" data-language=\"javascript\">class Component\n</pre> <p>This is the base class for React Components when they're defined using ES6 classes. See <a href=\"reusable-components#es6-classes\">Reusable Components</a> for how to use ES6 classes with React. For what methods are actually provided by the base class, see the <a href=\"component-api\">Component API</a>.</p> <h3 id=\"react.createclass\">\nReact.createClass </h3>\n<pre class=\"highlight\" data-language=\"javascript\">ReactClass createClass(object specification)\n</pre> <p>Create a component class, given a specification. A component implements a <code>render</code> method which returns <strong>one single</strong> child. That child may have an arbitrarily deep child structure. One thing that makes components different than standard prototypal classes is that you don't need to call new on them. They are convenience wrappers that construct backing instances (via new) for you.</p> <p>For more information about the specification object, see <a href=\"component-specs\">Component Specs and Lifecycle</a>.</p> <h3 id=\"react.createelement\">\nReact.createElement </h3>\n<pre class=\"highlight\" data-language=\"javascript\">ReactElement createElement(\n  string/ReactClass type,\n  [object props],\n  [children ...]\n)\n</pre> <p>Create and return a new <code>ReactElement</code> of the given type. The type argument can be either an html tag name string (eg. 'div', 'span', etc), or a <code>ReactClass</code> (created via <code>React.createClass</code>).</p> <h3 id=\"react.cloneelement\">\nReact.cloneElement </h3>\n<pre class=\"highlight\" data-language=\"text\">ReactElement cloneElement(\n  ReactElement element,\n  [object props],\n  [children ...]\n)\n</pre> <p>Clone and return a new <code>ReactElement</code> using <code>element</code> as the starting point. The resulting element will have the original element's props with the new props merged in shallowly. New children will replace existing children. Unlike <code>React.addons.cloneWithProps</code>, <code>key</code> and <code>ref</code> from the original element will be preserved. There is no special behavior for merging any props (unlike <code>cloneWithProps</code>). See the <a href=\"https://facebook.github.io/react/blog/2015/03/03/react-v0.13-rc2.html\">v0.13 RC2 blog post</a> for additional details.</p> <h3 id=\"react.createfactory\">\nReact.createFactory </h3>\n<pre class=\"highlight\" data-language=\"javascript\">factoryFunction createFactory(\n  string/ReactClass type\n)\n</pre> <p>Return a function that produces ReactElements of a given type. Like <code>React.createElement</code>, the type argument can be either an html tag name string (eg. 'div', 'span', etc), or a <code>ReactClass</code>.</p> <h3 id=\"react.isvalidelement\">\nReact.isValidElement </h3>\n<pre class=\"highlight\" data-language=\"javascript\">boolean isValidElement(* object)\n</pre> <p>Verifies the object is a ReactElement.</p> <h3 id=\"react.dom\">\nReact.DOM </h3> <p><code>React.DOM</code> provides convenience wrappers around <code>React.createElement</code> for DOM components. These should only be used when not using JSX. For example, <code>React.DOM.div(null, 'Hello World!')</code></p> <h3 id=\"react.proptypes\">\nReact.PropTypes </h3> <p><code>React.PropTypes</code> includes types that can be used with a component's <code>propTypes</code> object to validate props being passed to your components. For more information about <code>propTypes</code>, see <a href=\"reusable-components\">Reusable Components</a>.</p> <h3 id=\"react.children\">\nReact.Children </h3> <p><code>React.Children</code> provides utilities for dealing with the <code>this.props.children</code> opaque data structure.</p> <h4 id=\"react.children.map\">\nReact.Children.map </h4>\n<pre class=\"highlight\" data-language=\"javascript\">array React.Children.map(object children, function fn [, object thisArg])\n</pre> <p>Invoke <code>fn</code> on every immediate child contained within <code>children</code> with <code>this</code> set to <code>thisArg</code>. If <code>children</code> is a <a href=\"create-fragment\">keyed fragment</a> or array it will be traversed: <code>fn</code> will never be passed the container objects. If children is <code>null</code> or <code>undefined</code> returns <code>null</code> or <code>undefined</code> rather than an array.</p> <h4 id=\"react.children.foreach\">\nReact.Children.forEach </h4>\n<pre class=\"highlight\" data-language=\"javascript\">React.Children.forEach(object children, function fn [, object thisArg])\n</pre> <p>Like <code>React.Children.map()</code> but does not return an array.</p> <h4 id=\"react.children.count\">\nReact.Children.count </h4>\n<pre class=\"highlight\" data-language=\"javascript\">number React.Children.count(object children)\n</pre> <p>Return the total number of components in <code>children</code>, equal to the number of times that a callback passed to <code>map</code> or <code>forEach</code> would be invoked.</p> <h4 id=\"react.children.only\">\nReact.Children.only </h4>\n<pre class=\"highlight\" data-language=\"javascript\">object React.Children.only(object children)\n</pre> <p>Return the only child in <code>children</code>. Throws otherwise.</p> <h4 id=\"react.children.toarray\">\nReact.Children.toArray </h4>\n<pre class=\"highlight\" data-language=\"javascript\">array React.Children.toArray(object children)\n</pre> <p>Return the <code>children</code> opaque data structure as a flat array with keys assigned to each child. Useful if you want to manipulate collections of children in your render methods, especially if you want to reorder or slice <code>this.props.children</code> before passing it down.</p> <h2 id=\"reactdom\">\nReactDOM </h2> <p>The <code>react-dom</code> package provides DOM-specific methods that can be used at the top level of your app and as an escape hatch to get outside of the React model if you need to. Most of your components should not need to use this module.</p> <h3 id=\"reactdom.render\">\nReactDOM.render </h3>\n<pre class=\"highlight\" data-language=\"javascript\">render(\n  ReactElement element,\n  DOMElement container,\n  [function callback]\n)\n</pre> <p>Render a ReactElement into the DOM in the supplied <code>container</code> and return a <a href=\"more-about-refs\">reference</a> to the component (or returns <code>null</code> for <a href=\"reusable-components#stateless-functions\">stateless components</a>).</p> <p>If the ReactElement was previously rendered into <code>container</code>, this will perform an update on it and only mutate the DOM as necessary to reflect the latest React component.</p> <p>If the optional callback is provided, it will be executed after the component is rendered or updated.</p> <blockquote>  <p><code>ReactDOM.render()</code> controls the contents of the container node you pass in. Any existing DOM elements inside are replaced when first called. Later calls use Reactâs DOM diffing algorithm for efficient updates.</p> <p><code>ReactDOM.render()</code> does not modify the container node (only modifies the children of the container). In the future, it may be possible to insert a component to an existing DOM node without overwriting the existing children.</p> <p><code>ReactDOM.render()</code> currently returns a reference to the root <code>ReactComponent</code> instance. However, using this return value is legacy and should be avoided because future versions of React may render components asynchronously in some cases. If you need a reference to the root <code>ReactComponent</code> instance, the preferred solution is to attach a <a href=\"more-about-refs#the-ref-callback-attribute\">callback ref</a> to the root element.</p> </blockquote> <h3 id=\"reactdom.unmountcomponentatnode\">\nReactDOM.unmountComponentAtNode </h3>\n<pre class=\"highlight\" data-language=\"javascript\">boolean unmountComponentAtNode(DOMElement container)\n</pre> <p>Remove a mounted React component from the DOM and clean up its event handlers and state. If no component was mounted in the container, calling this function does nothing. Returns <code>true</code> if a component was unmounted and <code>false</code> if there was no component to unmount.</p> <h3 id=\"reactdom.finddomnode\">\nReactDOM.findDOMNode </h3>\n<pre class=\"highlight\" data-language=\"javascript\">DOMElement findDOMNode(ReactComponent component)\n</pre> <p>If this component has been mounted into the DOM, this returns the corresponding native browser DOM element. This method is useful for reading values out of the DOM, such as form field values and performing DOM measurements. <strong>In most cases, you can attach a ref to the DOM node and avoid using <code>findDOMNode</code> at all.</strong> When <code>render</code> returns <code>null</code> or <code>false</code>, <code>findDOMNode</code> returns <code>null</code>.</p> <blockquote>  <p><code>findDOMNode()</code> is an escape hatch used to access the underlying DOM node. In most cases, use of this escape hatch is discouraged because it pierces the component abstraction.</p> <p><code>findDOMNode()</code> only works on mounted components (that is, components that have been placed in the DOM). If you try to call this on a component that has not been mounted yet (like calling <code>findDOMNode()</code> in <code>render()</code> on a component that has yet to be created) an exception will be thrown.</p> <p><code>findDOMNode()</code> cannot be used on stateless components.</p> </blockquote> <h2 id=\"reactdomserver\">\nReactDOMServer </h2> <p>The <code>react-dom/server</code> package allows you to render your components on the server.</p> <h3 id=\"reactdomserver.rendertostring\">\nReactDOMServer.renderToString </h3>\n<pre class=\"highlight\" data-language=\"javascript\">string renderToString(ReactElement element)\n</pre> <p>Render a ReactElement to its initial HTML. This should only be used on the server. React will return an HTML string. You can use this method to generate HTML on the server and send the markup down on the initial request for faster page loads and to allow search engines to crawl your pages for SEO purposes.</p> <p>If you call <code>ReactDOM.render()</code> on a node that already has this server-rendered markup, React will preserve it and only attach event handlers, allowing you to have a very performant first-load experience.</p> <h3 id=\"reactdomserver.rendertostaticmarkup\">\nReactDOMServer.renderToStaticMarkup </h3>\n<pre class=\"highlight\" data-language=\"javascript\">string renderToStaticMarkup(ReactElement element)\n</pre> <p>Similar to <code>renderToString</code>, except this doesn't create extra DOM attributes such as <code>data-react-id</code>, that React uses internally. This is useful if you want to use React as a simple static page generator, as stripping away the extra attributes can save lots of bytes.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/top-level-api.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/top-level-api.html</a>\n  </p>\n</div>\n","docs/language-tooling":"<h1> Language Tooling </h1>  <h2 id=\"es2015-with-jsx\">\nES2015 with JSX </h2>\n<h3 id=\"in-browser-jsx-transform\">\nIn-browser JSX Transform </h3> <p>If you like using JSX, Babel 5 provided an in-browser ES2015 and JSX transformer for development called browser.js that can be included from <a href=\"https://cdnjs.com/libraries/babel-core/5.8.34\">CDNJS</a>. Include a <code>&lt;script type=\"text/babel\"&gt;</code> tag to engage the JSX transformer.</p> <blockquote>  <p>The in-browser JSX transformer is fairly large and results in extraneous computation client-side that can be avoided. Do not use it in production â see the next section.</p> </blockquote> <h3 id=\"productionizing-precompiled-jsx\">\nProductionizing: Precompiled JSX </h3> <p>If you have <a href=\"https://www.npmjs.com/\">npm</a>, you can run <code>npm install -g babel-cli</code>. Babel has built-in support for React v0.12+. Tags are automatically transformed to their equivalent <code>React.createElement(...)</code>, <code>displayName</code> is automatically inferred and added to all <code>React.createClass</code> calls.</p> <p>This tool will translate files that use JSX syntax to plain JavaScript files that can run directly in the browser. It will also watch directories for you and automatically transform files when they are changed; for example: <code>babel --watch src/ --out-dir lib/</code>.</p> <p>Beginning with Babel 6, there are no transforms included by default. This means that options must be specified when running the <code>babel</code> command, or a <code>.babelrc</code> must specify options. Additional packages must also be installed which bundle together a number of transforms, called presets. The most common use when working with React will be to include the <code>es2015</code> and <code>react</code> presets. More information about the changes to Babel can be found in <a href=\"http://babeljs.io/blog/2015/10/29/6.0.0\">their blog post announcing Babel 6</a>.</p> <p>Here is an example of what you will do if using ES2015 syntax and React:</p> <pre class=\"highlight\" data-language=\"text\">npm install babel-preset-es2015 babel-preset-react\nbabel --presets es2015,react --watch src/ --out-dir lib/\n</pre> <p>By default JSX files with a <code>.js</code> extension are transformed. Run <code>babel --help</code> for more information on how to use Babel.</p> <p>Example output:</p> <pre class=\"highlight\" data-language=\"text\">$ cat test.js\nvar HelloMessage = React.createClass({\n  render: function() {\n    return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;;\n  }\n});\n\nReactDOM.render(&lt;HelloMessage name=\"John\" /&gt;, mountNode);\n$ babel test.js\n\"use strict\";\n\nvar HelloMessage = React.createClass({\n  displayName: \"HelloMessage\",\n\n  render: function render() {\n    return React.createElement(\n      \"div\",\n      null,\n      \"Hello \",\n      this.props.name\n    );\n  }\n});\n\nReactDOM.render(React.createElement(HelloMessage, { name: \"John\" }), mountNode);\n</pre>\n<h3 id=\"helpful-open-source-projects\">\nHelpful Open-Source Projects </h3> <p>The open-source community has built tools that integrate JSX with several editors and build systems. See <a href=\"https://github.com/facebook/react/wiki/Complementary-Tools#jsx-integrations\">JSX integrations</a> for the full list.</p> <h2 id=\"flow\">\nFlow </h2> <p>Flow is a JavaScript type checker released by Facebook, and it supports JSX. For more info, checkout the <a href=\"http://flowtype.org/\">Flow homepage</a>.</p> <h2 id=\"typescript\">\nTypeScript </h2> <p>TypeScript is a type-checker and transpiler that supports type-checking React and JSX. For more info, check out their guide on <a href=\"https://www.typescriptlang.org/docs/handbook/react-&amp;-webpack.html\">getting started with React and Webpack</a>, or learn more about <a href=\"https://www.typescriptlang.org/docs/handbook/jsx.html\">TypeScript's JSX support</a>.</p> <p>To learn more about TypeScript in general, visit the <a href=\"https://www.typescriptlang.org/\">TypeScript homepage</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/language-tooling.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/language-tooling.html</a>\n  </p>\n</div>\n","docs/clone-with-props":"<h1> Cloning ReactElements </h1>  <blockquote> <p>Note: <code>cloneWithProps</code> is deprecated. Use <a href=\"top-level-api#react.cloneelement\">React.cloneElement</a> instead.</p> </blockquote> <p>In rare situations, you may want to create a copy of a React element with different props from those of the original element. One example is cloning the elements passed into <code>this.props.children</code> and rendering them with different props:</p> <pre class=\"highlight\" data-language=\"js\">var cloneWithProps = require('react-addons-clone-with-props');\n\nvar _makeBlue = function(element) {\n  return cloneWithProps(element, {style: {color: 'blue'}});\n};\n\nvar Blue = React.createClass({\n  render: function() {\n    var blueChildren = React.Children.map(this.props.children, _makeBlue);\n    return &lt;div&gt;{blueChildren}&lt;/div&gt;;\n  }\n});\n\nReactDOM.render(\n  &lt;Blue&gt;\n    &lt;p&gt;This text is blue.&lt;/p&gt;\n  &lt;/Blue&gt;,\n  document.getElementById('container')\n);\n</pre> <p><code>cloneWithProps</code> does not transfer <code>key</code> or <code>ref</code> to the cloned element. <code>className</code> and <code>style</code> props are automatically merged.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/clone-with-props.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/clone-with-props.html</a>\n  </p>\n</div>\n","docs/advanced-performance":"<h1> Advanced Performance </h1>  <p>One of the first questions people ask when considering React for a project is whether their application will be as fast and responsive as an equivalent non-React version. The idea of re-rendering an entire subtree of components in response to every state change makes people wonder whether this process negatively impacts performance. React uses several clever techniques to minimize the number of costly DOM operations required to update the UI.</p> <h2 id=\"use-the-production-build\">\nUse the production build </h2> <p>If you're benchmarking or seeing performance problems in your React apps, make sure you're testing with the <a href=\"https://facebook.github.io/react/downloads.html\">minified production build</a>. The development build includes extra warnings that are helpful when building your apps, but it is slower due to the extra bookkeeping it does.</p> <h2 id=\"avoiding-reconciling-the-dom\">\nAvoiding reconciling the DOM </h2> <p>React makes use of a <em>virtual DOM</em>, which is a descriptor of a DOM subtree rendered in the browser. This parallel representation allows React to avoid creating DOM nodes and accessing existing ones, which is slower than operations on JavaScript objects. When a component's props or state change, React decides whether an actual DOM update is necessary by constructing a new virtual DOM and comparing it to the old one. Only in the case they are not equal, will React <a href=\"reconciliation\">reconcile</a> the DOM, applying as few mutations as possible.</p> <p>On top of this, React provides a component lifecycle function, <code>shouldComponentUpdate</code>, which is triggered before the re-rendering process starts (virtual DOM comparison and possible eventual DOM reconciliation), giving the developer the ability to short circuit this process. The default implementation of this function returns <code>true</code>, leaving React to perform the update:</p> <pre class=\"highlight\" data-language=\"javascript\">shouldComponentUpdate: function(nextProps, nextState) {\n  return true;\n}\n</pre> <p>Keep in mind that React will invoke this function pretty often, so the implementation has to be fast.</p> <p>Say you have a messaging application with several chat threads. Suppose only one of the threads has changed. If we implement <code>shouldComponentUpdate</code> on the <code>ChatThread</code> component, React can skip the rendering step for the other threads:</p> <pre class=\"highlight\" data-language=\"javascript\">shouldComponentUpdate: function(nextProps, nextState) {\n  // TODO: return whether or not current chat thread is\n  // different to former one.\n}\n</pre> <p>So, in summary, React avoids carrying out expensive DOM operations required to reconcile subtrees of the DOM by allowing the user to short circuit the process using <code>shouldComponentUpdate</code>, and, for those which should update, by comparing virtual DOMs.</p> <h2 id=\"shouldcomponentupdate-in-action\">\nshouldComponentUpdate in action </h2> <p>Here's a subtree of components. For each one is indicated what <code>shouldComponentUpdate</code> returned and whether or not the virtual DOMs were equivalent. Finally, the circle's color indicates whether the component had to be reconciled or not.</p> <figure><img src=\"https://facebook.github.io/react/img/docs/should-component-update.png\"></figure> <p>In the example above, since <code>shouldComponentUpdate</code> returned <code>false</code> for the subtree rooted at C2, React had no need to generate the new virtual DOM, and therefore, it neither needed to reconcile the DOM. Note that React didn't even have to invoke <code>shouldComponentUpdate</code> on C4 and C5.</p> <p>For C1 and C3 <code>shouldComponentUpdate</code> returned <code>true</code>, so React had to go down to the leaves and check them. For C6 it returned <code>true</code>; since the virtual DOMs weren't equivalent it had to reconcile the DOM. The last interesting case is C8. For this node React had to compute the virtual DOM, but since it was equal to the old one, it didn't have to reconcile it's DOM.</p> <p>Note that React only had to do DOM mutations for C6, which was inevitable. For C8, it bailed out by comparing the virtual DOMs, and for C2's subtree and C7, it didn't even have to compute the virtual DOM as we bailed out on <code>shouldComponentUpdate</code>.</p> <p>So, how should we implement <code>shouldComponentUpdate</code>? Say that you have a component that just renders a string value:</p> <pre class=\"highlight\" data-language=\"javascript\">React.createClass({\n  propTypes: {\n    value: React.PropTypes.string.isRequired\n  },\n\n  render: function() {\n    return &lt;div&gt;{this.props.value}&lt;/div&gt;;\n  }\n});\n</pre> <p>We could easily implement <code>shouldComponentUpdate</code> as follows:</p> <pre class=\"highlight\" data-language=\"javascript\">shouldComponentUpdate: function(nextProps, nextState) {\n  return this.props.value !== nextProps.value;\n}\n</pre> <p>So far so good, dealing with such simple props/state structures is easy. We could even generalize an implementation based on shallow equality and mix it into components. In fact, React already provides such implementation: <a href=\"pure-render-mixin\">PureRenderMixin</a>.</p> <p>But what if your components' props or state are mutable data structures? Say the prop the component receives, instead of being a string like <code>'bar'</code>, is a JavaScript object that contains a string such as, <code>{ foo: 'bar' }</code>:</p> <pre class=\"highlight\" data-language=\"javascript\">React.createClass({\n  propTypes: {\n    value: React.PropTypes.object.isRequired\n  },\n\n  render: function() {\n    return &lt;div&gt;{this.props.value.foo}&lt;/div&gt;;\n  }\n});\n</pre> <p>The implementation of <code>shouldComponentUpdate</code> we had before wouldn't always work as expected:</p> <pre class=\"highlight\" data-language=\"javascript\">// assume this.props.value is { foo: 'bar' }\n// assume nextProps.value is { foo: 'bar' },\n// but this reference is different to this.props.value\nthis.props.value !== nextProps.value; // true\n</pre> <p>The problem is <code>shouldComponentUpdate</code> will return <code>true</code> when the prop actually didn't change. To fix this, we could come up with this alternative implementation:</p> <pre class=\"highlight\" data-language=\"javascript\">shouldComponentUpdate: function(nextProps, nextState) {\n  return this.props.value.foo !== nextProps.value.foo;\n}\n</pre> <p>Basically, we ended up doing a deep comparison to make sure we properly track changes. In terms of performance, this approach is pretty expensive. It doesn't scale as we would have to write different deep equality code for each model. On top of that, it might not even work if we don't carefully manage object references. Say this component is used by a parent:</p> <pre class=\"highlight\" data-language=\"javascript\">React.createClass({\n  getInitialState: function() {\n    return { value: { foo: 'bar' } };\n  },\n\n  onClick: function() {\n    var value = this.state.value;\n    value.foo += 'bar'; // ANTI-PATTERN!\n    this.setState({ value: value });\n  },\n\n  render: function() {\n    return (\n      &lt;div&gt;\n        &lt;InnerComponent value={this.state.value} /&gt;\n        &lt;a onClick={this.onClick}&gt;Click me&lt;/a&gt;\n      &lt;/div&gt;\n    );\n  }\n});\n</pre> <p>The first time the inner component gets rendered, it will have <code>{ foo: 'bar' }</code> as the value prop. If the user clicks on the anchor, the parent component's state will get updated to <code>{ value: { foo: 'barbar' } }</code>, triggering the re-rendering process of the inner component, which will receive <code>{ foo: 'barbar' }</code> as the new value for the prop.</p> <p>The problem is that since the parent and inner components share a reference to the same object, when the object gets mutated on line 2 of the <code>onClick</code> function, the prop the inner component had will change. So, when the re-rendering process starts, and <code>shouldComponentUpdate</code> gets invoked, <code>this.props.value.foo</code> will be equal to <code>nextProps.value.foo</code>, because in fact, <code>this.props.value</code> references the same object as <code>nextProps.value</code>.</p> <p>Consequently, since we'll miss the change on the prop and short circuit the re-rendering process, the UI won't get updated from <code>'bar'</code> to <code>'barbar'</code>.</p> <h2 id=\"immutable-js-to-the-rescue\">\nImmutable-js to the rescue </h2> <p><a href=\"https://github.com/facebook/immutable-js\">Immutable-js</a> is a JavaScript collections library written by Lee Byron, which Facebook recently open-sourced. It provides <em>immutable persistent</em> collections via <em>structural sharing</em>. Let's see what these properties mean:</p> <ul> <li>\n<em>Immutable</em>: once created, a collection cannot be altered at another point in time.</li> <li>\n<em>Persistent</em>: new collections can be created from a previous collection and a mutation such as set. The original collection is still valid after the new collection is created.</li> <li>\n<em>Structural Sharing</em>: new collections are created using as much of the same structure as the original collection as possible, reducing copying to a minimum to achieve space efficiency and acceptable performance. If the new collection is equal to the original, the original is often returned.</li> </ul> <p>Immutability makes tracking changes cheap; a change will always result in a new object so we only need to check if the reference to the object has changed. For example, in this regular JavaScript code:</p> <pre class=\"highlight\" data-language=\"javascript\">var x = { foo: \"bar\" };\nvar y = x;\ny.foo = \"baz\";\nx === y; // true\n</pre> <p>Although <code>y</code> was edited, since it's a reference to the same object as <code>x</code>, this comparison returns <code>true</code>. However, this code could be written using immutable-js as follows:</p> <pre class=\"highlight\" data-language=\"javascript\">var SomeRecord = Immutable.Record({ foo: null });\nvar x = new SomeRecord({ foo: 'bar'  });\nvar y = x.set('foo', 'baz');\nx === y; // false\n</pre> <p>In this case, since a new reference is returned when mutating <code>x</code>, we can safely assume that <code>x</code> has changed.</p> <p>Another possible way to track changes could be doing dirty checking by having a flag set by setters. A problem with this approach is that it forces you to use setters and, either write a lot of additional code, or somehow instrument your classes. Alternatively, you could deep copy the object just before the mutations and deep compare to determine whether there was a change or not. A problem with this approach is both deepCopy and deepCompare are expensive operations.</p> <p>So, Immutable data structures provides you a cheap and less verbose way to track changes on objects, which is all we need to implement <code>shouldComponentUpdate</code>. Therefore, if we model props and state attributes using the abstractions provided by immutable-js we'll be able to use <code>PureRenderMixin</code> and get a nice boost in perf.</p> <h2 id=\"immutable-js-and-flux\">\nImmutable-js and Flux </h2> <p>If you're using <a href=\"https://facebook.github.io/flux/\">Flux</a>, you should start writing your stores using immutable-js. Take a look at the <a href=\"https://facebook.github.io/immutable-js/docs/#/\">full API</a>.</p> <p>Let's see one possible way to model the thread example using Immutable data structures. First, we need to define a <code>Record</code> for each of the entities we're trying to model. Records are just immutable containers that hold values for a specific set of fields:</p> <pre class=\"highlight\" data-language=\"javascript\">var User = Immutable.Record({\n  id: undefined,\n  name: undefined,\n  email: undefined\n});\n\nvar Message = Immutable.Record({\n  timestamp: new Date(),\n  sender: undefined,\n  text: ''\n});\n</pre> <p>The <code>Record</code> function receives an object that defines the fields the object has and its default values.</p> <p>The messages <em>store</em> could keep track of the users and messages using two lists:</p> <pre class=\"highlight\" data-language=\"javascript\">this.users = Immutable.List();\nthis.messages = Immutable.List();\n</pre> <p>It should be pretty straightforward to implement functions to process each <em>payload</em> type. For instance, when the store sees a payload representing a new message, we can just create a new record and append it to the messages list:</p> <pre class=\"highlight\" data-language=\"javascript\">this.messages = this.messages.push(new Message({\n  timestamp: payload.timestamp,\n  sender: payload.sender,\n  text: payload.text\n});\n</pre> <p>Note that since the data structures are immutable, we need to assign the result of the push function to <code>this.messages</code>.</p> <p>On the React side, if we also use immutable-js data structures to hold the components' state, we could mix <code>PureRenderMixin</code> into all our components and short circuit the re-rendering process.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/advanced-performance.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/advanced-performance.html</a>\n  </p>\n</div>\n","docs/test-utils":"<h1> Test Utilities </h1>  <p><code>ReactTestUtils</code> makes it easy to test React components in the testing framework of your choice (we use <a href=\"https://facebook.github.io/jest/\">Jest</a>).</p> <pre class=\"highlight\" data-language=\"text\">var ReactTestUtils = require('react-addons-test-utils');\n</pre> <blockquote>  <p>Airbnb has released a testing utility called Enzyme, which makes it easy to assert, manipulate, and traverse your React Components' output. If you're deciding on a unit testing library, it's worth checking out: <a href=\"http://airbnb.io/enzyme/\">http://airbnb.io/enzyme/</a></p> </blockquote> <h3 id=\"simulate\">\nSimulate </h3>\n<pre class=\"highlight\" data-language=\"javascript\">Simulate.{eventName}(\n  DOMElement element,\n  [object eventData]\n)\n</pre> <p>Simulate an event dispatch on a DOM node with optional <code>eventData</code> event data. <strong>This is possibly the single most useful utility in <code>ReactTestUtils</code>.</strong></p> <p><strong>Clicking an element</strong></p> <pre class=\"highlight\" data-language=\"javascript\">// &lt;button ref=\"button\"&gt;...&lt;/button&gt;\nvar node = this.refs.button;\nReactTestUtils.Simulate.click(node);\n</pre> <p><strong>Changing the value of an input field and then pressing ENTER.</strong></p> <pre class=\"highlight\" data-language=\"javascript\">// &lt;input ref=\"input\" /&gt;\nvar node = this.refs.input;\nnode.value = 'giraffe';\nReactTestUtils.Simulate.change(node);\nReactTestUtils.Simulate.keyDown(node, {key: \"Enter\", keyCode: 13, which: 13});\n</pre> <p><em>Note that you will have to provide any event property that you're using in your component (e.g. keyCode, which, etc...) as React is not creating any of these for you.</em></p> <p><code>Simulate</code> has a method for <a href=\"events#supported-events\">every event that React understands</a>.</p> <h3 id=\"renderintodocument\">\nrenderIntoDocument </h3>\n<pre class=\"highlight\" data-language=\"javascript\">ReactComponent renderIntoDocument(\n  ReactElement instance\n)\n</pre> <p>Render a component into a detached DOM node in the document. <strong>This function requires a DOM.</strong></p> <blockquote>  <p>You will need to have <code>window</code>, <code>window.document</code> and <code>window.document.createElement</code> globally available <strong>before</strong> you import React. Otherwise React will think it can't access the DOM and methods like <code>setState</code> won't work.</p> </blockquote> <h3 id=\"mockcomponent\">\nmockComponent </h3>\n<pre class=\"highlight\" data-language=\"javascript\">object mockComponent(\n  function componentClass,\n  [string mockTagName]\n)\n</pre> <p>Pass a mocked component module to this method to augment it with useful methods that allow it to be used as a dummy React component. Instead of rendering as usual, the component will become a simple <code>&lt;div&gt;</code> (or other tag if <code>mockTagName</code> is provided) containing any provided children.</p> <h3 id=\"iselement\">\nisElement </h3>\n<pre class=\"highlight\" data-language=\"javascript\">boolean isElement(\n  ReactElement element\n)\n</pre> <p>Returns <code>true</code> if <code>element</code> is any ReactElement.</p> <h3 id=\"iselementoftype\">\nisElementOfType </h3>\n<pre class=\"highlight\" data-language=\"javascript\">boolean isElementOfType(\n  ReactElement element,\n  function componentClass\n)\n</pre> <p>Returns <code>true</code> if <code>element</code> is a ReactElement whose type is of a React <code>componentClass</code>.</p> <h3 id=\"isdomcomponent\">\nisDOMComponent </h3>\n<pre class=\"highlight\" data-language=\"javascript\">boolean isDOMComponent(\n  ReactComponent instance\n)\n</pre> <p>Returns <code>true</code> if <code>instance</code> is a DOM component (such as a <code>&lt;div&gt;</code> or <code>&lt;span&gt;</code>).</p> <h3 id=\"iscompositecomponent\">\nisCompositeComponent </h3>\n<pre class=\"highlight\" data-language=\"javascript\">boolean isCompositeComponent(\n  ReactComponent instance\n)\n</pre> <p>Returns <code>true</code> if <code>instance</code> is a composite component (created with <code>React.createClass()</code>).</p> <h3 id=\"iscompositecomponentwithtype\">\nisCompositeComponentWithType </h3>\n<pre class=\"highlight\" data-language=\"javascript\">boolean isCompositeComponentWithType(\n  ReactComponent instance,\n  function componentClass\n)\n</pre> <p>Returns <code>true</code> if <code>instance</code> is a composite component (created with <code>React.createClass()</code>) whose type is of a React <code>componentClass</code>.</p> <h3 id=\"findallinrenderedtree\">\nfindAllInRenderedTree </h3>\n<pre class=\"highlight\" data-language=\"javascript\">array findAllInRenderedTree(\n  ReactComponent tree,\n  function test\n)\n</pre> <p>Traverse all components in <code>tree</code> and accumulate all components where <code>test(component)</code> is <code>true</code>. This is not that useful on its own, but it's used as a primitive for other test utils.</p> <h3 id=\"scryrendereddomcomponentswithclass\">\nscryRenderedDOMComponentsWithClass </h3>\n<pre class=\"highlight\" data-language=\"javascript\">array scryRenderedDOMComponentsWithClass(\n  ReactComponent tree, \n  string className\n)\n</pre> <p>Finds all DOM elements of components in the rendered tree that are DOM components with the class name matching <code>className</code>.</p> <h3 id=\"findrendereddomcomponentwithclass\">\nfindRenderedDOMComponentWithClass </h3>\n<pre class=\"highlight\" data-language=\"javascript\">DOMElement findRenderedDOMComponentWithClass(\n  ReactComponent tree,\n  string className\n)\n</pre> <p>Like <code>scryRenderedDOMComponentsWithClass()</code> but expects there to be one result, and returns that one result, or throws exception if there is any other number of matches besides one.</p> <h3 id=\"scryrendereddomcomponentswithtag\">\nscryRenderedDOMComponentsWithTag </h3>\n<pre class=\"highlight\" data-language=\"javascript\">array scryRenderedDOMComponentsWithTag(\n  ReactComponent tree,\n  string tagName\n)\n</pre> <p>Finds all DOM elements of components in the rendered tree that are DOM components with the tag name matching <code>tagName</code>.</p> <h3 id=\"findrendereddomcomponentwithtag\">\nfindRenderedDOMComponentWithTag </h3>\n<pre class=\"highlight\" data-language=\"javascript\">DOMElement findRenderedDOMComponentWithTag(\n  ReactComponent tree,\n  string tagName\n)\n</pre> <p>Like <code>scryRenderedDOMComponentsWithTag()</code> but expects there to be one result, and returns that one result, or throws exception if there is any other number of matches besides one.</p> <h3 id=\"scryrenderedcomponentswithtype\">\nscryRenderedComponentsWithType </h3>\n<pre class=\"highlight\" data-language=\"javascript\">array scryRenderedComponentsWithType(\n  ReactComponent tree,\n  function componentClass\n)\n</pre> <p>Finds all instances of components with type equal to <code>componentClass</code>.</p> <h3 id=\"findrenderedcomponentwithtype\">\nfindRenderedComponentWithType </h3>\n<pre class=\"highlight\" data-language=\"javascript\">ReactComponent findRenderedComponentWithType(\n  ReactComponent tree, \n  function componentClass\n)\n</pre> <p>Same as <code>scryRenderedComponentsWithType()</code> but expects there to be one result and returns that one result, or throws exception if there is any other number of matches besides one.</p> <h2 id=\"shallow-rendering\">\nShallow rendering </h2> <p>Shallow rendering is an experimental feature that lets you render a component \"one level deep\" and assert facts about what its render method returns, without worrying about the behavior of child components, which are not instantiated or rendered. This does not require a DOM.</p> <pre class=\"highlight\" data-language=\"javascript\">ReactShallowRenderer createRenderer()\n</pre> <p>Call this in your tests to create a shallow renderer. You can think of this as a \"place\" to render the component you're testing, where it can respond to events and update itself.</p> <pre class=\"highlight\" data-language=\"javascript\">shallowRenderer.render(\n  ReactElement element\n)\n</pre> <p>Similar to <code>ReactDOM.render</code>.</p> <pre class=\"highlight\" data-language=\"javascript\">ReactElement shallowRenderer.getRenderOutput()\n</pre> <p>After <code>render</code> has been called, returns shallowly rendered output. You can then begin to assert facts about the output. For example, if your component's render method returns:</p> <pre class=\"highlight\" data-language=\"javascript\">&lt;div&gt;\n  &lt;span className=\"heading\"&gt;Title&lt;/span&gt;\n  &lt;Subcomponent foo=\"bar\" /&gt;\n&lt;/div&gt;\n</pre> <p>Then you can assert:</p> <pre class=\"highlight\" data-language=\"javascript\">var renderer = ReactTestUtils.createRenderer();\nresult = renderer.getRenderOutput();\nexpect(result.type).toBe('div');\nexpect(result.props.children).toEqual([\n  &lt;span className=\"heading\"&gt;Title&lt;/span&gt;,\n  &lt;Subcomponent foo=\"bar\" /&gt;\n]);\n</pre> <p>Shallow testing currently has some limitations, namely not supporting refs. We're releasing this feature early and would appreciate the React community's feedback on how it should evolve.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/test-utils.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/test-utils.html</a>\n  </p>\n</div>\n","docs/component-api":"<h1> Component API </h1>  <h2 id=\"react.component\">\nReact.Component </h2> <p>Instances of a React Component are created internally in React when rendering. These instances are reused in subsequent renders, and can be accessed in your component methods as <code>this</code>. The only way to get a handle to a React Component instance outside of React is by storing the return value of <code>ReactDOM.render</code>. Inside other Components, you may use <a href=\"more-about-refs\">refs</a> to achieve the same result.</p> <h3 id=\"setstate\">\nsetState </h3>\n<pre class=\"highlight\" data-language=\"javascript\">void setState(\n  function|object nextState,\n  [function callback]\n)\n</pre> <p>Performs a shallow merge of nextState into current state. This is the primary method you use to trigger UI updates from event handlers and server request callbacks.</p> <p>The first argument can be an object (containing zero or more keys to update) or a function (of state and props) that returns an object containing keys to update.</p> <p>Here is the simple object usage:</p> <pre class=\"highlight\" data-language=\"javascript\">setState({mykey: 'my new value'});\n</pre> <p>It's also possible to pass a function with the signature <code>function(state, props)</code>. This can be useful in some cases when you want to enqueue an atomic update that consults the previous value of state+props before setting any values. For instance, suppose we wanted to increment a value in state:</p> <pre class=\"highlight\" data-language=\"javascript\">setState(function(previousState, currentProps) {\n  return {myInteger: previousState.myInteger + 1};\n});\n</pre> <p>The second (optional) parameter is a callback function that will be executed once <code>setState</code> is completed and the component is re-rendered.</p> <blockquote> <p>Notes:</p> <p><em>NEVER</em> mutate <code>this.state</code> directly, as calling <code>setState()</code> afterwards may replace the mutation you made. Treat <code>this.state</code> as if it were immutable.</p> <p><code>setState()</code> does not immediately mutate <code>this.state</code> but creates a pending state transition. Accessing <code>this.state</code> after calling this method can potentially return the existing value.</p> <p>There is no guarantee of synchronous operation of calls to <code>setState</code> and calls may be batched for performance gains.</p> <p><code>setState()</code> will always trigger a re-render unless conditional rendering logic is implemented in <code>shouldComponentUpdate()</code>. If mutable objects are being used and the logic cannot be implemented in <code>shouldComponentUpdate()</code>, calling <code>setState()</code> only when the new state differs from the previous state will avoid unnecessary re-renders.</p> </blockquote> <h3 id=\"replacestate\">\nreplaceState </h3>\n<pre class=\"highlight\" data-language=\"javascript\">void replaceState(\n  object nextState,\n  [function callback]\n)\n</pre> <p>Like <code>setState()</code> but deletes any pre-existing state keys that are not in nextState.</p> <blockquote>  <p>This method is not available on ES6 <code>class</code> components that extend <code>React.Component</code>. It may be removed entirely in a future version of React.</p> </blockquote> <h3 id=\"forceupdate\">\nforceUpdate </h3>\n<pre class=\"highlight\" data-language=\"javascript\">void forceUpdate(\n  [function callback]\n)\n</pre> <p>By default, when your component's state or props change, your component will re-render. However, if these change implicitly (eg: data deep within an object changes without changing the object itself) or if your <code>render()</code> method depends on some other data, you can tell React that it needs to re-run <code>render()</code> by calling <code>forceUpdate()</code>.</p> <p>Calling <code>forceUpdate()</code> will cause <code>render()</code> to be called on the component, skipping <code>shouldComponentUpdate()</code>. This will trigger the normal lifecycle methods for child components, including the <code>shouldComponentUpdate()</code> method of each child. React will still only update the DOM if the markup changes.</p> <p>Normally you should try to avoid all uses of <code>forceUpdate()</code> and only read from <code>this.props</code> and <code>this.state</code> in <code>render()</code>. This makes your component \"pure\" and your application much simpler and more efficient.</p> <h3 id=\"ismounted\">\nisMounted </h3>\n<pre class=\"highlight\" data-language=\"javascript\">boolean isMounted()\n</pre> <p><code>isMounted()</code> returns <code>true</code> if the component is rendered into the DOM, <code>false</code> otherwise. You can use this method to guard asynchronous calls to <code>setState()</code> or <code>forceUpdate()</code>.</p> <blockquote>  <p>This method is not available on ES6 <code>class</code> components that extend <code>React.Component</code>. It will likely be removed entirely in a future version of React, so you might as well <a href=\"https://facebook.github.io/react/blog/2015/12/16/ismounted-antipattern.html\">start migrating away from isMounted() now</a>.</p> </blockquote><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/component-api.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/component-api.html</a>\n  </p>\n</div>\n","docs/component-specs":"<h1> Component Specs and Lifecycle </h1>  <h2 id=\"component-specifications\">\nComponent Specifications </h2> <p>When creating a component class by invoking <code>React.createClass()</code>, you should provide a specification object that contains a <code>render</code> method and can optionally contain other lifecycle methods described here.</p> <blockquote>  <p>It is also possible to use plain JavaScript classes as component classes. These classes can implement most of the same methods, though there are some differences. For more information about these differences, please read our documentation about <a href=\"reusable-components#es6-classes\">ES6 classes</a>.</p> </blockquote> <h3 id=\"render\">\nrender </h3>\n<pre class=\"highlight\" data-language=\"javascript\">ReactElement render()\n</pre> <p>The <code>render()</code> method is required.</p> <p>When called, it should examine <code>this.props</code> and <code>this.state</code> and return a single child element. This child element can be either a virtual representation of a native DOM component (such as <code>&lt;div /&gt;</code> or <code>React.DOM.div()</code>) or another composite component that you've defined yourself.</p> <p>You can also return <code>null</code> or <code>false</code> to indicate that you don't want anything rendered. Behind the scenes, React renders a <code>&lt;noscript&gt;</code> tag to work with our current diffing algorithm. When returning <code>null</code> or <code>false</code>, <code>ReactDOM.findDOMNode(this)</code> will return <code>null</code>.</p> <p>The <code>render()</code> function should be <em>pure</em>, meaning that it does not modify component state, it returns the same result each time it's invoked, and it does not read from or write to the DOM or otherwise interact with the browser (e.g., by using <code>setTimeout</code>). If you need to interact with the browser, perform your work in <code>componentDidMount()</code> or the other lifecycle methods instead. Keeping <code>render()</code> pure makes server rendering more practical and makes components easier to think about.</p> <h3 id=\"getinitialstate\">\ngetInitialState </h3>\n<pre class=\"highlight\" data-language=\"javascript\">object getInitialState()\n</pre> <p>Invoked once before the component is mounted. The return value will be used as the initial value of <code>this.state</code>.</p> <h3 id=\"getdefaultprops\">\ngetDefaultProps </h3>\n<pre class=\"highlight\" data-language=\"javascript\">object getDefaultProps()\n</pre> <p>Invoked once and cached when the class is created. Values in the mapping will be set on <code>this.props</code> if that prop is not specified by the parent component (i.e. using an <code>in</code> check).</p> <p>This method is invoked before any instances are created and thus cannot rely on <code>this.props</code>. In addition, be aware that any complex objects returned by <code>getDefaultProps()</code> will be shared across instances, not copied.</p> <h3 id=\"proptypes\">\npropTypes </h3>\n<pre class=\"highlight\" data-language=\"javascript\">object propTypes\n</pre> <p>The <code>propTypes</code> object allows you to validate props being passed to your components. For more information about <code>propTypes</code>, see <a href=\"reusable-components\">Reusable Components</a>.</p> <h3 id=\"mixins\">\nmixins </h3>\n<pre class=\"highlight\" data-language=\"javascript\">array mixins\n</pre> <p>The <code>mixins</code> array allows you to use mixins to share behavior among multiple components. For more information about mixins, see <a href=\"reusable-components\">Reusable Components</a>.</p> <h3 id=\"statics\">\nstatics </h3>\n<pre class=\"highlight\" data-language=\"javascript\">object statics\n</pre> <p>The <code>statics</code> object allows you to define static methods that can be called on the component class. For example:</p> <pre class=\"highlight\" data-language=\"javascript\">var MyComponent = React.createClass({\n  statics: {\n    customMethod: function(foo) {\n      return foo === 'bar';\n    }\n  },\n  render: function() {\n  }\n});\n\nMyComponent.customMethod('bar');  // true\n</pre> <p>Methods defined within this block are <em>static</em>, meaning that you can run them before any component instances are created, and the methods do not have access to the props or state of your components. If you want to check the value of props in a static method, have the caller pass in the props as an argument to the static method.</p> <h3 id=\"displayname\">\ndisplayName </h3>\n<pre class=\"highlight\" data-language=\"javascript\">string displayName\n</pre> <p>The <code>displayName</code> string is used in debugging messages. JSX sets this value automatically; see <a href=\"jsx-in-depth#the-transform\">JSX in Depth</a>.</p> <h2 id=\"lifecycle-methods\">\nLifecycle Methods </h2> <p>Various methods are executed at specific points in a component's lifecycle.</p> <h3 id=\"mounting-componentwillmount\">\nMounting: componentWillMount </h3>\n<pre class=\"highlight\" data-language=\"javascript\">void componentWillMount()\n</pre> <p>Invoked once, both on the client and server, immediately before the initial rendering occurs. If you call <code>setState</code> within this method, <code>render()</code> will see the updated state and will be executed only once despite the state change.</p> <h3 id=\"mounting-componentdidmount\">\nMounting: componentDidMount </h3>\n<pre class=\"highlight\" data-language=\"javascript\">void componentDidMount()\n</pre> <p>Invoked once, only on the client (not on the server), immediately after the initial rendering occurs. At this point in the lifecycle, you can access any refs to your children (e.g., to access the underlying DOM representation). The <code>componentDidMount()</code> method of child components is invoked before that of parent components.</p> <p>If you want to integrate with other JavaScript frameworks, set timers using <code>setTimeout</code> or <code>setInterval</code>, or send AJAX requests, perform those operations in this method.</p> <h3 id=\"updating-componentwillreceiveprops\">\nUpdating: componentWillReceiveProps </h3>\n<pre class=\"highlight\" data-language=\"javascript\">void componentWillReceiveProps(\n  object nextProps\n)\n</pre> <p>Invoked when a component is receiving new props. This method is not called for the initial render.</p> <p>Use this as an opportunity to react to a prop transition before <code>render()</code> is called by updating the state using <code>this.setState()</code>. The old props can be accessed via <code>this.props</code>. Calling <code>this.setState()</code> within this function will not trigger an additional render.</p> <pre class=\"highlight\" data-language=\"javascript\">componentWillReceiveProps: function(nextProps) {\n  this.setState({\n    likesIncreasing: nextProps.likeCount &gt; this.props.likeCount\n  });\n}\n</pre> <blockquote>  <p>One common mistake is for code executed during this lifecycle method to assume that props have changed. To understand why this is invalid, read <a href=\"https://facebook.github.io/react/blog/2016/01/08/A-implies-B-does-not-imply-B-implies-A.html\">A implies B does not imply B implies A</a></p> <p>There is no analogous method <code>componentWillReceiveState</code>. An incoming prop transition may cause a state change, but the opposite is not true. If you need to perform operations in response to a state change, use <code>componentWillUpdate</code>.</p> </blockquote> <h3 id=\"updating-shouldcomponentupdate\">\nUpdating: shouldComponentUpdate </h3>\n<pre class=\"highlight\" data-language=\"javascript\">boolean shouldComponentUpdate(\n  object nextProps, object nextState\n)\n</pre> <p>Invoked before rendering when new props or state are being received. This method is not called for the initial render or when <code>forceUpdate</code> is used.</p> <p>Use this as an opportunity to <code>return false</code> when you're certain that the transition to the new props and state will not require a component update.</p> <pre class=\"highlight\" data-language=\"javascript\">shouldComponentUpdate: function(nextProps, nextState) {\n  return nextProps.id !== this.props.id;\n}\n</pre> <p>If <code>shouldComponentUpdate</code> returns false, then <code>render()</code> will be completely skipped until the next state change. In addition, <code>componentWillUpdate</code> and <code>componentDidUpdate</code> will not be called.</p> <p>By default, <code>shouldComponentUpdate</code> always returns <code>true</code> to prevent subtle bugs when <code>state</code> is mutated in place, but if you are careful to always treat <code>state</code> as immutable and to read only from <code>props</code> and <code>state</code> in <code>render()</code> then you can override <code>shouldComponentUpdate</code> with an implementation that compares the old props and state to their replacements.</p> <p>If performance is a bottleneck, especially with dozens or hundreds of components, use <code>shouldComponentUpdate</code> to speed up your app.</p> <h3 id=\"updating-componentwillupdate\">\nUpdating: componentWillUpdate </h3>\n<pre class=\"highlight\" data-language=\"javascript\">void componentWillUpdate(\n  object nextProps, object nextState\n)\n</pre> <p>Invoked immediately before rendering when new props or state are being received. This method is not called for the initial render.</p> <p>Use this as an opportunity to perform preparation before an update occurs.</p> <blockquote>  <p>You <em>cannot</em> use <code>this.setState()</code> in this method. If you need to update state in response to a prop change, use <code>componentWillReceiveProps</code> instead.</p> </blockquote> <h3 id=\"updating-componentdidupdate\">\nUpdating: componentDidUpdate </h3>\n<pre class=\"highlight\" data-language=\"javascript\">void componentDidUpdate(\n  object prevProps, object prevState\n)\n</pre> <p>Invoked immediately after the component's updates are flushed to the DOM. This method is not called for the initial render.</p> <p>Use this as an opportunity to operate on the DOM when the component has been updated.</p> <h3 id=\"unmounting-componentwillunmount\">\nUnmounting: componentWillUnmount </h3>\n<pre class=\"highlight\" data-language=\"javascript\">void componentWillUnmount()\n</pre> <p>Invoked immediately before a component is unmounted from the DOM.</p> <p>Perform any necessary cleanup in this method, such as invalidating timers or cleaning up any DOM elements that were created in <code>componentDidMount</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/component-specs.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/component-specs.html</a>\n  </p>\n</div>\n","docs/tags-and-attributes":"<h1> Tags and Attributes </h1>  <h2 id=\"supported-elements\">\nSupported Elements </h2> <p>React attempts to support all common elements in both HTML and SVG. Any lower case tag in JSX will be rendered to an element with that tag. SVG elements must be contained within an <code>&lt;svg&gt;</code> element to work properly.</p> <h3 id=\"using-react.dom-factory-methods\">\nUsing <code>React.DOM</code> Factory methods </h3> <p>If you aren't using JSX and are using the <code>React.DOM.*</code> API to create elements, then you are slightly more limited and there is list of supported elements that will be available on that API.</p> <h4 id=\"html-elements\">\nHTML Elements </h4> <p>The following HTML elements are supported in <code>React.DOM.*</code>:</p> <pre class=\"highlight\" data-language=\"text\">a abbr address area article aside audio b base bdi bdo big blockquote body br\nbutton canvas caption cite code col colgroup data datalist dd del details dfn\ndialog div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5\nh6 head header hgroup hr html i iframe img input ins kbd keygen label legend li\nlink main map mark menu menuitem meta meter nav noscript object ol optgroup\noption output p param picture pre progress q rp rt ruby s samp script section\nselect small source span strong style sub summary sup table tbody td textarea\ntfoot th thead time title tr track u ul var video wbr\n</pre>\n<h4 id=\"svg-elements\">\nSVG elements </h4> <p>The following SVG elements are supported in <code>React.DOM.*</code>:</p> <pre class=\"highlight\" data-language=\"text\">circle clipPath defs ellipse g image line linearGradient mask path pattern\npolygon polyline radialGradient rect stop svg text tspan\n</pre> <p>You may also be interested in <a href=\"https://github.com/facebook/react-art\">react-art</a>, a cross-browser drawing library for React.</p> <h2 id=\"supported-attributes\">\nSupported Attributes </h2> <p>React supports all <code>data-*</code> and <code>aria-*</code> attributes as well as every attribute in the following lists.</p> <blockquote>  <p>All attributes are camel-cased and the attributes <code>class</code> and <code>for</code> are <code>className</code> and <code>htmlFor</code>, respectively, to match the DOM API specification.</p> </blockquote> <p>For a list of events, see <a href=\"events\">Supported Events</a>.</p> <h3 id=\"html-attributes\">\nHTML Attributes </h3> <p>These standard attributes are supported:</p> <pre class=\"highlight\" data-language=\"text\">accept acceptCharset accessKey action allowFullScreen allowTransparency alt\nasync autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\ncharSet checked cite classID className colSpan cols content contentEditable\ncontextMenu controls coords crossOrigin data dateTime default defer dir\ndisabled download draggable encType form formAction formEncType formMethod\nformNoValidate formTarget frameBorder headers height hidden high href hrefLang\nhtmlFor httpEquiv icon id inputMode integrity is keyParams keyType kind label\nlang list loop low manifest marginHeight marginWidth max maxLength media\nmediaGroup method min minLength multiple muted name noValidate nonce open\noptimum pattern placeholder poster preload profile radioGroup readOnly rel\nrequired reversed role rowSpan rows sandbox scope scoped scrolling seamless\nselected shape size sizes span spellCheck src srcDoc srcLang srcSet start step\nstyle summary tabIndex target title type useMap value width wmode wrap\n</pre> <p>These RDFa attributes are supported (several RDFa attributes overlap with standard HTML attributes and thus are excluded from this list):</p> <pre class=\"highlight\" data-language=\"text\">about datatype inlist prefix property resource typeof vocab\n</pre> <p>In addition, the following non-standard attributes are supported:</p> <ul> <li>\n<code>autoCapitalize autoCorrect</code> for Mobile Safari.</li> <li>\n<code>color</code> for <code>&lt;link rel=\"mask-icon\" /&gt;</code> in Safari.</li> <li>\n<code>itemProp itemScope itemType itemRef itemID</code> for <a href=\"http://schema.org/docs/gs.html\">HTML5 microdata</a>.</li> <li>\n<code>security</code> for older versions of Internet Explorer.</li> <li>\n<code>unselectable</code> for Internet Explorer.</li> <li>\n<code>results autoSave</code> for WebKit/Blink input fields of type <code>search</code>.</li> </ul> <p>There is also 2 React-specific attributes: - <code>dangerouslySetInnerHTML</code> (<a href=\"special-non-dom-attributes\">more here</a>), used for directly inserting HTML strings into a component. - <code>suppressContentEditableWarning</code>, used to suppress the warning when using <code>contentEditable</code> and <code>children</code>.</p> <h3 id=\"svg-attributes\">\nSVG Attributes </h3>\n<pre class=\"highlight\" data-language=\"text\">accentHeight accumulate additive alignmentBaseline allowReorder alphabetic\namplitude arabicForm ascent attributeName attributeType autoReverse azimuth\nbaseFrequency baseProfile baselineShift bbox begin bias by calcMode capHeight\nclip clipPath clipPathUnits clipRule colorInterpolation\ncolorInterpolationFilters colorProfile colorRendering contentScriptType\ncontentStyleType cursor cx cy d decelerate descent diffuseConstant direction\ndisplay divisor dominantBaseline dur dx dy edgeMode elevation enableBackground\nend exponent externalResourcesRequired fill fillOpacity fillRule filter\nfilterRes filterUnits floodColor floodOpacity focusable fontFamily fontSize\nfontSizeAdjust fontStretch fontStyle fontVariant fontWeight format from fx fy\ng1 g2 glyphName glyphOrientationHorizontal glyphOrientationVertical glyphRef\ngradientTransform gradientUnits hanging horizAdvX horizOriginX ideographic\nimageRendering in in2 intercept k k1 k2 k3 k4 kernelMatrix kernelUnitLength\nkerning keyPoints keySplines keyTimes lengthAdjust letterSpacing lightingColor\nlimitingConeAngle local markerEnd markerHeight markerMid markerStart\nmarkerUnits markerWidth mask maskContentUnits maskUnits mathematical mode\nnumOctaves offset opacity operator order orient orientation origin overflow\noverlinePosition overlineThickness paintOrder panose1 pathLength\npatternContentUnits patternTransform patternUnits pointerEvents points\npointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits\nr radius refX refY renderingIntent repeatCount repeatDur requiredExtensions\nrequiredFeatures restart result rotate rx ry scale seed shapeRendering slope\nspacing specularConstant specularExponent speed spreadMethod startOffset\nstdDeviation stemh stemv stitchTiles stopColor stopOpacity\nstrikethroughPosition strikethroughThickness string stroke strokeDasharray\nstrokeDashoffset strokeLinecap strokeLinejoin strokeMiterlimit strokeOpacity\nstrokeWidth surfaceScale systemLanguage tableValues targetX targetY textAnchor\ntextDecoration textLength textRendering to transform u1 u2 underlinePosition\nunderlineThickness unicode unicodeBidi unicodeRange unitsPerEm vAlphabetic\nvHanging vIdeographic vMathematical values vectorEffect version vertAdvY\nvertOriginX vertOriginY viewBox viewTarget visibility widths wordSpacing\nwritingMode x x1 x2 xChannelSelector xHeight xlinkActuate xlinkArcrole\nxlinkHref xlinkRole xlinkShow xlinkTitle xlinkType xmlBase xmlLang xmlSpace\ny y1 y2 yChannelSelector z zoomAndPan\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/tags-and-attributes.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/tags-and-attributes.html</a>\n  </p>\n</div>\n","docs/dom-differences":"<h1> DOM Differences </h1>  <p>React has implemented a browser-independent events and DOM system for performance and cross-browser compatibility reasons. We took the opportunity to clean up a few rough edges in browser DOM implementations.</p> <ul> <li>All DOM properties and attributes (including event handlers) should be camelCased to be consistent with standard JavaScript style. We intentionally break with the spec here since the spec is inconsistent. <strong>However</strong>, <code>data-*</code> and <code>aria-*</code> attributes <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#data-*\">conform to the specs</a> and should be lower-cased only.</li> <li>The <code>style</code> attribute accepts a JavaScript object with camelCased properties rather than a CSS string. This is consistent with the DOM <code>style</code> JavaScript property, is more efficient, and prevents XSS security holes.</li> <li>Since <code>class</code> and <code>for</code> are reserved words in JavaScript, the JSX elements for built-in <a href=\"http://javascript.info/tutorial/dom-nodes\">DOM nodes</a> should use the attribute names <code>className</code> and <code>htmlFor</code> respectively, (eg. <code>&lt;div className=\"foo\" /&gt;</code> ). Custom elements should use <code>class</code> and <code>for</code> directly (eg. <code>&lt;my-tag class=\"foo\" /&gt;</code> ).</li> <li>All event objects conform to the W3C spec, and all events (including submit) bubble correctly per the W3C spec. See <a href=\"events\">Event System</a> for more details.</li> <li>The <code>onChange</code> event behaves as you would expect it to: whenever a form field is changed this event is fired rather than inconsistently on blur. We intentionally break from existing browser behavior because <code>onChange</code> is a misnomer for its behavior and React relies on this event to react to user input in real time. See <a href=\"forms\">Forms</a> for more details.</li> <li>Form input attributes such as <code>value</code> and <code>checked</code>, as well as <code>textarea</code>. <a href=\"forms\">More here</a>.</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/dom-differences.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/dom-differences.html</a>\n  </p>\n</div>\n","docs/pure-render-mixin":"<h1> PureRenderMixin </h1>  <p>If your React component's render function is \"pure\" (in other words, it renders the same result given the same props and state), you can use this mixin for a performance boost in some cases.</p> <p>Example:</p> <pre class=\"highlight\" data-language=\"js\">var PureRenderMixin = require('react-addons-pure-render-mixin');\nReact.createClass({\n  mixins: [PureRenderMixin],\n\n  render: function() {\n    return &lt;div className={this.props.className}&gt;foo&lt;/div&gt;;\n  }\n});\n</pre> <p>Example using ES6 class syntax:</p> <pre class=\"highlight\" data-language=\"js\">import PureRenderMixin from 'react-addons-pure-render-mixin';\nclass FooComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this);\n  }\n\n  render() {\n    return &lt;div className={this.props.className}&gt;foo&lt;/div&gt;;\n  }\n}\n</pre> <p>Under the hood, the mixin implements <a href=\"component-specs#updating-shouldcomponentupdate\">shouldComponentUpdate</a>, in which it compares the current props and state with the next ones and returns <code>false</code> if the equalities pass.</p> <blockquote>  <p>This only shallowly compares the objects. If these contain complex data structures, it may produce false-negatives for deeper differences. Only mix into components which have simple props and state, or use <code>forceUpdate()</code> when you know deep data structures have changed. Or, consider using <a href=\"https://facebook.github.io/immutable-js/\">immutable objects</a> to facilitate fast comparisons of nested data.</p> <p>Furthermore, <code>shouldComponentUpdate</code> skips updates for the whole component subtree. Make sure all the children components are also \"pure\".</p> </blockquote><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/pure-render-mixin.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/pure-render-mixin.html</a>\n  </p>\n</div>\n","tips/self-closing-tag":"<h1>Self-Closing Tag</h1>  <p>In JSX, <code>&lt;MyComponent /&gt;</code> alone is valid while <code>&lt;MyComponent&gt;</code> isn't. All tags must be closed, either with the self-closing format or with a corresponding closing tag (<code>&lt;/MyComponent&gt;</code>).</p> <blockquote>  <p>Every React component can be self-closing: <code>&lt;div /&gt;</code>. <code>&lt;div&gt;&lt;/div&gt;</code> is also an equivalent.</p> </blockquote><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/tips/self-closing-tag.html\" class=\"_attribution-link\">https://facebook.github.io/react/tips/self-closing-tag.html</a>\n  </p>\n</div>\n","docs/create-fragment":"<h1> Keyed Fragments </h1>  <p>In most cases, you can use the <code>key</code> prop to specify keys on the elements you're returning from <code>render</code>. However, this breaks down in one situation: if you have two sets of children that you need to reorder, there's no way to put a key on each set without adding a wrapper element.</p> <p>That is, if you have a component such as:</p> <pre class=\"highlight\" data-language=\"js\">var Swapper = React.createClass({\n  propTypes: {\n    // `leftChildren` and `rightChildren` can be a string, element, array, etc.\n    leftChildren: React.PropTypes.node,\n    rightChildren: React.PropTypes.node,\n\n    swapped: React.PropTypes.bool\n  },\n  render: function() {\n    var children;\n    if (this.props.swapped) {\n      children = [this.props.rightChildren, this.props.leftChildren];\n    } else {\n      children = [this.props.leftChildren, this.props.rightChildren];\n    }\n    return &lt;div&gt;{children}&lt;/div&gt;;\n  }\n});\n</pre> <p>The children will unmount and remount as you change the <code>swapped</code> prop because there aren't any keys marked on the two sets of children.</p> <p>To solve this problem, you can use the <code>createFragment</code> add-on to give keys to the sets of children.</p> <h4 id=\"arrayltreactnodegt-createfragmentobject-children\">\n<code>Array&lt;ReactNode&gt; createFragment(object children)</code> </h4> <p>Instead of creating arrays, we write:</p> <pre class=\"highlight\" data-language=\"js\">var createFragment = require('react-addons-create-fragment');\n\nif (this.props.swapped) {\n  children = createFragment({\n    right: this.props.rightChildren,\n    left: this.props.leftChildren\n  });\n} else {\n  children = createFragment({\n    left: this.props.leftChildren,\n    right: this.props.rightChildren\n  });\n}\n</pre> <p>The keys of the passed object (that is, <code>left</code> and <code>right</code>) are used as keys for the entire set of children, and the order of the object's keys is used to determine the order of the rendered children. With this change, the two sets of children will be properly reordered in the DOM without unmounting.</p> <p>The return value of <code>createFragment</code> should be treated as an opaque object; you can use the <code>React.Children</code> helpers to loop through a fragment but should not access it directly. Note also that we're relying on the JavaScript engine preserving object enumeration order here, which is not guaranteed by the spec but is implemented by all major browsers and VMs for objects with non-numeric keys.</p> <blockquote>  <p>In the future, <code>createFragment</code> may be replaced by an API such as</p> <pre class=\"highlight\" data-language=\"js\">return (\n  &lt;div&gt;\n    &lt;x:frag key=\"right\"&gt;{this.props.rightChildren}&lt;/x:frag&gt;,\n    &lt;x:frag key=\"left\"&gt;{this.props.leftChildren}&lt;/x:frag&gt;\n  &lt;/div&gt;\n);\n</pre> <p>allowing you to assign keys directly in JSX without adding wrapper elements.</p> </blockquote><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/create-fragment.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/create-fragment.html</a>\n  </p>\n</div>\n","tips/style-props-value-px":"<h1>Shorthand for Specifying Pixel Values in style props</h1>  <p>When specifying a pixel value for your inline <code>style</code> prop, React automatically appends the string \"px\" for you after your number value, so this works:</p> <pre class=\"highlight\" data-language=\"js\">var divStyle = {height: 10}; // rendered as \"height:10px\"\nReactDOM.render(&lt;div style={divStyle}&gt;Hello World!&lt;/div&gt;, mountNode);\n</pre> <p>See <a href=\"inline-styles\">Inline Styles</a> for more info.</p> <p>Sometimes you <em>do</em> want to keep the CSS properties unitless. Here's a list of properties that won't get the automatic \"px\" suffix:</p> <ul> <li><code>animationIterationCount</code></li> <li><code>boxFlex</code></li> <li><code>boxFlexGroup</code></li> <li><code>boxOrdinalGroup</code></li> <li><code>columnCount</code></li> <li><code>fillOpacity</code></li> <li><code>flex</code></li> <li><code>flexGrow</code></li> <li><code>flexPositive</code></li> <li><code>flexShrink</code></li> <li><code>flexNegative</code></li> <li><code>flexOrder</code></li> <li><code>fontWeight</code></li> <li><code>lineClamp</code></li> <li><code>lineHeight</code></li> <li><code>opacity</code></li> <li><code>order</code></li> <li><code>orphans</code></li> <li><code>stopOpacity</code></li> <li><code>strokeDashoffset</code></li> <li><code>strokeOpacity</code></li> <li><code>strokeWidth</code></li> <li><code>tabSize</code></li> <li><code>widows</code></li> <li><code>zIndex</code></li> <li><code>zoom</code></li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/tips/style-props-value-px.html\" class=\"_attribution-link\">https://facebook.github.io/react/tips/style-props-value-px.html</a>\n  </p>\n</div>\n","docs/multiple-components":"<h1> Multiple Components </h1>  <p>So far, we've looked at how to write a single component to display data and handle user input. Next let's examine one of React's finest features: composability.</p> <h2 id=\"motivation-separation-of-concerns\">\nMotivation: Separation of Concerns </h2> <p>By building modular components that reuse other components with well-defined interfaces, you get much of the same benefits that you get by using functions or classes. Specifically you can <em>separate the different concerns</em> of your app however you please simply by building new components. By building a custom component library for your application, you are expressing your UI in a way that best fits your domain.</p> <h2 id=\"composition-example\">\nComposition Example </h2> <p>Let's create a simple Avatar component which shows a Facebook page picture and name using the Facebook Graph API.</p> <pre class=\"highlight\" data-language=\"javascript\">var Avatar = React.createClass({\n  render: function() {\n    return (\n      &lt;div&gt;\n        &lt;PagePic pagename={this.props.pagename} /&gt;\n        &lt;PageLink pagename={this.props.pagename} /&gt;\n      &lt;/div&gt;\n    );\n  }\n});\n\nvar PagePic = React.createClass({\n  render: function() {\n    return (\n      &lt;img src={'https://graph.facebook.com/' + this.props.pagename + '/picture'} /&gt;\n    );\n  }\n});\n\nvar PageLink = React.createClass({\n  render: function() {\n    return (\n      &lt;a href={'https://www.facebook.com/' + this.props.pagename}&gt;\n        {this.props.pagename}\n      &lt;/a&gt;\n    );\n  }\n});\n\nReactDOM.render(\n  &lt;Avatar pagename=\"Engineering\" /&gt;,\n  document.getElementById('example')\n);\n</pre>\n<h2 id=\"ownership\">\nOwnership </h2> <p>In the above example, instances of <code>Avatar</code> <em>own</em> instances of <code>PagePic</code> and <code>PageLink</code>. In React, <strong>an owner is the component that sets the <code>props</code> of other components</strong>. More formally, if a component <code>X</code> is created in component <code>Y</code>'s <code>render()</code> method, it is said that <code>X</code> is <em>owned by</em> <code>Y</code>. As discussed earlier, a component cannot mutate its <code>props</code> â they are always consistent with what its owner sets them to. This fundamental invariant leads to UIs that are guaranteed to be consistent.</p> <p>It's important to draw a distinction between the owner-ownee relationship and the parent-child relationship. The owner-ownee relationship is specific to React, while the parent-child relationship is simply the one you know and love from the DOM. In the example above, <code>Avatar</code> owns the <code>div</code>, <code>PagePic</code> and <code>PageLink</code> instances, and <code>div</code> is the <strong>parent</strong> (but not owner) of the <code>PagePic</code> and <code>PageLink</code> instances.</p> <h2 id=\"children\">\nChildren </h2> <p>When you create a React component instance, you can include additional React components or JavaScript expressions between the opening and closing tags like this:</p> <pre class=\"highlight\" data-language=\"javascript\">&lt;Parent&gt;&lt;Child /&gt;&lt;/Parent&gt;\n</pre> <p><code>Parent</code> can read its children by accessing the special <code>this.props.children</code> prop. <strong><code>this.props.children</code> is an opaque data structure:</strong> use the <a href=\"top-level-api#react.children\">React.Children utilities</a> to manipulate them.</p> <h3 id=\"child-reconciliation\">\nChild Reconciliation </h3> <p><strong>Reconciliation is the process by which React updates the DOM with each new render pass.</strong> In general, children are reconciled according to the order in which they are rendered. For example, suppose two render passes generate the following respective markup:</p> <pre class=\"highlight\" data-language=\"html\">// Render Pass 1\n&lt;Card&gt;\n  &lt;p&gt;Paragraph 1&lt;/p&gt;\n  &lt;p&gt;Paragraph 2&lt;/p&gt;\n&lt;/Card&gt;\n// Render Pass 2\n&lt;Card&gt;\n  &lt;p&gt;Paragraph 2&lt;/p&gt;\n&lt;/Card&gt;\n</pre> <p>Intuitively, <code>&lt;p&gt;Paragraph 1&lt;/p&gt;</code> was removed. Instead, React will reconcile the DOM by changing the text content of the first child and destroying the last child. React reconciles according to the <em>order</em> of the children.</p> <h3 id=\"stateful-children\">\nStateful Children </h3> <p>For most components, this is not a big deal. However, for stateful components that maintain data in <code>this.state</code> across render passes, this can be very problematic.</p> <p>In most cases, this can be sidestepped by hiding elements instead of destroying them:</p> <pre class=\"highlight\" data-language=\"html\">// Render Pass 1\n&lt;Card&gt;\n  &lt;p&gt;Paragraph 1&lt;/p&gt;\n  &lt;p&gt;Paragraph 2&lt;/p&gt;\n&lt;/Card&gt;\n// Render Pass 2\n&lt;Card&gt;\n  &lt;p style={{display: 'none'}}&gt;Paragraph 1&lt;/p&gt;\n  &lt;p&gt;Paragraph 2&lt;/p&gt;\n&lt;/Card&gt;\n</pre>\n<h3 id=\"dynamic-children\">\nDynamic Children </h3> <p>The situation gets more complicated when the children are shuffled around (as in search results) or if new components are added onto the front of the list (as in streams). In these cases where the identity and state of each child must be maintained across render passes, you can uniquely identify each child by assigning it a <code>key</code>:</p> <pre class=\"highlight\" data-language=\"javascript\">  render: function() {\n    var results = this.props.results;\n    return (\n      &lt;ol&gt;\n        {results.map(function(result) {\n          return &lt;li key={result.id}&gt;{result.text}&lt;/li&gt;;\n        })}\n      &lt;/ol&gt;\n    );\n  }\n</pre> <p>When React reconciles the keyed children, it will ensure that any child with <code>key</code> will be reordered (instead of clobbered) or destroyed (instead of reused).</p> <p>The <code>key</code> should <em>always</em> be supplied directly to the components in the array, not to the container HTML child of each component in the array:</p> <pre class=\"highlight\" data-language=\"javascript\">// WRONG!\nvar ListItemWrapper = React.createClass({\n  render: function() {\n    return &lt;li key={this.props.data.id}&gt;{this.props.data.text}&lt;/li&gt;;\n  }\n});\nvar MyComponent = React.createClass({\n  render: function() {\n    return (\n      &lt;ul&gt;\n        {this.props.results.map(function(result) {\n          return &lt;ListItemWrapper data={result}/&gt;;\n        })}\n      &lt;/ul&gt;\n    );\n  }\n});\n</pre>\n<pre class=\"highlight\" data-language=\"javascript\">// Correct :)\nvar ListItemWrapper = React.createClass({\n  render: function() {\n    return &lt;li&gt;{this.props.data.text}&lt;/li&gt;;\n  }\n});\nvar MyComponent = React.createClass({\n  render: function() {\n    return (\n      &lt;ul&gt;\n        {this.props.results.map(function(result) {\n           return &lt;ListItemWrapper key={result.id} data={result}/&gt;;\n        })}\n      &lt;/ul&gt;\n    );\n  }\n});\n</pre> <p>You can also key children by passing a ReactFragment object. See <a href=\"create-fragment\">Keyed Fragments</a> for more details.</p> <h2 id=\"data-flow\">\nData Flow </h2> <p>In React, data flows from owner to owned component through <code>props</code> as discussed above. This is effectively one-way data binding: owners bind their owned component's props to some value the owner has computed based on its <code>props</code> or <code>state</code>. Since this process happens recursively, data changes are automatically reflected everywhere they are used.</p> <h2 id=\"a-note-on-performance\">\nA Note on Performance </h2> <p>You may be thinking that it's expensive to change data if there are a large number of nodes under an owner. The good news is that JavaScript is fast and <code>render()</code> methods tend to be quite simple, so in most applications this is extremely fast. Additionally, the bottleneck is almost always the DOM mutation and not JS execution. React will optimize this for you by using batching and change detection.</p> <p>However, sometimes you really want to have fine-grained control over your performance. In that case, simply override <code>shouldComponentUpdate()</code> to return false when you want React to skip processing of a subtree. See <a href=\"component-specs\">the React reference docs</a> for more information.</p> <blockquote>  <p>If <code>shouldComponentUpdate()</code> returns false when data has actually changed, React can't keep your UI in sync. Be sure you know what you're doing while using it, and only use this function when you have a noticeable performance problem. Don't underestimate how fast JavaScript is relative to the DOM.</p> </blockquote><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/multiple-components.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/multiple-components.html</a>\n  </p>\n</div>\n","docs/update":"<h1> Immutability Helpers </h1>  <p>React lets you use whatever style of data management you want, including mutation. However, if you can use immutable data in performance-critical parts of your application it's easy to implement a fast <code>shouldComponentUpdate()</code> method to significantly speed up your app.</p> <p>Dealing with immutable data in JavaScript is more difficult than in languages designed for it, like <a href=\"http://clojure.org/\">Clojure</a>. However, we've provided a simple immutability helper, <code>update()</code>, that makes dealing with this type of data much easier, <em>without</em> fundamentally changing how your data is represented. You can also take a look at Facebook's <a href=\"https://facebook.github.io/immutable-js/docs/\">Immutable-js</a> and the <a href=\"advanced-performance\">Advanced Performance</a> section for more detail on Immutable-js.</p> <h2 id=\"the-main-idea\">\nThe main idea </h2> <p>If you mutate data like this:</p> <pre class=\"highlight\" data-language=\"js\">myData.x.y.z = 7;\n// or...\nmyData.a.b.push(9);\n</pre> <p>You have no way of determining which data has changed since the previous copy has been overwritten. Instead, you need to create a new copy of <code>myData</code> and change only the parts of it that need to be changed. Then you can compare the old copy of <code>myData</code> with the new one in <code>shouldComponentUpdate()</code> using triple-equals:</p> <pre class=\"highlight\" data-language=\"js\">var newData = deepCopy(myData);\nnewData.x.y.z = 7;\nnewData.a.b.push(9);\n</pre> <p>Unfortunately, deep copies are expensive, and sometimes impossible. You can alleviate this by only copying objects that need to be changed and by reusing the objects that haven't changed. Unfortunately, in today's JavaScript this can be cumbersome:</p> <pre class=\"highlight\" data-language=\"js\">var newData = extend(myData, {\n  x: extend(myData.x, {\n    y: extend(myData.x.y, {z: 7}),\n  }),\n  a: extend(myData.a, {b: myData.a.b.concat(9)})\n});\n</pre> <p>While this is fairly performant (since it only makes a shallow copy of <code>log n</code> objects and reuses the rest), it's a big pain to write. Look at all the repetition! This is not only annoying, but also provides a large surface area for bugs.</p> <p><code>update()</code> provides simple syntactic sugar around this pattern to make writing this code easier. This code becomes:</p> <pre class=\"highlight\" data-language=\"js\">var update = require('react-addons-update');\n\nvar newData = update(myData, {\n  x: {y: {z: {$set: 7}}},\n  a: {b: {$push: [9]}}\n});\n</pre> <p>While the syntax takes a little getting used to (though it's inspired by <a href=\"http://docs.mongodb.org/manual/core/crud-introduction/#query\">MongoDB's query language</a>) there's no redundancy, it's statically analyzable and it's not much more typing than the mutative version.</p> <p>The <code>$</code>-prefixed keys are called <em>commands</em>. The data structure they are \"mutating\" is called the <em>target</em>.</p> <h2 id=\"available-commands\">\nAvailable commands </h2> <ul> <li>\n<code>{$push: array}</code> <code>push()</code> all the items in <code>array</code> on the target.</li> <li>\n<code>{$unshift: array}</code> <code>unshift()</code> all the items in <code>array</code> on the target.</li> <li>\n<code>{$splice: array of arrays}</code> for each item in <code>arrays</code> call <code>splice()</code> on the target with the parameters provided by the item.</li> <li>\n<code>{$set: any}</code> replace the target entirely.</li> <li>\n<code>{$merge: object}</code> merge the keys of <code>object</code> with the target.</li> <li>\n<code>{$apply: function}</code> passes in the current value to the function and updates it with the new returned value.</li> </ul> <h2 id=\"examples\">\nExamples </h2>\n<h3 id=\"simple-push\">\nSimple push </h3>\n<pre class=\"highlight\" data-language=\"js\">var initialArray = [1, 2, 3];\nvar newArray = update(initialArray, {$push: [4]}); // =&gt; [1, 2, 3, 4]\n</pre> <p><code>initialArray</code> is still <code>[1, 2, 3]</code>.</p> <h3 id=\"nested-collections\">\nNested collections </h3>\n<pre class=\"highlight\" data-language=\"js\">var collection = [1, 2, {a: [12, 17, 15]}];\nvar newCollection = update(collection, {2: {a: {$splice: [[1, 1, 13, 14]]}}});\n// =&gt; [1, 2, {a: [12, 13, 14, 15]}]\n</pre> <p>This accesses <code>collection</code>'s index <code>2</code>, key <code>a</code>, and does a splice of one item starting from index <code>1</code> (to remove <code>17</code>) while inserting <code>13</code> and <code>14</code>.</p> <h3 id=\"updating-a-value-based-on-its-current-one\">\nUpdating a value based on its current one </h3>\n<pre class=\"highlight\" data-language=\"js\">var obj = {a: 5, b: 3};\nvar newObj = update(obj, {b: {$apply: function(x) {return x * 2;}}});\n// =&gt; {a: 5, b: 6}\n// This is equivalent, but gets verbose for deeply nested collections:\nvar newObj2 = update(obj, {b: {$set: obj.b * 2}});\n</pre>\n<h3 id=\"shallow-merge\">\n(Shallow) merge </h3>\n<pre class=\"highlight\" data-language=\"js\">var obj = {a: 5, b: 3};\nvar newObj = update(obj, {$merge: {b: 6, c: 7}}); // =&gt; {a: 5, b: 6, c: 7}\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/update.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/update.html</a>\n  </p>\n</div>\n","tips/children-props-type":"<h1>Type of the Children props</h1>  <p>Usually, a component's children (<code>this.props.children</code>) is an array of components:</p> <pre class=\"highlight\" data-language=\"js\">var GenericWrapper = React.createClass({\n  componentDidMount: function() {\n    console.log(Array.isArray(this.props.children)); // =&gt; true\n  },\n\n  render: function() {\n    return &lt;div /&gt;;\n  }\n});\n\nReactDOM.render(\n  &lt;GenericWrapper&gt;&lt;span/&gt;&lt;span/&gt;&lt;span/&gt;&lt;/GenericWrapper&gt;,\n  mountNode\n);\n</pre> <p>However, when there is only a single child, <code>this.props.children</code> will be the single child component itself <em>without the array wrapper</em>. This saves an array allocation.</p> <pre class=\"highlight\" data-language=\"js\">var GenericWrapper = React.createClass({\n  componentDidMount: function() {\n    console.log(Array.isArray(this.props.children)); // =&gt; false\n\n    // warning: yields 5 for length of the string 'hello', not 1 for the\n    // length of the non-existent array wrapper!\n    console.log(this.props.children.length);\n  },\n\n  render: function() {\n    return &lt;div /&gt;;\n  }\n});\n\nReactDOM.render(&lt;GenericWrapper&gt;hello&lt;/GenericWrapper&gt;, mountNode);\n</pre> <p>To make <code>this.props.children</code> easy to deal with, we've provided the <a href=\"../docs/top-level-api#react.children\">React.Children utilities</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/tips/children-props-type.html\" class=\"_attribution-link\">https://facebook.github.io/react/tips/children-props-type.html</a>\n  </p>\n</div>\n","tips/false-in-jsx":"<h1>False in JSX</h1>  <p>Here's how <code>false</code> renders in different situations:</p> <p>Renders as <code>id=\"false\"</code>:</p> <pre class=\"highlight\" data-language=\"js\">ReactDOM.render(&lt;div id={false} /&gt;, mountNode);\n</pre> <p>String <code>\"false\"</code> as input value:</p> <pre class=\"highlight\" data-language=\"js\">ReactDOM.render(&lt;input value={false} /&gt;, mountNode);\n</pre> <p>No child:</p> <pre class=\"highlight\" data-language=\"js\">ReactDOM.render(&lt;div&gt;{false}&lt;/div&gt;, mountNode);\n</pre> <p>The reason why this one doesn't render as the string <code>\"false\"</code> as a <code>div</code> child is to allow the more common use-case: <code>&lt;div&gt;{x &gt; 1 &amp;&amp; 'You have more than one item'}&lt;/div&gt;</code>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/tips/false-in-jsx.html\" class=\"_attribution-link\">https://facebook.github.io/react/tips/false-in-jsx.html</a>\n  </p>\n</div>\n","docs/special-non-dom-attributes":"<h1> Special Non-DOM Attributes </h1>  <p>Beside <a href=\"dom-differences\">DOM differences</a>, React offers some attributes that simply don't exist in DOM.</p> <ul> <li>\n<code>key</code>: an optional, unique identifier. When your component shuffles around during <code>render</code> passes, it might be destroyed and recreated due to the diff algorithm. Assigning it a key that persists makes sure the component stays. See more <a href=\"multiple-components#dynamic-children\">here</a>.</li> <li>\n<code>ref</code>: see <a href=\"more-about-refs\">here</a>.</li> <li>\n<code>dangerouslySetInnerHTML</code>: Provides the ability to insert raw HTML, mainly for cooperating with DOM string manipulation libraries. See more <a href=\"../tips/dangerously-set-inner-html\">here</a>.</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/special-non-dom-attributes.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/special-non-dom-attributes.html</a>\n  </p>\n</div>\n","tips/maximum-number-of-jsx-root-nodes":"<h1>Maximum Number of JSX Root Nodes</h1>  <p>Currently, in a component's <code>render</code>, you can only return one node; if you have, say, a list of <code>div</code>s to return, you must wrap your components within a <code>div</code>, <code>span</code> or any other component.</p> <p>Don't forget that JSX compiles into regular JS; returning two functions doesn't really make syntactic sense. Likewise, don't put more than one child in a ternary.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/tips/maximum-number-of-jsx-root-nodes.html\" class=\"_attribution-link\">https://facebook.github.io/react/tips/maximum-number-of-jsx-root-nodes.html</a>\n  </p>\n</div>\n","tips/inline-styles":"<h1>Inline Styles</h1>  <p>In React, inline styles are not specified as a string. Instead they are specified with an object whose key is the camelCased version of the style name, and whose value is the style's value, usually a string (<a href=\"style-props-value-px\">more on that later</a>):</p> <pre class=\"highlight\" data-language=\"js\">var divStyle = {\n  color: 'white',\n  backgroundImage: 'url(' + imgUrl + ')',\n  WebkitTransition: 'all', // note the capital 'W' here\n  msTransition: 'all' // 'ms' is the only lowercase vendor prefix\n};\n\nReactDOM.render(&lt;div style={divStyle}&gt;Hello World!&lt;/div&gt;, mountNode);\n</pre> <p>Style keys are camelCased in order to be consistent with accessing the properties on DOM nodes from JS (e.g. <code>node.style.backgroundImage</code>). Vendor prefixes <a href=\"http://www.andismith.com/blog/2012/02/modernizr-prefixed/\">other than <code>ms</code></a> should begin with a capital letter. This is why <code>WebkitTransition</code> has an uppercase \"W\".</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/tips/inline-styles.html\" class=\"_attribution-link\">https://facebook.github.io/react/tips/inline-styles.html</a>\n  </p>\n</div>\n","docs/webcomponents":"<h1> Web Components </h1>  <p>Trying to compare and contrast React with WebComponents inevitably results in specious conclusions, because the two libraries are built to solve different problems. WebComponents provide strong encapsulation for reusable components, while React provides a declarative library that keeps the DOM in sync with your data. The two goals are complementary; engineers can mix-and-match the technologies. As a developer, you are free to use React in your WebComponents, or to use WebComponents in React, or both.</p> <h2 id=\"using-web-components-in-react\">\nUsing Web Components in React </h2>\n<pre class=\"highlight\" data-language=\"javascript\">class HelloMessage extends React.Component{\n  render() {\n    return &lt;div&gt;Hello &lt;x-search&gt;{this.props.name}&lt;/x-search&gt;!&lt;/div&gt;;\n  }\n}\n</pre> <blockquote>  <p>The programming models of the two component systems (web components vs. react components) differ in that web components often expose an imperative API (for instance, a <code>video</code> web component might expose <code>play()</code> and <code>pause()</code> functions). To the extent that web components are declarative functions of their attributes, they should work, but to access the imperative APIs of a web component, you will need to attach a ref to the component and interact with the DOM node directly. If you are using third-party web components, the recommended solution is to write a React component that behaves as a wrapper for your web component.</p> <p>At this time, events emitted by a web component may not properly propagate through a React render tree. You will need to manually attach event handlers to handle these events within your React components.</p> </blockquote> <h2 id=\"using-react-in-your-web-components\">\nUsing React in your Web Components </h2>\n<pre class=\"highlight\" data-language=\"javascript\">var proto = Object.create(HTMLElement.prototype, {\n  attachedCallback: {\n    value: function() {\n      var mountPoint = document.createElement('span');\n      this.createShadowRoot().appendChild(mountPoint);\n\n      var name = this.getAttribute('name');\n      var url = 'https://www.google.com/search?q=' + encodeURIComponent(name);\n      ReactDOM.render(&lt;a href={url}&gt;{name}&lt;/a&gt;, mountPoint);\n    }\n  }\n});\ndocument.registerElement('x-search', {prototype: proto});\n</pre>\n<h2 id=\"complete-example\">\nComplete Example </h2> <p>Check out the <code>webcomponents</code> example in the <a href=\"https://facebook.github.io/react/downloads.html\">starter kit</a> for a complete example.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/webcomponents.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/webcomponents.html</a>\n  </p>\n</div>\n","tips/componentwillreceiveprops-not-triggered-after-mounting":"<h1>componentWillReceiveProps Not Triggered After Mounting</h1>  <p><code>componentWillReceiveProps</code> isn't triggered after the node is put on scene. This is by design. Check out <a href=\"../docs/component-specs\">other lifecycle methods</a> for the one that suits your needs.</p> <p>The reason for that is because <code>componentWillReceiveProps</code> often handles the logic of comparing with the old props and acting upon changes; not triggering it at mounting (where there are no old props) helps in defining what the method does.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/tips/componentWillReceiveProps-not-triggered-after-mounting.html\" class=\"_attribution-link\">https://facebook.github.io/react/tips/componentWillReceiveProps-not-triggered-after-mounting.html</a>\n  </p>\n</div>\n","tips/if-else-in-jsx":"<h1>If-Else in JSX</h1>  <p><code>if-else</code> statements don't work inside JSX. This is because JSX is just syntactic sugar for function calls and object construction. Take this basic example:</p> <pre class=\"highlight\" data-language=\"js\">// This JSX:\nReactDOM.render(&lt;div id=\"msg\"&gt;Hello World!&lt;/div&gt;, mountNode);\n\n// Is transformed to this JS:\nReactDOM.render(React.createElement(\"div\", {id:\"msg\"}, \"Hello World!\"), mountNode);\n</pre> <p>This means that <code>if</code> statements don't fit in. Take this example:</p> <pre class=\"highlight\" data-language=\"js\">// This JSX:\n&lt;div id={if (condition) { 'msg' }}&gt;Hello World!&lt;/div&gt;\n\n// Is transformed to this JS:\nReact.createElement(\"div\", {id: if (condition) { 'msg' }}, \"Hello World!\");\n</pre> <p>That's not valid JS. You probably want to make use of a ternary expression:</p> <pre class=\"highlight\" data-language=\"js\">ReactDOM.render(&lt;div id={condition ? 'msg' : null}&gt;Hello World!&lt;/div&gt;, mountNode);\n</pre> <p>If a ternary expression isn't robust enough, you can use <code>if</code> statements outside of your JSX to determine which components should be used:</p> <pre class=\"highlight\" data-language=\"js\">var loginButton;\nif (loggedIn) {\n  loginButton = &lt;LogoutButton /&gt;;\n} else {\n  loginButton = &lt;LoginButton /&gt;;\n}\n\nreturn (\n  &lt;nav&gt;\n    &lt;Home /&gt;\n    {loginButton}\n  &lt;/nav&gt;\n);\n</pre> <p>Or if you prefer a more \"inline\" aesthetic, define <a href=\"https://en.wikipedia.org/wiki/Immediately-invoked_function_expression\">immediately-invoked function expressions</a> <em>inside</em> your JSX:</p> <pre class=\"highlight\" data-language=\"js\">return (\n  &lt;section&gt;\n    &lt;h1&gt;Color&lt;/h1&gt;\n    &lt;h3&gt;Name&lt;/h3&gt;\n    &lt;p&gt;{this.state.color || \"white\"}&lt;/p&gt;\n    &lt;h3&gt;Hex&lt;/h3&gt;\n    &lt;p&gt;\n      {(() =&gt; {\n        switch (this.state.color) {\n          case \"red\":   return \"#FF0000\";\n          case \"green\": return \"#00FF00\";\n          case \"blue\":  return \"#0000FF\";\n          default:      return \"#FFFFFF\";\n        }\n      })()}\n    &lt;/p&gt;\n  &lt;/section&gt;\n);\n</pre> <blockquote>  <p>In the example above, an ES6 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">arrow function</a> is utilized to lexically bind the value of <code>this</code>.</p> </blockquote> <p>Try using it today with the <a href=\"https://babeljs.io/repl/\">Babel REPL</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/tips/if-else-in-JSX.html\" class=\"_attribution-link\">https://facebook.github.io/react/tips/if-else-in-JSX.html</a>\n  </p>\n</div>\n","tips/controlled-input-null-value":"<h1>Value of null for Controlled Input</h1>  <p>Specifying the <code>value</code> prop on a <a href=\"../docs/forms\">controlled component</a> prevents the user from changing the input unless you desire so.</p> <p>You might have run into a problem where <code>value</code> is specified, but the input can still be changed without consent. In this case, you might have accidentally set <code>value</code> to <code>undefined</code> or <code>null</code>.</p> <p>The snippet below shows this phenomenon; after a second, the text becomes editable.</p> <pre class=\"highlight\" data-language=\"js\">ReactDOM.render(&lt;input value=\"hi\" /&gt;, mountNode);\n\nsetTimeout(function() {\n  ReactDOM.render(&lt;input value={null} /&gt;, mountNode);\n}, 1000);\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/tips/controlled-input-null-value.html\" class=\"_attribution-link\">https://facebook.github.io/react/tips/controlled-input-null-value.html</a>\n  </p>\n</div>\n","docs/context":"<h1> Context </h1>  <p>One of React's biggest strengths is that it's easy to track the flow of data through your React components. When you look at a component, you can easily see exactly which props are being passed in which makes your apps easy to reason about.</p> <p>Occasionally, you want to pass data through the component tree without having to pass the props down manually at every level. React's \"context\" feature lets you do this.</p> <blockquote>  <p>Context is an advanced and experimental feature. The API is likely to change in future releases.</p> <p>Most applications will never need to use context. Especially if you are just getting started with React, you likely do not want to use context. Using context will make your code harder to understand because it makes the data flow less clear. It is similar to using global variables to pass state through your application.</p> <p><strong>If you have to use context, use it sparingly.</strong></p> <p>Regardless of whether you're building an application or a library, try to isolate your use of context to a small area and avoid using the context API directly when possible so that it's easier to upgrade when the API changes.</p> </blockquote> <h2 id=\"passing-info-automatically-through-a-tree\">\nPassing info automatically through a tree </h2> <p>Suppose you have a structure like:</p> <pre class=\"highlight\" data-language=\"javascript\">class Button extends React.Component {\n  render() {\n    return (\n      &lt;button style={{background: this.props.color}}&gt;\n        {this.props.children}\n      &lt;/button&gt;\n    );\n  }\n}\n\nclass Message extends React.Component {\n  render() {\n    return (\n      &lt;div&gt;\n        {this.props.text} &lt;Button color={this.props.color}&gt;Delete&lt;/Button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nclass MessageList extends React.Component {\n  render() {\n    const color = \"purple\";\n    const children = this.props.messages.map((message) =&gt;\n      &lt;Message text={message.text} color={color} /&gt;\n    );\n    return &lt;div&gt;{children}&lt;/div&gt;;\n  }\n}\n</pre> <p>In this example, we manually thread through a <code>color</code> prop in order to style the <code>Button</code> and <code>Message</code> components appropriately. Theming is a good example of when you might want an entire subtree to have access to some piece of information (a color). Using context, we can pass this through the tree automatically:</p> <pre class=\"highlight\" data-language=\"javascript\">class Button extends React.Component {\n  render() {\n    return (\n      &lt;button style={{background: this.context.color}}&gt;\n        {this.props.children}\n      &lt;/button&gt;\n    );\n  }\n}\n\nButton.contextTypes = {\n  color: React.PropTypes.string\n};\n\nclass Message extends React.Component {\n  render() {\n    return (\n      &lt;div&gt;\n        {this.props.text} &lt;Button&gt;Delete&lt;/Button&gt;\n      &lt;/div&gt;\n    );\n  }\n}\n\nclass MessageList extends React.Component {\n  getChildContext() {\n    return {color: \"purple\"};\n  }\n\n  render() {\n    const children = this.props.messages.map((message) =&gt;\n      &lt;Message text={message.text} /&gt;\n    );\n    return &lt;div&gt;{children}&lt;/div&gt;;\n  }\n}\n\nMessageList.childContextTypes = {\n  color: React.PropTypes.string\n};\n</pre> <p>By adding <code>childContextTypes</code> and <code>getChildContext</code> to <code>MessageList</code> (the context provider), React passes the information down automatically and any component in the subtree (in this case, <code>Button</code>) can access it by defining <code>contextTypes</code>.</p> <p>If <code>contextTypes</code> is not defined, then <code>context</code> will be an empty object.</p> <h2 id=\"parent-child-coupling\">\nParent-child coupling </h2> <p>Context can also let you build an API such as:</p> <pre class=\"highlight\" data-language=\"javascript\">&lt;Menu&gt;\n  &lt;MenuItem&gt;aubergine&lt;/MenuItem&gt;\n  &lt;MenuItem&gt;butternut squash&lt;/MenuItem&gt;\n  &lt;MenuItem&gt;clementine&lt;/MenuItem&gt;\n&lt;/Menu&gt;\n</pre> <p>By passing down the relevant info in the <code>Menu</code> component, each <code>MenuItem</code> can communicate back to the containing <code>Menu</code> component.</p> <p><strong>Before you build components with this API, consider if there are cleaner alternatives.</strong> We're fond of simply passing the items as an array in cases like this:</p> <pre class=\"highlight\" data-language=\"javascript\">&lt;Menu items={['aubergine', 'butternut squash', 'clementine']} /&gt;\n</pre> <p>Recall that you can also pass entire React components in props if you'd like to.</p> <h2 id=\"referencing-context-in-lifecycle-methods\">\nReferencing context in lifecycle methods </h2> <p>If <code>contextTypes</code> is defined within a component, the following lifecycle methods will receive an additional parameter, the <code>context</code> object:</p> <pre class=\"highlight\" data-language=\"javascript\">void componentWillReceiveProps(\n  object nextProps, object nextContext\n)\n\nboolean shouldComponentUpdate(\n  object nextProps, object nextState, object nextContext\n)\n\nvoid componentWillUpdate(\n  object nextProps, object nextState, object nextContext\n)\n\nvoid componentDidUpdate(\n  object prevProps, object prevState, object prevContext\n)\n</pre>\n<h2 id=\"referencing-context-in-stateless-functional-components\">\nReferencing context in stateless functional components </h2> <p>Stateless functional components are also able to reference <code>context</code> if <code>contextTypes</code> is defined as a property of the function. The following code shows the <code>Button</code> component above written as a stateless functional component.</p> <pre class=\"highlight\" data-language=\"javascript\">const Button = ({children}, context) =&gt;\n  &lt;button style={{background: context.color}}&gt;\n    {children}\n  &lt;/button&gt;;\n\nButton.contextTypes = {color: React.PropTypes.string};\n</pre>\n<h2 id=\"updating-context\">\nUpdating context </h2> <p>The <code>getChildContext</code> function will be called when the state or props changes. In order to update data in the context, trigger a local state update with <code>this.setState</code>. This will trigger a new context and changes will be received by the children.</p> <pre class=\"highlight\" data-language=\"javascript\">class MediaQuery extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {type:'desktop'};\n  }\n\n  getChildContext() {\n    return {type: this.state.type};\n  }\n\n  componentDidMount() {\n    const checkMediaQuery = () =&gt; {\n      const type = window.matchMedia(\"(min-width: 1025px)\").matches ? 'desktop' : 'mobile';\n      if (type !== this.state.type) {\n        this.setState({type});\n      }\n    };\n\n    window.addEventListener('resize', checkMediaQuery);\n    checkMediaQuery();\n  }\n\n  render() {\n    return this.props.children;\n  }\n}\n\nMediaQuery.childContextTypes = {\n  type: React.PropTypes.string\n};\n</pre>\n<h2 id=\"when-not-to-use-context\">\nWhen not to use context </h2> <p>Just as global variables are best avoided when writing clear code, you should avoid using context in most cases. In particular, think twice before using it to \"save typing\" and using it instead of passing explicit props.</p> <p>The best use cases for context are for implicitly passing down the logged-in user, the current language, or theme information. All of these might otherwise be true globals, but context lets you scope them to a single React subtree.</p> <p>Do not use context to pass your model data through components. Threading your data through the tree explicitly is much easier to understand. Using context makes your components more coupled and less reusable, because they behave differently depending on where they're rendered.</p> <h2 id=\"known-limitations\">\nKnown limitations </h2> <p>If a context value provided by a component changes, descendants that use that value won't update if an intermediate parent returns <code>false</code> from <code>shouldComponentUpdate</code>. See issue <a href=\"https://github.com/facebook/react/issues/2517\">#2517</a> for more details.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/context.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/context.html</a>\n  </p>\n</div>\n","docs/events":"<h1> Event System </h1>  <h2 id=\"syntheticevent\">\nSyntheticEvent </h2> <p>Your event handlers will be passed instances of <code>SyntheticEvent</code>, a cross-browser wrapper around the browser's native event. It has the same interface as the browser's native event, including <code>stopPropagation()</code> and <code>preventDefault()</code>, except the events work identically across all browsers.</p> <p>If you find that you need the underlying browser event for some reason, simply use the <code>nativeEvent</code> attribute to get it. Every <code>SyntheticEvent</code> object has the following attributes:</p> <pre class=\"highlight\" data-language=\"javascript\">boolean bubbles\nboolean cancelable\nDOMEventTarget currentTarget\nboolean defaultPrevented\nnumber eventPhase\nboolean isTrusted\nDOMEvent nativeEvent\nvoid preventDefault()\nboolean isDefaultPrevented()\nvoid stopPropagation()\nboolean isPropagationStopped()\nDOMEventTarget target\nnumber timeStamp\nstring type\n</pre> <blockquote>  <p>As of v0.14, returning <code>false</code> from an event handler will no longer stop event propagation. Instead, <code>e.stopPropagation()</code> or <code>e.preventDefault()</code> should be triggered manually, as appropriate.</p> </blockquote> <h2 id=\"event-pooling\">\nEvent pooling </h2> <p>The <code>SyntheticEvent</code> is pooled. This means that the <code>SyntheticEvent</code> object will be reused and all properties will be nullified after the event callback has been invoked. This is for performance reasons. As such, you cannot access the event in an asynchronous way.</p> <pre class=\"highlight\" data-language=\"javascript\">function onClick(event) {\n  console.log(event); // =&gt; nullified object.\n  console.log(event.type); // =&gt; \"click\"\n  var eventType = event.type; // =&gt; \"click\"\n\n  setTimeout(function() {\n    console.log(event.type); // =&gt; null\n    console.log(eventType); // =&gt; \"click\"\n  }, 0);\n\n  this.setState({clickEvent: event}); // Won't work. this.state.clickEvent will only contain null values.\n  this.setState({eventType: event.type}); // You can still export event properties.\n}\n</pre> <blockquote>  <p>If you want to access the event properties in an asynchronous way, you should call <code>event.persist()</code> on the event, which will remove the synthetic event from the pool and allow references to the event to be retained by user code.</p> </blockquote> <h2 id=\"supported-events\">\nSupported Events </h2> <p>React normalizes events so that they have consistent properties across different browsers.</p> <p>The event handlers below are triggered by an event in the bubbling phase. To register an event handler for the capture phase, append <code>Capture</code> to the event name; for example, instead of using <code>onClick</code>, you would use <code>onClickCapture</code> to handle the click event in the capture phase.</p> <h3 id=\"clipboard-events\">\nClipboard Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onCopy onCut onPaste\n</pre> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">DOMDataTransfer clipboardData\n</pre>\n<h3 id=\"composition-events\">\nComposition Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onCompositionEnd onCompositionStart onCompositionUpdate\n</pre> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">string data\n</pre>\n<h3 id=\"keyboard-events\">\nKeyboard Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onKeyDown onKeyPress onKeyUp\n</pre> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">boolean altKey\nnumber charCode\nboolean ctrlKey\nboolean getModifierState(key)\nstring key\nnumber keyCode\nstring locale\nnumber location\nboolean metaKey\nboolean repeat\nboolean shiftKey\nnumber which\n</pre>\n<h3 id=\"focus-events\">\nFocus Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onFocus onBlur\n</pre> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">DOMEventTarget relatedTarget\n</pre> <p>These focus events work on all elements in the React DOM, not just form elements.</p> <h3 id=\"form-events\">\nForm Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onChange onInput onSubmit\n</pre> <p>For more information about the onChange event, see <a href=\"forms\">Forms</a>.</p> <h3 id=\"mouse-events\">\nMouse Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onClick onContextMenu onDoubleClick onDrag onDragEnd onDragEnter onDragExit\nonDragLeave onDragOver onDragStart onDrop onMouseDown onMouseEnter onMouseLeave\nonMouseMove onMouseOut onMouseOver onMouseUp\n</pre> <p>The <code>onMouseEnter</code> and <code>onMouseLeave</code> events propagate from the element being left to the one being entered instead of ordinary bubbling and do not have a capture phase.</p> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">boolean altKey\nnumber button\nnumber buttons\nnumber clientX\nnumber clientY\nboolean ctrlKey\nboolean getModifierState(key)\nboolean metaKey\nnumber pageX\nnumber pageY\nDOMEventTarget relatedTarget\nnumber screenX\nnumber screenY\nboolean shiftKey\n</pre>\n<h3 id=\"selection-events\">\nSelection Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onSelect\n</pre>\n<h3 id=\"touch-events\">\nTouch Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onTouchCancel onTouchEnd onTouchMove onTouchStart\n</pre> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">boolean altKey\nDOMTouchList changedTouches\nboolean ctrlKey\nboolean getModifierState(key)\nboolean metaKey\nboolean shiftKey\nDOMTouchList targetTouches\nDOMTouchList touches\n</pre>\n<h3 id=\"ui-events\">\nUI Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onScroll\n</pre> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">number detail\nDOMAbstractView view\n</pre>\n<h3 id=\"wheel-events\">\nWheel Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onWheel\n</pre> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">number deltaMode\nnumber deltaX\nnumber deltaY\nnumber deltaZ\n</pre>\n<h3 id=\"media-events\">\nMedia Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onAbort onCanPlay onCanPlayThrough onDurationChange onEmptied onEncrypted \nonEnded onError onLoadedData onLoadedMetadata onLoadStart onPause onPlay \nonPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend \nonTimeUpdate onVolumeChange onWaiting\n</pre>\n<h3 id=\"image-events\">\nImage Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onLoad onError\n</pre>\n<h3 id=\"animation-events\">\nAnimation Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onAnimationStart onAnimationEnd onAnimationIteration\n</pre> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">string animationName\nstring pseudoElement\nfloat elapsedTime\n</pre>\n<h3 id=\"transition-events\">\nTransition Events </h3> <p>Event names:</p> <pre class=\"highlight\" data-language=\"text\">onTransitionEnd\n</pre> <p>Properties:</p> <pre class=\"highlight\" data-language=\"javascript\">string propertyName\nstring pseudoElement\nfloat elapsedTime\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/events.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/events.html</a>\n  </p>\n</div>\n","docs/reconciliation":"<h1> Reconciliation </h1>  <p>React's key design decision is to make the API seem like it re-renders the whole app on every update. This makes writing applications a lot easier but is also an incredible challenge to make it tractable. This article explains how with powerful heuristics we managed to turn a O(n<sup>3</sup>) problem into a O(n) one.</p> <h2 id=\"motivation\">\nMotivation </h2> <p>Generating the minimum number of operations to transform one tree into another is a complex and well-studied problem. The <a href=\"http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf\">state of the art algorithms</a> have a complexity in the order of O(n<sup>3</sup>) where n is the number of nodes in the tree.</p> <p>This means that displaying 1000 nodes would require in the order of one billion comparisons. This is far too expensive for our use case. To put this number in perspective, CPUs nowadays execute roughly 3 billion instructions per second. So even with the most performant implementation, we wouldn't be able to compute that diff in less than a second.</p> <p>Since an optimal algorithm is not tractable, we implement a non-optimal O(n) algorithm using heuristics based on two assumptions:</p> <ol> <li>Two components of the same class will generate similar trees and two components of different classes will generate different trees.</li> <li>It is possible to provide a unique key for elements that is stable across different renders.</li> </ol> <p>In practice, these assumptions are ridiculously fast for almost all practical use cases.</p> <h2 id=\"pair-wise-diff\">\nPair-wise diff </h2> <p>In order to do a tree diff, we first need to be able to diff two nodes. There are three different cases being handled.</p> <h3 id=\"different-node-types\">\nDifferent Node Types </h3> <p>If the node type is different, React is going to treat them as two different sub-trees, throw away the first one and build/insert the second one.</p> <pre class=\"highlight\" data-language=\"xml\">renderA: &lt;div /&gt;\nrenderB: &lt;span /&gt;\n=&gt; [removeNode &lt;div /&gt;], [insertNode &lt;span /&gt;]\n</pre> <p>The same logic is used for custom components. If they are not of the same type, React is not going to even try at matching what they render. It is just going to remove the first one from the DOM and insert the second one.</p> <pre class=\"highlight\" data-language=\"xml\">renderA: &lt;Header /&gt;\nrenderB: &lt;Content /&gt;\n=&gt; [removeNode &lt;Header /&gt;], [insertNode &lt;Content /&gt;]\n</pre> <p>Having this high level knowledge is a very important aspect of why React's diff algorithm is both fast and precise. It provides a good heuristic to quickly prune big parts of the tree and focus on parts likely to be similar.</p> <p>It is very unlikely that a <code>&lt;Header&gt;</code> element is going to generate a DOM that is going to look like what a <code>&lt;Content&gt;</code> would generate. Instead of spending time trying to match those two structures, React just re-builds the tree from scratch.</p> <p>As a corollary, if there is a <code>&lt;Header&gt;</code> element at the same position in two consecutive renders, you would expect to see a very similar structure and it is worth exploring it.</p> <h3 id=\"dom-nodes\">\nDOM Nodes </h3> <p>When comparing two DOM nodes, we look at the attributes of both and can decide which of them changed in linear time.</p> <pre class=\"highlight\" data-language=\"xml\">renderA: &lt;div id=\"before\" /&gt;\nrenderB: &lt;div id=\"after\" /&gt;\n=&gt; [replaceAttribute id \"after\"]\n</pre> <p>Instead of treating style as an opaque string, a key-value object is used instead. This lets us update only the properties that changed.</p> <pre class=\"highlight\" data-language=\"xml\">renderA: &lt;div style={{color: 'red'}} /&gt;\nrenderB: &lt;div style={{fontWeight: 'bold'}} /&gt;\n=&gt; [removeStyle color], [addStyle font-weight 'bold']\n</pre> <p>After the attributes have been updated, we recurse on all the children.</p> <h3 id=\"custom-components\">\nCustom Components </h3> <p>We decided that the two custom components are the same. Since components are stateful, we cannot just use the new component and call it a day. React takes all the attributes from the new component and calls <code>componentWillReceiveProps()</code> and <code>componentWillUpdate()</code> on the previous one.</p> <p>The previous component is now operational. Its <code>render()</code> method is called and the diff algorithm restarts with the new result and the previous result.</p> <h2 id=\"list-wise-diff\">\nList-wise diff </h2>\n<h3 id=\"problematic-case\">\nProblematic Case </h3> <p>In order to do children reconciliation, React adopts a very naive approach. It goes over both lists of children at the same time and generates a mutation whenever there's a difference.</p> <p>For example if you add an element at the end:</p> <pre class=\"highlight\" data-language=\"xml\">renderA: &lt;div&gt;&lt;span&gt;first&lt;/span&gt;&lt;/div&gt;\nrenderB: &lt;div&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;second&lt;/span&gt;&lt;/div&gt;\n=&gt; [insertNode &lt;span&gt;second&lt;/span&gt;]\n</pre> <p>Inserting an element at the beginning is problematic. React is going to see that both nodes are spans and therefore run into a mutation mode.</p> <pre class=\"highlight\" data-language=\"xml\">renderA: &lt;div&gt;&lt;span&gt;first&lt;/span&gt;&lt;/div&gt;\nrenderB: &lt;div&gt;&lt;span&gt;second&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;/div&gt;\n=&gt; [replaceAttribute textContent 'second'], [insertNode &lt;span&gt;first&lt;/span&gt;]\n</pre> <p>There are many algorithms that attempt to find the minimum sets of operations to transform a list of elements. <a href=\"https://en.wikipedia.org/wiki/Levenshtein_distance\">Levenshtein distance</a> can find the minimum using single element insertion, deletion and substitution in O(n<sup>2</sup>). Even if we were to use Levenshtein, this doesn't find when a node has moved into another position and algorithms to do that have much worse complexity.</p> <h3 id=\"keys\">\nKeys </h3> <p>In order to solve this seemingly intractable issue, an optional attribute has been introduced. You can provide for each child a key that is going to be used to do the matching. If you specify a key, React is now able to find insertion, deletion, substitution and moves in O(n) using a hash table.</p> <pre class=\"highlight\" data-language=\"xml\">renderA: &lt;div&gt;&lt;span key=\"first\"&gt;first&lt;/span&gt;&lt;/div&gt;\nrenderB: &lt;div&gt;&lt;span key=\"second\"&gt;second&lt;/span&gt;&lt;span key=\"first\"&gt;first&lt;/span&gt;&lt;/div&gt;\n=&gt; [insertNode &lt;span&gt;second&lt;/span&gt;]\n</pre> <p>In practice, finding a key is not really hard. Most of the time, the element you are going to display already has a unique id. When that's not the case, you can add a new ID property to your model or hash some parts of the content to generate a key. Remember that the key only has to be unique among its siblings, not globally unique.</p> <h2 id=\"trade-offs\">\nTrade-offs </h2> <p>It is important to remember that the reconciliation algorithm is an implementation detail. React could re-render the whole app on every action; the end result would be the same. We are regularly refining the heuristics in order to make common use cases faster.</p> <p>In the current implementation, you can express the fact that a sub-tree has been moved amongst its siblings, but you cannot tell that it has moved somewhere else. The algorithm will re-render that full sub-tree.</p> <p>Because we rely on two heuristics, if the assumptions behind them are not met, performance will suffer.</p> <ol> <li><p>The algorithm will not try to match sub-trees of different components classes. If you see yourself alternating between two components classes with very similar output, you may want to make it the same class. In practice, we haven't found this to be an issue.</p></li> <li><p>Keys should be stable, predictable, and unique. Unstable keys (like those produced by Math.random()) will cause many nodes to be unnecessarily re-created, which can cause performance degradation and lost state in child components.</p></li> </ol><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/reconciliation.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/reconciliation.html</a>\n  </p>\n</div>\n","tips/dom-event-listeners":"<h1>DOM Event Listeners in a Component</h1>  <blockquote>  <p>This entry shows how to attach DOM events not provided by React (<a href=\"../docs/events\">check here for more info</a>). This is good for integrations with other libraries such as jQuery.</p> </blockquote> <p>Try to resize the window:</p> <pre class=\"highlight\" data-language=\"js\">var Box = React.createClass({\n  getInitialState: function() {\n    return {windowWidth: window.innerWidth};\n  },\n\n  handleResize: function(e) {\n    this.setState({windowWidth: window.innerWidth});\n  },\n\n  componentDidMount: function() {\n    window.addEventListener('resize', this.handleResize);\n  },\n\n  componentWillUnmount: function() {\n    window.removeEventListener('resize', this.handleResize);\n  },\n\n  render: function() {\n    return &lt;div&gt;Current window width: {this.state.windowWidth}&lt;/div&gt;;\n  }\n});\n\nReactDOM.render(&lt;Box /&gt;, mountNode);\n</pre> <p><code>componentDidMount</code> is called after the component is mounted and has a DOM representation. This is often a place where you would attach generic DOM events.</p> <p>Notice that the event callback is bound to the react component and not the original element. React automatically binds methods to the current component instance for you through a process of <a href=\"../docs/interactivity-and-dynamic-uis#under-the-hood-autobinding-and-event-delegation\">autobinding</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/tips/dom-event-listeners.html\" class=\"_attribution-link\">https://facebook.github.io/react/tips/dom-event-listeners.html</a>\n  </p>\n</div>\n","tips/initial-ajax":"<h1>Load Initial Data via AJAX</h1>  <p>Fetch data in <code>componentDidMount</code>. When the response arrives, store the data in state, triggering a render to update your UI.</p> <p>When fetching data asynchronously, use <code>componentWillUnmount</code> to cancel any outstanding requests before the component is unmounted.</p> <p>This example fetches the desired Github user's latest gist:</p> <pre class=\"highlight\" data-language=\"js\">var UserGist = React.createClass({\n  getInitialState: function() {\n    return {\n      username: '',\n      lastGistUrl: ''\n    };\n  },\n\n  componentDidMount: function() {\n    this.serverRequest = $.get(this.props.source, function (result) {\n      var lastGist = result[0];\n      this.setState({\n        username: lastGist.owner.login,\n        lastGistUrl: lastGist.html_url\n      });\n    }.bind(this));\n  },\n\n  componentWillUnmount: function() {\n    this.serverRequest.abort();\n  },\n\n  render: function() {\n    return (\n      &lt;div&gt;\n        {this.state.username}'s last gist is\n        &lt;a href={this.state.lastGistUrl}&gt;here&lt;/a&gt;.\n      &lt;/div&gt;\n    );\n  }\n});\n\nReactDOM.render(\n  &lt;UserGist source=\"https://api.github.com/users/octocat/gists\" /&gt;,\n  mountNode\n);\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/tips/initial-ajax.html\" class=\"_attribution-link\">https://facebook.github.io/react/tips/initial-ajax.html</a>\n  </p>\n</div>\n","tips/children-undefined":"<h1>this.props.children undefined</h1>  <p>You can't access the children of your component through <code>this.props.children</code>. <code>this.props.children</code> designates the children being <strong>passed onto you</strong> by the owner:</p> <pre class=\"highlight\" data-language=\"js\">var App = React.createClass({\n  componentDidMount: function() {\n    // This doesn't refer to the `span`s! It refers to the children between\n    // last line's `&lt;App&gt;&lt;/App&gt;`, which are undefined.\n    console.log(this.props.children);\n  },\n\n  render: function() {\n    return &lt;div&gt;&lt;span/&gt;&lt;span/&gt;&lt;/div&gt;;\n  }\n});\n\nReactDOM.render(&lt;App&gt;&lt;/App&gt;, mountNode);\n</pre> <p>To access your own subcomponents (the <code>span</code>s), place <a href=\"../docs/more-about-refs\">refs</a> on them.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/tips/children-undefined.html\" class=\"_attribution-link\">https://facebook.github.io/react/tips/children-undefined.html</a>\n  </p>\n</div>\n","tips/dangerously-set-inner-html":"<h1>Dangerously Set innerHTML</h1>  <p>Improper use of the <code>innerHTML</code> can open you up to a <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\">cross-site scripting (XSS)</a> attack. Sanitizing user input for display is notoriously error-prone, and failure to properly sanitize is one of the <a href=\"https://owasptop10.googlecode.com/files/OWASP%20Top%2010%20-%202013.pdf\">leading causes of web vulnerabilities</a> on the internet.</p> <p>Our design philosophy is that it should be âeasyâ to make things safe, and developers should explicitly state their intent when performing âunsafeâ operations. The prop name <code>dangerouslySetInnerHTML</code> is intentionally chosen to be frightening, and the prop value (an object instead of a string) can be used to indicate sanitized data.</p> <p>After fully understanding the security ramifications and properly sanitizing the data, create a new object containing only the key <code>__html</code> and your sanitized data as the value. Here is an example using the JSX syntax:</p> <pre class=\"highlight\" data-language=\"js\">function createMarkup() { return {__html: 'First &amp;middot; Second'}; };\n&lt;div dangerouslySetInnerHTML={createMarkup()} /&gt;\n</pre> <p>The point being that if you unintentionally do say <code>&lt;div dangerouslySetInnerHTML={getUsername()} /&gt;</code> it will not be rendered because <code>getUsername()</code> would return a plain <code>string</code> and not a <code>{__html: ''}</code> object. The intent behind the <code>{__html:...}</code> syntax is that it be considered a \"type/taint\" of sorts. Sanitized data can be returned from a function using this wrapper object, and this marked data can subsequently be passed into <code>dangerouslySetInnerHTML</code>. For this reason, we recommend against writing code of the form <code>&lt;div dangerouslySetInnerHTML={{__html: getMarkup()}} /&gt;</code>.</p> <p>This functionality is mainly provided for cooperation with DOM string manipulation libraries, so the HTML provided must be well-formed (ie., pass XML validation).</p> <p>For a more complete usage example, refer to the last example on the <a href=\"https://facebook.github.io/react/\">front page</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/tips/dangerously-set-inner-html.html\" class=\"_attribution-link\">https://facebook.github.io/react/tips/dangerously-set-inner-html.html</a>\n  </p>\n</div>\n","docs/glossary":"<h1> React (Virtual) DOM Terminology </h1>  <p>In React's terminology, there are five core types that are important to distinguish:</p> <ul> <li><a href=\"#react-elements\">ReactElement / ReactElement Factory</a></li> <li><a href=\"#react-nodes\">ReactNode</a></li> <li><a href=\"#react-components\">ReactComponent / ReactComponent Class</a></li> </ul> <h2 id=\"react-elements\">\nReact Elements </h2> <p>The primary type in React is the <code>ReactElement</code>. It has four properties: <code>type</code>, <code>props</code>, <code>key</code> and <code>ref</code>. It has no methods and nothing on the prototype.</p> <p>You can create one of these objects through <code>React.createElement</code>.</p> <pre class=\"highlight\" data-language=\"javascript\">var root = React.createElement('div');\n</pre> <p>To render a new tree into the DOM, you create <code>ReactElement</code>s and pass them to <code>ReactDOM.render</code> along with a regular DOM <code>Element</code> (<code>HTMLElement</code> or <code>SVGElement</code>). <code>ReactElement</code>s are not to be confused with DOM <code>Element</code>s. A <code>ReactElement</code> is a light, stateless, immutable, virtual representation of a DOM <code>Element</code>. It is a virtual DOM.</p> <pre class=\"highlight\" data-language=\"javascript\">ReactDOM.render(root, document.getElementById('example'));\n</pre> <p>To add properties to a DOM element, pass a properties object as the second argument and children to the third argument.</p> <pre class=\"highlight\" data-language=\"javascript\">var child = React.createElement('li', null, 'Text Content');\nvar root = React.createElement('ul', { className: 'my-list' }, child);\nReactDOM.render(root, document.getElementById('example'));\n</pre> <p>If you use React JSX, then these <code>ReactElement</code>s are created for you. So this is equivalent:</p> <pre class=\"highlight\" data-language=\"javascript\">var root = &lt;ul className=\"my-list\"&gt;\n             &lt;li&gt;Text Content&lt;/li&gt;\n           &lt;/ul&gt;;\nReactDOM.render(root, document.getElementById('example'));\n</pre>\n<h3 id=\"factories\">\nFactories </h3> <p>A <code>ReactElement</code>-factory is simply a function that generates a <code>ReactElement</code> with a particular <code>type</code> property. React has a built-in helper for you to create factories. It's effectively just:</p> <pre class=\"highlight\" data-language=\"javascript\">function createFactory(type) {\n  return React.createElement.bind(null, type);\n}\n</pre> <p>It allows you to create a convenient short-hand instead of typing out <code>React.createElement('div')</code> all the time.</p> <pre class=\"highlight\" data-language=\"javascript\">var div = React.createFactory('div');\nvar root = div({ className: 'my-div' });\nReactDOM.render(root, document.getElementById('example'));\n</pre> <p>React already has built-in factories for common HTML tags:</p> <pre class=\"highlight\" data-language=\"javascript\">var root = React.DOM.ul({ className: 'my-list' },\n             React.DOM.li(null, 'Text Content')\n           );\n</pre> <p>If you are using JSX you have no need for factories. JSX already provides a convenient short-hand for creating <code>ReactElement</code>s.</p> <h2 id=\"react-nodes\">\nReact Nodes </h2> <p>A <code>ReactNode</code> can be either:</p> <ul> <li><code>ReactElement</code></li> <li>\n<code>string</code> (aka <code>ReactText</code>)</li> <li>\n<code>number</code> (aka <code>ReactText</code>)</li> <li>Array of <code>ReactNode</code>s (aka <code>ReactFragment</code>)</li> </ul> <p>These are used as properties of other <code>ReactElement</code>s to represent children. Effectively they create a tree of <code>ReactElement</code>s.</p> <h2 id=\"react-components\">\nReact Components </h2> <p>You can use React using only <code>ReactElement</code>s but to really take advantage of React, you'll want to use <code>ReactComponent</code>s to create encapsulations with embedded state.</p> <p>A <code>ReactComponent</code> Class is simply just a JavaScript class (or \"constructor function\").</p> <pre class=\"highlight\" data-language=\"javascript\">var MyComponent = React.createClass({\n  render: function() {\n    ...\n  }\n});\n</pre> <p>When this constructor is invoked it is expected to return an object with at least a <code>render</code> method on it. This object is referred to as a <code>ReactComponent</code>.</p> <pre class=\"highlight\" data-language=\"javascript\">var component = new MyComponent(props); // never do this\n</pre> <p>Other than for testing, you would normally <em>never</em> call this constructor yourself. React calls it for you.</p> <p>Instead, you pass the <code>ReactComponent</code> Class to <code>createElement</code> you get a <code>ReactElement</code>.</p> <pre class=\"highlight\" data-language=\"javascript\">var element = React.createElement(MyComponent);\n</pre> <p>OR using JSX:</p> <pre class=\"highlight\" data-language=\"javascript\">var element = &lt;MyComponent /&gt;;\n</pre> <p>When this is passed to <code>ReactDOM.render</code>, React will call the constructor for you and create a <code>ReactComponent</code>, which is returned.</p> <pre class=\"highlight\" data-language=\"javascript\">var component = ReactDOM.render(element, document.getElementById('example'));\n</pre> <p>If you keep calling <code>ReactDOM.render</code> with the same type of <code>ReactElement</code> and the same container DOM <code>Element</code> it always returns the same instance. This instance is stateful.</p> <pre class=\"highlight\" data-language=\"javascript\">var componentA = ReactDOM.render(&lt;MyComponent /&gt;, document.getElementById('example'));\nvar componentB = ReactDOM.render(&lt;MyComponent /&gt;, document.getElementById('example'));\ncomponentA === componentB; // true\n</pre> <p>This is why you shouldn't construct your own instance. Instead, <code>ReactElement</code> is a virtual <code>ReactComponent</code> before it gets constructed. An old and new <code>ReactElement</code> can be compared to see if a new <code>ReactComponent</code> instance should be created or if the existing one should be reused.</p> <p>The <code>render</code> method of a <code>ReactComponent</code> is expected to return another <code>ReactElement</code>. This allows these components to be composed. Ultimately the render resolves into <code>ReactElement</code> with a <code>string</code> tag which instantiates a DOM <code>Element</code> instance and inserts it into the document.</p> <p>React 0.14 introduced <a href=\"https://facebook.github.io/react/blog/2015/10/07/react-v0.14.html#stateless-functional-components\">stateless functional components</a> as an alternative way of defining components. Instead of being a class, it is a simple function that accepts props and is expected to return a <code>ReactElement</code>.</p> <h2 id=\"formal-type-definitions\">\nFormal Type Definitions </h2>\n<h3 id=\"entry-point\">\nEntry Point </h3>\n<pre class=\"highlight\" data-language=\"text\">ReactDOM.render = (ReactElement, HTMLElement | SVGElement) =&gt; ReactComponent;\n</pre>\n<h3 id=\"nodes-and-elements\">\nNodes and Elements </h3>\n<pre class=\"highlight\" data-language=\"text\">type ReactNode = ReactElement | ReactFragment | ReactText;\n\ntype ReactElement = ReactComponentElement | ReactDOMElement;\n\ntype ReactDOMElement = {\n  type : string,\n  props : {\n    children : ReactNodeList,\n    className : string,\n    etc.\n  },\n  key : string | boolean | number | null,\n  ref : string | null\n};\n\ntype ReactComponentElement&lt;TProps&gt; = {\n  type : ReactClass&lt;TProps&gt; | ReactFunctionalComponent&lt;TProps&gt;,\n  props : TProps,\n  key : string | boolean | number | null,\n  ref : string | null\n};\n\ntype ReactFragment = Array&lt;ReactNode | ReactEmpty&gt;;\n\ntype ReactNodeList = ReactNode | ReactEmpty;\n\ntype ReactText = string | number;\n\ntype ReactEmpty = null | undefined | boolean;\n</pre>\n<h3 id=\"classes-and-components\">\nClasses and Components </h3>\n<pre class=\"highlight\" data-language=\"text\">type ReactClass&lt;TProps&gt; = (TProps) =&gt; ReactComponent&lt;TProps&gt;;\n\ntype ReactComponent&lt;TProps&gt; = {\n  props : TProps,\n  render : () =&gt; ReactElement\n};\n\ntype ReactFunctionalComponent&lt;TProps&gt; = (TProps) =&gt; ReactElement;\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/docs/glossary.html\" class=\"_attribution-link\">https://facebook.github.io/react/docs/glossary.html</a>\n  </p>\n</div>\n","tips/communicate-between-components":"<h1>Communicate Between Components</h1>  <p>For parent-child communication, simply <a href=\"../docs/multiple-components\">pass props</a>.</p> <p>For child-parent communication: Say your <code>GroceryList</code> component has a list of items generated through an array. When a list item is clicked, you want to display its name:</p> <pre class=\"highlight\" data-language=\"js\">var handleClick = function(i, props) {\n  console.log('You clicked: ' + props.items[i]);\n}\n\nfunction GroceryList(props) {  \n  return (\n    &lt;div&gt;\n      {props.items.map(function(item, i) {\n        return (\n          &lt;div onClick={handleClick.bind(this, i, props)} key={i}&gt;{item}&lt;/div&gt;\n        );\n      })}\n    &lt;/div&gt;\n  );\n}\n\nReactDOM.render(\n  &lt;GroceryList items={['Apple', 'Banana', 'Cranberry']} /&gt;, mountNode\n);\n</pre> <p>Notice the use of <code>bind(this, arg1, arg2, ...)</code>: we're simply passing more arguments to <code>handleClick</code>. This is not a new React concept; it's just JavaScript.</p> <p>For communication between two components that don't have a parent-child relationship, you can set up your own global event system. Subscribe to events in <code>componentDidMount()</code>, unsubscribe in <code>componentWillUnmount()</code>, and call <code>setState()</code> when you receive an event. <a href=\"https://facebook.github.io/flux/\">Flux</a> pattern is one of the possible ways to arrange this.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/tips/communicate-between-components.html\" class=\"_attribution-link\">https://facebook.github.io/react/tips/communicate-between-components.html</a>\n  </p>\n</div>\n","tips/props-in-getinitialstate-as-anti-pattern":"<h1>Props in getInitialState Is an Anti-Pattern</h1>  <blockquote>  <p>This isn't really a React-specific tip, as such anti-patterns often occur in code in general; in this case, React simply points them out more clearly.</p> </blockquote> <p>Using props to generate state in <code>getInitialState</code> often leads to duplication of \"source of truth\", i.e. where the real data is. This is because <code>getInitialState</code> is only invoked when the component is first created.</p> <p>Whenever possible, compute values on-the-fly to ensure that they don't get out of sync later on and cause maintenance trouble.</p> <p><strong>Bad example:</strong></p> <pre class=\"highlight\" data-language=\"js\">var MessageBox = React.createClass({\n  getInitialState: function() {\n    return {nameWithQualifier: 'Mr. ' + this.props.name};\n  },\n\n  render: function() {\n    return &lt;div&gt;{this.state.nameWithQualifier}&lt;/div&gt;;\n  }\n});\n\nReactDOM.render(&lt;MessageBox name=\"Rogers\"/&gt;, mountNode);\n</pre> <p>Better:</p> <pre class=\"highlight\" data-language=\"js\">var MessageBox = React.createClass({\n  render: function() {\n    return &lt;div&gt;{'Mr. ' + this.props.name}&lt;/div&gt;;\n  }\n});\n\nReactDOM.render(&lt;MessageBox name=\"Rogers\"/&gt;, mountNode);\n</pre> <p>(For more complex logic, simply isolate the computation in a method.)</p> <p>However, it's <strong>not</strong> an anti-pattern if you make it clear that the prop is only seed data for the component's internally-controlled state:</p> <pre class=\"highlight\" data-language=\"js\">var Counter = React.createClass({\n  getInitialState: function() {\n    // naming it initialX clearly indicates that the only purpose\n    // of the passed down prop is to initialize something internally\n    return {count: this.props.initialCount};\n  },\n\n  handleClick: function() {\n    this.setState({count: this.state.count + 1});\n  },\n\n  render: function() {\n    return &lt;div onClick={this.handleClick}&gt;{this.state.count}&lt;/div&gt;;\n  }\n});\n\nReactDOM.render(&lt;Counter initialCount={7}/&gt;, mountNode);\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/tips/props-in-getInitialState-as-anti-pattern.html\" class=\"_attribution-link\">https://facebook.github.io/react/tips/props-in-getInitialState-as-anti-pattern.html</a>\n  </p>\n</div>\n","tips/expose-component-functions":"<h1>Expose Component Functions</h1>  <p>There's another (uncommon) way of <a href=\"communicate-between-components\">communicating between components</a>: simply expose a method on the child component for the parent to call.</p> <p>Say a list of todos, which upon clicking get removed. If there's only one unfinished todo left, animate it:</p> <pre class=\"highlight\" data-language=\"js\">var Todo = React.createClass({\n  render: function() {\n    return &lt;div onClick={this.props.onClick}&gt;{this.props.title}&lt;/div&gt;;\n  },\n\n  //this component will be accessed by the parent through the `ref` attribute\n  animate: function() {\n    console.log('Pretend %s is animating', this.props.title);\n  }\n});\n\nvar Todos = React.createClass({\n  getInitialState: function() {\n    return {items: ['Apple', 'Banana', 'Cranberry']};\n  },\n\n  handleClick: function(index) {\n    var items = this.state.items.filter(function(item, i) {\n      return index !== i;\n    });\n    this.setState({items: items}, function() {\n      if (items.length === 1) {\n        this.refs.item0.animate();\n      }\n    }.bind(this));\n  },\n\n  render: function() {\n    return (\n      &lt;div&gt;\n        {this.state.items.map(function(item, i) {\n          var boundClick = this.handleClick.bind(this, i);\n          return (\n            &lt;Todo onClick={boundClick} key={i} title={item} ref={'item' + i} /&gt;\n          );\n        }, this)}\n      &lt;/div&gt;\n    );\n  }\n});\n\nReactDOM.render(&lt;Todos /&gt;, mountNode);\n</pre> <p>Alternatively, you could have achieved this by passing the <code>todo</code> an <code>isLastUnfinishedItem</code> prop, let it check this prop in <code>componentDidUpdate</code>, then animate itself; however, this quickly gets messy if you pass around different props to control animations.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/tips/expose-component-functions.html\" class=\"_attribution-link\">https://facebook.github.io/react/tips/expose-component-functions.html</a>\n  </p>\n</div>\n","tips/use-react-with-other-libraries":"<h1>Use React with Other Libraries</h1>  <p>You don't have to go full React. The component <a href=\"../docs/component-specs#lifecycle-methods\">lifecycle events</a>, especially <code>componentDidMount</code> and <code>componentDidUpdate</code>, are good places to put your other libraries' logic.</p> <pre class=\"highlight\" data-language=\"js\">var App = React.createClass({\n  getInitialState: function() {\n    return {myModel: new myBackboneModel({items: [1, 2, 3]})};\n  },\n\n  componentDidMount: function() {\n    $(this.refs.placeholder).append($('&lt;span /&gt;'));\n  },\n\n  componentWillUnmount: function() {\n    // Clean up work here.\n  },\n\n  shouldComponentUpdate: function() {\n    // Let's just never update this component again.\n    return false;\n  },\n\n  render: function() {\n    return &lt;div ref=\"placeholder\"/&gt;;\n  }\n});\n\nReactDOM.render(&lt;App /&gt;, mountNode);\n</pre> <p>You can attach your own <a href=\"dom-event-listeners\">event listeners</a> and even <a href=\"https://baconjs.github.io\">event streams</a> this way.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2013&ndash;2016 Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>\n    <a href=\"https://facebook.github.io/react/tips/use-react-with-other-libraries.html\" class=\"_attribution-link\">https://facebook.github.io/react/tips/use-react-with-other-libraries.html</a>\n  </p>\n</div>\n"}
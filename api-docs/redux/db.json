{"index":"<h1 id=\"-a-href-http-redux-js-org-img-src-https-camo-githubusercontent-com-f28b5bc7822f1b7bb28a96d8d09e7d79169248fc-687474703a2f2f692e696d6775722e636f6d2f4a65567164514d2e706e67-height-60-a\">Redux</h1> <p>Redux is a predictable state container for JavaScript apps.<br>(If you’re looking for a WordPress framework, check out <a href=\"https://reduxframework.com/\" target=\"_blank\">Redux Framework</a>.)</p> <p>It helps you write applications that behave consistently, run in different environments (client, server, and native), and are easy to test. On top of that, it provides a great developer experience, such as <a href=\"https://github.com/gaearon/redux-devtools\" target=\"_blank\">live code editing combined with a time traveling debugger</a>.</p> <p>You can use Redux together with <a href=\"https://facebook.github.io/react/\" target=\"_blank\">React</a>, or with any other view library.<br>It is tiny (2kB, including dependencies).</p>  <blockquote> <p><strong>New! Learn Redux from its creator:<br><a href=\"https://egghead.io/series/getting-started-with-redux\" target=\"_blank\">Getting Started with Redux</a> (30 free videos)</strong></p> </blockquote> <h3 id=\"testimonials\">Testimonials</h3> <blockquote> <p><a href=\"https://twitter.com/jingc/status/616608251463909376\" target=\"_blank\">“Love what you’re doing with Redux”</a><br>Jing Chen, creator of Flux</p> <p><a href=\"https://twitter.com/fisherwebdev/status/616286955693682688\" target=\"_blank\">“I asked for comments on Redux in FB's internal JS discussion group, and it was universally praised. Really awesome work.”</a><br>Bill Fisher, author of Flux documentation</p> <p><a href=\"https://twitter.com/andrestaltz/status/616271392930201604\" target=\"_blank\">“It's cool that you are inventing a better Flux by not doing Flux at all.”</a><br>André Staltz, creator of Cycle</p> </blockquote> <h3 id=\"developer-experience\">Developer Experience</h3> <p>I wrote Redux while working on my React Europe talk called <a href=\"https://www.youtube.com/watch?v=xsSnOQynTHs\" target=\"_blank\">“Hot Reloading with Time Travel”</a>. My goal was to create a state management library with minimal API but completely predictable behavior, so it is possible to implement logging, hot reloading, time travel, universal apps, record and replay, without any buy-in from the developer.</p> <h3 id=\"influences\">Influences</h3> <p>Redux evolves the ideas of <a href=\"http://facebook.github.io/flux/\" target=\"_blank\">Flux</a>, but avoids its complexity by taking cues from <a href=\"https://github.com/evancz/elm-architecture-tutorial/\" target=\"_blank\">Elm</a>.<br>Whether you have used them or not, Redux only takes a few minutes to get started with.</p> <h3 id=\"installation\">Installation</h3> <p>To install the stable version:</p> <pre>npm install --save redux\n</pre>\n<p>This assumes you are using <a href=\"https://www.npmjs.com/\" target=\"_blank\">npm</a> as your package manager.<br>If you don’t, you can <a href=\"https://unpkg.com/redux/\" target=\"_blank\">access these files on unpkg</a>, download them, or point your package manager to them.</p> <p>Most commonly people consume Redux as a collection of <a href=\"http://webpack.github.io/docs/commonjs.html\" target=\"_blank\">CommonJS</a> modules. These modules are what you get when you import <code>redux</code> in a <a href=\"http://webpack.github.io\" target=\"_blank\">Webpack</a>, <a href=\"http://browserify.org/\" target=\"_blank\">Browserify</a>, or a Node environment. If you like to live on the edge and use <a href=\"http://rollupjs.org\" target=\"_blank\">Rollup</a>, we support that as well.</p> <p>If you don’t use a module bundler, it’s also fine. The <code>redux</code> npm package includes precompiled production and development <a href=\"https://github.com/umdjs/umd\" target=\"_blank\">UMD</a> builds in the <a href=\"https://unpkg.com/redux/dist/\" target=\"_blank\"><code>dist</code> folder</a>. They can be used directly without a bundler and are thus compatible with many popular JavaScript module loaders and environments. For example, you can drop a UMD build as a <a href=\"https://unpkg.com/redux/dist/redux.js\" target=\"_blank\"><code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">&gt;</span></span></code> tag</a> on the page, or <a href=\"https://github.com/reactjs/redux/pull/1181#issuecomment-167361975\" target=\"_blank\">tell Bower to install it</a>. The UMD builds make Redux available as a <code>window.Redux</code> global variable.</p> <p>The Redux source code is written in ES2015 but we precompile both CommonJS and UMD builds to ES5 so they work in <a href=\"http://caniuse.com/#feat=es5\" target=\"_blank\">any modern browser</a>. You don’t need to use Babel or a module bundler to <a href=\"https://github.com/reactjs/redux/blob/master/examples/counter-vanilla/index.html\" target=\"_blank\">get started with Redux</a>.</p> <h4 id=\"complementary-packages\">Complementary Packages</h4> <p>Most likely, you’ll also need <a href=\"https://github.com/reactjs/react-redux\" target=\"_blank\">the React bindings</a> and <a href=\"https://github.com/gaearon/redux-devtools\" target=\"_blank\">the developer tools</a>.</p> <pre>npm install --save react-redux\nnpm install --save-dev redux-devtools\n</pre>\n<p>Note that unlike Redux itself, many packages in the Redux ecosystem don’t provide UMD builds, so we recommend using CommonJS module bundlers like <a href=\"http://webpack.github.io\" target=\"_blank\">Webpack</a> and <a href=\"http://browserify.org/\" target=\"_blank\">Browserify</a> for the most comfortable development experience.</p> <h3 id=\"the-gist\">The Gist</h3> <p>The whole state of your app is stored in an object tree inside a single <em>store</em>.<br>The only way to change the state tree is to emit an <em>action</em>, an object describing what happened.<br>To specify how the actions transform the state tree, you write pure <em>reducers</em>.</p> <p>That’s it!</p> <pre data-language=\"js\">import { createStore } from 'redux'\n\n/**\n * This is a reducer, a pure function with (state, action) =&gt; state signature.\n * It describes how an action transforms the state into the next state.\n *\n * The shape of the state is up to you: it can be a primitive, an array, an object,\n * or even an Immutable.js data structure. The only important part is that you should\n * not mutate the state object, but return a new object if the state changes.\n *\n * In this example, we use a `switch` statement and strings, but you can use a helper that\n * follows a different convention (such as function maps) if it makes sense for your\n * project.\n */\nfunction counter(state = 0, action) {\n  switch (action.type) {\n  case 'INCREMENT':\n    return state + 1\n  case 'DECREMENT':\n    return state - 1\n  default:\n    return state\n  }\n}\n\n// Create a Redux store holding the state of your app.\n// Its API is { subscribe, dispatch, getState }.\nlet store = createStore(counter)\n\n// You can use subscribe() to update the UI in response to state changes.\n// Normally you’d use a view binding library (e.g. React Redux) rather than subscribe() directly.\n// However it can also be handy to persist the current state in the localStorage.\n\nstore.subscribe(() =&gt;\n  console.log(store.getState())\n)\n\n// The only way to mutate the internal state is to dispatch an action.\n// The actions can be serialized, logged or stored and later replayed.\nstore.dispatch({ type: 'INCREMENT' })\n// 1\nstore.dispatch({ type: 'INCREMENT' })\n// 2\nstore.dispatch({ type: 'DECREMENT' })\n// 1\n</pre> <p>Instead of mutating the state directly, you specify the mutations you want to happen with plain objects called <em>actions</em>. Then you write a special function called a <em>reducer</em> to decide how every action transforms the entire application’s state.</p> <p>If you’re coming from Flux, there is a single important difference you need to understand. Redux doesn’t have a Dispatcher or support many stores. Instead, there is just a single store with a single root reducing function. As your app grows, instead of adding stores, you split the root reducer into smaller reducers independently operating on the different parts of the state tree. This is exactly like there is just one root component in a React app, but it is composed out of many small components.</p> <p>This architecture might seem like an overkill for a counter app, but the beauty of this pattern is how well it scales to large and complex apps. It also enables very powerful developer tools, because it is possible to trace every mutation to the action that caused it. You can record user sessions and reproduce them just by replaying every action.</p> <h3 id=\"learn-redux-from-its-creator\">Learn Redux from Its Creator</h3> <p><a href=\"https://egghead.io/series/getting-started-with-redux\" target=\"_blank\">Getting Started with Redux</a> is a video course consisting of 30 videos narrated by Dan Abramov, author of Redux. It is designed to complement the “Basics” part of the docs while bringing additional insights about immutability, testing, Redux best practices, and using Redux with React. <strong>This course is free and will always be.</strong></p> <blockquote> <p><a href=\"https://twitter.com/sandrinodm/status/670548531422326785\" target=\"_blank\">“Great course on egghead.io by @dan_abramov - instead of just showing you how to use #redux, it also shows how and why redux was built!”</a><br>Sandrino Di Mattia</p> <p><a href=\"https://twitter.com/chrisdhanaraj/status/670328025553219584\" target=\"_blank\">“Plowing through @dan_abramov 'Getting Started with Redux' - its amazing how much simpler concepts get with video.”</a><br>Chris Dhanaraj</p> <p><a href=\"https://twitter.com/eddiezane/status/670333133242408960\" target=\"_blank\">“This video series on Redux by @dan_abramov on @eggheadio is spectacular!”</a><br>Eddie Zaneski</p> <p><a href=\"https://twitter.com/danott/status/669909126554607617\" target=\"_blank\">“Come for the name hype. Stay for the rock solid fundamentals. (Thanks, and great job @dan_abramov and @eggheadio!)”</a><br>Dan</p> <p><a href=\"https://twitter.com/gelatindesign/status/669658358643892224\" target=\"_blank\">“This series of videos on Redux by @dan_abramov is repeatedly blowing my mind - gunna do some serious refactoring”</a><br>Laurence Roberts</p> </blockquote> <p>So, what are you waiting for?</p> <h4 id=\"-watch-the-30-free-videos-https-egghead-io-series-getting-started-with-redux\"><a href=\"https://egghead.io/series/getting-started-with-redux\" target=\"_blank\">Watch the 30 Free Videos!</a></h4> <p>If you enjoyed my course, consider supporting Egghead by <a href=\"https://egghead.io/pricing\" target=\"_blank\">buying a subscription</a>. Subscribers have access to the source code for the example in every one of my videos, as well as to tons of advanced lessons on other topics, including JavaScript in depth, React, Angular, and more. Many <a href=\"https://egghead.io/instructors\" target=\"_blank\">Egghead instructors</a> are also open source library authors, so buying a subscription is a nice way to thank them for the work that they’ve done.</p> <h3 id=\"documentation\">Documentation</h3> <ul> <li><a href=\"introduction/index\">Introduction</a></li> <li><a href=\"basics/index\">Basics</a></li> <li><a href=\"advanced/index\">Advanced</a></li> <li><a href=\"recipes/index\">Recipes</a></li> <li><a href=\"troubleshooting\">Troubleshooting</a></li> <li><a href=\"glossary\">Glossary</a></li> <li><a href=\"api/index\">API Reference</a></li> </ul> <p>For PDF, ePub, and MOBI exports for offline reading, and instructions on how to create them, please see: <a href=\"https://github.com/paulkogel/redux-offline-docs\" target=\"_blank\">paulkogel/redux-offline-docs</a>.</p> <h3 id=\"examples\">Examples</h3> <ul> <li>\n<a href=\"introduction/examples#counter-vanilla\">Counter Vanilla</a> (<a href=\"https://github.com/reactjs/redux/tree/master/examples/counter-vanilla\" target=\"_blank\">source</a>)</li> <li>\n<a href=\"introduction/examples#counter\">Counter</a> (<a href=\"https://github.com/reactjs/redux/tree/master/examples/counter\" target=\"_blank\">source</a>)</li> <li>\n<a href=\"introduction/examples#todos\">Todos</a> (<a href=\"https://github.com/reactjs/redux/tree/master/examples/todos\" target=\"_blank\">source</a>)</li> <li>\n<a href=\"introduction/examples#todos-with-undo\">Todos with Undo</a> (<a href=\"https://github.com/reactjs/redux/tree/master/examples/todos-with-undo\" target=\"_blank\">source</a>)</li> <li>\n<a href=\"introduction/examples#todomvc\">TodoMVC</a> (<a href=\"https://github.com/reactjs/redux/tree/master/examples/todomvc\" target=\"_blank\">source</a>)</li> <li>\n<a href=\"introduction/examples#shopping-cart\">Shopping Cart</a> (<a href=\"https://github.com/reactjs/redux/tree/master/examples/shopping-cart\" target=\"_blank\">source</a>)</li> <li>\n<a href=\"introduction/examples#tree-view\">Tree View</a> (<a href=\"https://github.com/reactjs/redux/tree/master/examples/tree-view\" target=\"_blank\">source</a>)</li> <li>\n<a href=\"introduction/examples#async\">Async</a> (<a href=\"https://github.com/reactjs/redux/tree/master/examples/async\" target=\"_blank\">source</a>)</li> <li>\n<a href=\"introduction/examples#universal\">Universal</a> (<a href=\"https://github.com/reactjs/redux/tree/master/examples/universal\" target=\"_blank\">source</a>)</li> <li>\n<a href=\"introduction/examples#real-world\">Real World</a> (<a href=\"https://github.com/reactjs/redux/tree/master/examples/real-world\" target=\"_blank\">source</a>)</li> </ul> <p>If you’re new to the NPM ecosystem and have troubles getting a project up and running, or aren’t sure where to paste the gist above, check out <a href=\"https://github.com/jackielii/simplest-redux-example\" target=\"_blank\">simplest-redux-example</a> that uses Redux together with React and Browserify.</p> <h3 id=\"discussion\">Discussion</h3> <p>Join the <a href=\"https://discord.gg/0ZcbPKXt5bZ6au5t\" target=\"_blank\">#redux</a> channel of the <a href=\"http://www.reactiflux.com\" target=\"_blank\">Reactiflux</a> Discord community.</p> <h3 id=\"thanks\">Thanks</h3> <ul> <li>\n<a href=\"https://github.com/evancz/elm-architecture-tutorial\" target=\"_blank\">The Elm Architecture</a> for a great intro to modeling state updates with reducers;</li> <li>\n<a href=\"http://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/\" target=\"_blank\">Turning the database inside-out</a> for blowing my mind;</li> <li>\n<a href=\"https://www.youtube.com/watch?v=j-kj2qwJa_E\" target=\"_blank\">Developing ClojureScript with Figwheel</a> for convincing me that re-evaluation should “just work”;</li> <li>\n<a href=\"https://github.com/webpack/docs/wiki/hot-module-replacement-with-webpack\" target=\"_blank\">Webpack</a> for Hot Module Replacement;</li> <li>\n<a href=\"https://github.com/acdlite/flummox\" target=\"_blank\">Flummox</a> for teaching me to approach Flux without boilerplate or singletons;</li> <li>\n<a href=\"https://github.com/threepointone/disto\" target=\"_blank\">disto</a> for a proof of concept of hot reloadable Stores;</li> <li>\n<a href=\"https://github.com/optimizely/nuclear-js\" target=\"_blank\">NuclearJS</a> for proving this architecture can be performant;</li> <li>\n<a href=\"https://github.com/omcljs/om\" target=\"_blank\">Om</a> for popularizing the idea of a single state atom;</li> <li>\n<a href=\"https://github.com/cyclejs/cycle-core\" target=\"_blank\">Cycle</a> for showing how often a function is the best tool;</li> <li>\n<a href=\"https://github.com/facebook/react\" target=\"_blank\">React</a> for the pragmatic innovation.</li> </ul> <p>Special thanks to <a href=\"http://jdpaton.github.io\" target=\"_blank\">Jamie Paton</a> for handing over the <code>redux</code> NPM package name.</p> <h3 id=\"logo\">Logo</h3> <p>You can find the official logo <a href=\"https://github.com/reactjs/redux/tree/master/logo\" target=\"_blank\">on GitHub</a>.</p> <h3 id=\"change-log\">Change Log</h3> <p>This project adheres to <a href=\"http://semver.org/\" target=\"_blank\">Semantic Versioning</a>.<br>Every release, along with the migration instructions, is documented on the Github <a href=\"https://github.com/reactjs/redux/releases\" target=\"_blank\">Releases</a> page.</p> <h3 id=\"patrons\">Patrons</h3> <p>The work on Redux was <a href=\"https://www.patreon.com/reactdx\" target=\"_blank\">funded by the community</a>.<br>Meet some of the outstanding companies that made it possible:</p> <ul> <li><a href=\"https://github.com/webflow\" target=\"_blank\">Webflow</a></li> <li><a href=\"https://www.ximedes.com/\" target=\"_blank\">Ximedes</a></li> </ul> <p><a href=\"patrons\">See the full list of Redux patrons.</a></p> <h3 id=\"license\">License</h3> <p>MIT</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/\" class=\"_attribution-link\">http://redux.js.org/docs/</a>\n  </p>\n</div>\n","basics/index":"<h1 id=\"basics\">Basics</h1> <p>Don’t be fooled by all the fancy talk about reducers, middleware, store enhancers—Redux is incredibly simple. If you’ve ever built a Flux application, you will feel right at home. If you’re new to Flux, it’s easy too!</p> <p>In this guide, we’ll walk through the process of creating a simple Todo app.</p> <ul> <li><a href=\"actions\">Actions</a></li> <li><a href=\"reducers\">Reducers</a></li> <li><a href=\"store\">Store</a></li> <li><a href=\"dataflow\">Data Flow</a></li> <li><a href=\"usagewithreact\">Usage with React</a></li> <li><a href=\"exampletodolist\">Example: Todo List</a></li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/basics/index.html\" class=\"_attribution-link\">http://redux.js.org/docs/basics/index.html</a>\n  </p>\n</div>\n","introduction/index":"<h1 id=\"introduction\">Introduction</h1> <ul> <li><a href=\"motivation\">Motivation</a></li> <li><a href=\"threeprinciples\">Three Principles</a></li> <li><a href=\"priorart\">Prior Art</a></li> <li><a href=\"ecosystem\">Ecosystem</a></li> <li><a href=\"examples\">Examples</a></li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/introduction/index.html\" class=\"_attribution-link\">http://redux.js.org/docs/introduction/index.html</a>\n  </p>\n</div>\n","advanced/index":"<h1 id=\"advanced\">Advanced</h1> <p>In the <a href=\"../basics/index\">basics walkthrough</a>, we explored how to structure a simple Redux application. In this walkthrough, we will explore how AJAX and routing fit into the picture.</p> <ul> <li><a href=\"asyncactions\">Async Actions</a></li> <li><a href=\"asyncflow\">Async Flow</a></li> <li><a href=\"middleware\">Middleware</a></li> <li><a href=\"usagewithreactrouter.md\">Usage with React Router</a></li> <li><a href=\"exampleredditapi\">Example: Reddit API</a></li> <li><a href=\"nextsteps.md\">Next Steps</a></li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/advanced/index.html\" class=\"_attribution-link\">http://redux.js.org/docs/advanced/index.html</a>\n  </p>\n</div>\n","recipes/index":"<h1 id=\"recipes\">Recipes</h1> <p>These are some use cases and code snippets to get you started with Redux in a real app. They assume you understand the topics in <a href=\"../basics/index\">basic</a> and <a href=\"../advanced/index\">advanced</a> tutorials.</p> <ul> <li><a href=\"migratingtoredux\">Migrating to Redux</a></li> <li><a href=\"usingobjectspreadoperator\">Using Object Spread Operator</a></li> <li><a href=\"reducingboilerplate\">Reducing Boilerplate</a></li> <li><a href=\"serverrendering\">Server Rendering</a></li> <li><a href=\"writingtests\">Writing Tests</a></li> <li><a href=\"computingderiveddata\">Computing Derived Data</a></li> <li><a href=\"implementingundohistory\">Implementing Undo History</a></li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/recipes/index.html\" class=\"_attribution-link\">http://redux.js.org/docs/recipes/index.html</a>\n  </p>\n</div>\n","glossary":"<h1 id=\"glossary\">Glossary</h1> <p>This is a glossary of the core terms in Redux, along with their type signatures. The types are documented using <a href=\"http://flowtype.org/docs/quick-reference.html\" target=\"_blank\">Flow notation</a>.</p> <h2 id=\"state\">State</h2> <pre data-language=\"js\">type State = any\n</pre> <p><em>State</em> (also called the <em>state tree</em>) is a broad term, but in the Redux API it usually refers to the single state value that is managed by the store and returned by <a href=\"api/store#getState\"><code>getState()</code></a>. It represents the entire state of a Redux application, which is often a deeply nested object.</p> <p>By convention, the top-level state is an object or some other key-value collection like a Map, but technically it can be any type. Still, you should do your best to keep the state serializable. Don’t put anything inside it that you can’t easily turn into JSON.</p> <h2 id=\"action\">Action</h2> <pre data-language=\"js\">type Action = Object\n</pre> <p>An <em>action</em> is a plain object that represents an intention to change the state. Actions are the only way to get data into the store. Any data, whether from UI events, network callbacks, or other sources such as WebSockets needs to eventually be dispatched as actions.</p> <p>Actions must have a <code>type</code> field that indicates the type of action being performed. Types can be defined as constants and imported from another module. It’s better to use strings for <code>type</code> than <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol\" target=\"_blank\">Symbols</a> because strings are serializable.</p> <p>Other than <code>type</code>, the structure of an action object is really up to you. If you’re interested, check out <a href=\"https://github.com/acdlite/flux-standard-action\" target=\"_blank\">Flux Standard Action</a> for recommendations on how actions should be constructed.</p> <p>See also <a href=\"#async-action\">async action</a> below.</p> <h2 id=\"reducer\">Reducer</h2> <pre data-language=\"js\">type Reducer&lt;S, A&gt; = (state: S, action: A) =&gt; S\n</pre> <p>A <em>reducer</em> (also called a <em>reducing function</em>) is a function that accepts an accumulation and a value and returns a new accumulation. They are used to reduce a collection of values down to a single value.</p> <p>Reducers are not unique to Redux—they are a fundamental concept in functional programming. Even most non-functional languages, like JavaScript, have a built-in API for reducing. In JavaScript, it's <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\" target=\"_blank\"><code>Array.prototype.reduce()</code></a>.</p> <p>In Redux, the accumulated value is the state object, and the values being accumulated are actions. Reducers calculate a new state given the previous state and an action. They must be <em>pure functions</em>—functions that return the exact same output for given inputs. They should also be free of side-effects. This is what enables exciting features like hot reloading and time travel.</p> <p>Reducers are the most important concept in Redux.</p> <p><em>Do not put API calls into reducers.</em></p> <h2 id=\"dispatching-function\">Dispatching Function</h2> <pre data-language=\"js\">type BaseDispatch = (a: Action) =&gt; Action\ntype Dispatch = (a: Action | AsyncAction) =&gt; any\n</pre> <p>A <em>dispatching function</em> (or simply <em>dispatch function</em>) is a function that accepts an action or an <a href=\"#async-action\">async action</a>; it then may or may not dispatch one or more actions to the store.</p> <p>We must distinguish between dispatching functions in general and the base <a href=\"api/store#dispatch\"><code>dispatch</code></a> function provided by the store instance without any middleware.</p> <p>The base dispatch function <em>always</em> synchronously sends an action to the store’s reducer, along with the previous state returned by the store, to calculate a new state. It expects actions to be plain objects ready to be consumed by the reducer.</p> <p><a href=\"#middleware\">Middleware</a> wraps the base dispatch function. It allows the dispatch function to handle <a href=\"#async-action\">async actions</a> in addition to actions. Middleware may transform, delay, ignore, or otherwise interpret actions or async actions before passing them to the next middleware. See below for more information.</p> <h2 id=\"action-creator\">Action Creator</h2> <pre data-language=\"js\">type ActionCreator = (...args: any) =&gt; Action | AsyncAction\n</pre> <p>An <em>action creator</em> is, quite simply, a function that creates an action. Do not confuse the two terms—again, an action is a payload of information, and an action creator is a factory that creates an action.</p> <p>Calling an action creator only produces an action, but does not dispatch it. You need to call the store’s <a href=\"api/store#dispatch\"><code>dispatch</code></a> function to actually cause the mutation. Sometimes we say <em>bound action creators</em> to mean functions that call an action creator and immediately dispatch its result to a specific store instance.</p> <p>If an action creator needs to read the current state, perform an API call, or cause a side effect, like a routing transition, it should return an <a href=\"#async-action\">async action</a> instead of an action.</p> <h2 id=\"async-action\">Async Action</h2> <pre data-language=\"js\">type AsyncAction = any\n</pre> <p>An <em>async action</em> is a value that is sent to a dispatching function, but is not yet ready for consumption by the reducer. It will be transformed by <a href=\"#middleware\">middleware</a> into an action (or a series of actions) before being sent to the base <a href=\"api/store#dispatch\"><code>dispatch()</code></a> function. Async actions may have different types, depending on the middleware you use. They are often asynchronous primitives, like a Promise or a thunk, which are not passed to the reducer immediately, but trigger action dispatches once an operation has completed.</p> <h2 id=\"middleware\">Middleware</h2> <pre data-language=\"js\">type MiddlewareAPI = { dispatch: Dispatch, getState: () =&gt; State }\ntype Middleware = (api: MiddlewareAPI) =&gt; (next: Dispatch) =&gt; Dispatch\n</pre> <p>A middleware is a higher-order function that composes a <a href=\"#dispatching-function\">dispatch function</a> to return a new dispatch function. It often turns <a href=\"#async-action\">async actions</a> into actions.</p> <p>Middleware is composable using function composition. It is useful for logging actions, performing side effects like routing, or turning an asynchronous API call into a series of synchronous actions.</p> <p>See <a href=\"api/applymiddleware\"><code>applyMiddleware(...middlewares)</code></a> for a detailed look at middleware.</p> <h2 id=\"store\">Store</h2> <pre data-language=\"js\">type Store = {\n  dispatch: Dispatch\n  getState: () =&gt; State\n  subscribe: (listener: () =&gt; void) =&gt; () =&gt; void\n  replaceReducer: (reducer: Reducer) =&gt; void\n}\n</pre> <p>A store is an object that holds the application’s state tree.<br>There should only be a single store in a Redux app, as the composition happens on the reducer level.</p> <ul> <li>\n<a href=\"api/store#dispatch\"><code>dispatch(action)</code></a> is the base dispatch function described above.</li> <li>\n<a href=\"api/store#getState\"><code>getState()</code></a> returns the current state of the store.</li> <li>\n<a href=\"api/store#subscribe\"><code>subscribe(listener)</code></a> registers a function to be called on state changes.</li> <li>\n<a href=\"api/store#replaceReducer\"><code>replaceReducer(nextReducer)</code></a> can be used to implement hot reloading and code splitting. Most likely you won’t use it.</li> </ul> <p>See the complete <a href=\"api/store#dispatch\">store API reference</a> for more details.</p> <h2 id=\"store-creator\">Store creator</h2> <pre data-language=\"js\">type StoreCreator = (reducer: Reducer, initialState: ?State) =&gt; Store\n</pre> <p>A store creator is a function that creates a Redux store. Like with dispatching function, we must distinguish the base store creator, <a href=\"api/createstore\"><code>createStore(reducer, initialState)</code></a> exported from the Redux package, from store creators that are returned from the store enhancers.</p> <h2 id=\"store-enhancer\">Store enhancer</h2> <pre data-language=\"js\">type StoreEnhancer = (next: StoreCreator) =&gt; StoreCreator\n</pre> <p>A store enhancer is a higher-order function that composes a store creator to return a new, enhanced store creator. This is similar to middleware in that it allows you to alter the store interface in a composable way.</p> <p>Store enhancers are much the same concept as higher-order components in React, which are also occasionally called “component enhancers”.</p> <p>Because a store is not an instance, but rather a plain-object collection of functions, copies can be easily created and modified without mutating the original store. There is an example in <a href=\"api/compose\"><code>compose</code></a> documentation demonstrating that.</p> <p>Most likely you’ll never write a store enhancer, but you may use the one provided by the <a href=\"https://github.com/gaearon/redux-devtools\" target=\"_blank\">developer tools</a>. It is what makes time travel possible without the app being aware it is happening. Amusingly, the <a href=\"api/applymiddleware\">Redux middleware implementation</a> is itself a store enhancer.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/Glossary.html\" class=\"_attribution-link\">http://redux.js.org/docs/Glossary.html</a>\n  </p>\n</div>\n","api/index":"<h1 id=\"api-reference\">API Reference</h1> <p>The Redux API surface is tiny. Redux defines a set of contracts for you to implement (such as <a href=\"../glossary#reducer\">reducers</a>) and provides a few helper functions to tie these contracts together.</p> <p>This section documents the complete Redux API. Keep in mind that Redux is only concerned with managing the state. In a real app, you’ll also want to use UI bindings like <a href=\"https://github.com/gaearon/react-redux\" target=\"_blank\">react-redux</a>.</p> <h3 id=\"top-level-exports\">Top-Level Exports</h3> <ul> <li><a href=\"createstore\">createStore(reducer, [initialState])</a></li> <li><a href=\"combinereducers\">combineReducers(reducers)</a></li> <li><a href=\"applymiddleware\">applyMiddleware(...middlewares)</a></li> <li><a href=\"bindactioncreators\">bindActionCreators(actionCreators, dispatch)</a></li> <li><a href=\"compose\">compose(...functions)</a></li> </ul> <h3 id=\"store-api\">Store API</h3> <ul> <li>\n<a href=\"store\">Store</a><ul> <li><a href=\"store#getState\">getState()</a></li> <li><a href=\"store#dispatch\">dispatch(action)</a></li> <li><a href=\"store#subscribe\">subscribe(listener)</a></li> <li><a href=\"store#replaceReducer\">replaceReducer(nextReducer)</a></li> </ul> </li> </ul> <h3 id=\"importing\">Importing</h3> <p>Every function described above is a top-level export. You can import any of them like this:</p> <h4 id=\"es6\">ES6</h4> <pre data-language=\"js\">import { createStore } from 'redux'\n</pre> <h4 id=\"es5-commonjs\">ES5 (CommonJS)</h4> <pre data-language=\"js\">var createStore = require('redux').createStore\n</pre> <h4 id=\"es5-umd-build\">ES5 (UMD build)</h4> <pre data-language=\"js\">var createStore = Redux.createStore\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/api/index.html\" class=\"_attribution-link\">http://redux.js.org/docs/api/index.html</a>\n  </p>\n</div>\n","introduction/examples":"<h1 id=\"examples\">Examples</h1> <p>Redux is distributed with a few examples in its <a href=\"https://github.com/reactjs/redux/tree/master/examples\" target=\"_blank\">source code</a>.</p> <h2 id=\"counter-vanilla\">Counter Vanilla</h2> <p>Run the <a href=\"https://github.com/reactjs/redux/tree/master/examples/counter-vanilla\" target=\"_blank\">Counter Vanilla</a> example:</p> <pre>git clone https://github.com/reactjs/redux.git\n\ncd redux/examples/counter-vanilla\nopen index.html\n</pre>\n<p>It does not require a build system or a view framework and exists to show the raw Redux API used with ES5.</p> <h2 id=\"counter\">Counter</h2> <p>Run the <a href=\"https://github.com/reactjs/redux/tree/master/examples/counter\" target=\"_blank\">Counter</a> example:</p> <pre>git clone https://github.com/reactjs/redux.git\n\ncd redux/examples/counter\nnpm install\nnpm start\n\nopen http://localhost:3000/\n</pre>\n<p>This is the most basic example of using Redux together with React. For simplicity, it re-renders the React component manually when the store changes. In real projects, you will likely want to use the highly performant <a href=\"https://github.com/reactjs/react-redux\" target=\"_blank\">React Redux</a> bindings instead.</p> <p>This example includes tests.</p> <h2 id=\"todos\">Todos</h2> <p>Run the <a href=\"https://github.com/reactjs/redux/tree/master/examples/todos\" target=\"_blank\">Todos</a> example:</p> <pre>git clone https://github.com/reactjs/redux.git\n\ncd redux/examples/todos\nnpm install\nnpm start\n\nopen http://localhost:3000/\n</pre>\n<p>This is the best example to get a deeper understanding of how the state updates work together with components in Redux. It shows how reducers can delegate handling actions to other reducers, and how you can use <a href=\"https://github.com/reactjs/react-redux\" target=\"_blank\">React Redux</a> to generate container components from your presentational components.</p> <p>This example includes tests.</p> <h2 id=\"todos-with-undo\">Todos with Undo</h2> <p>Run the <a href=\"https://github.com/reactjs/redux/tree/master/examples/todos-with-undo\" target=\"_blank\">Todos with Undo</a> example:</p> <pre>git clone https://github.com/reactjs/redux.git\n\ncd redux/examples/todos-with-undo\nnpm install\nnpm start\n\nopen http://localhost:3000/\n</pre>\n<p>This is a variation on the previous example. It is almost identical, but additionally shows how wrapping your reducer with <a href=\"https://github.com/omnidan/redux-undo\" target=\"_blank\">Redux Undo</a> lets you add a Undo/Redo functionality to your app with a few lines of code.</p> <h2 id=\"todomvc\">TodoMVC</h2> <p>Run the <a href=\"https://github.com/reactjs/redux/tree/master/examples/todomvc\" target=\"_blank\">TodoMVC</a> example:</p> <pre>git clone https://github.com/reactjs/redux.git\n\ncd redux/examples/todomvc\nnpm install\nnpm start\n\nopen http://localhost:3000/\n</pre>\n<p>This is the classical <a href=\"http://todomvc.com/\" target=\"_blank\">TodoMVC</a> example. It’s here for the sake of comparison, but it covers the same points as the Todos example.</p> <p>This example includes tests.</p> <h2 id=\"shopping-cart\">Shopping Cart</h2> <p>Run the <a href=\"https://github.com/reactjs/redux/tree/master/examples/shopping-cart\" target=\"_blank\">Shopping Cart</a> example:</p> <pre>git clone https://github.com/reactjs/redux.git\n\ncd redux/examples/shopping-cart\nnpm install\nnpm start\n\nopen http://localhost:3000/\n</pre>\n<p>This example shows important idiomatic Redux patterns that become important as your app grows. In particular, it shows how to store entities in a normalized way by their IDs, how to compose reducers on several levels, and how to define selectors alongside the reducers so the knowledge about the state shape is encapsulated. It also demonstrates logging with <a href=\"https://github.com/fcomb/redux-logger\" target=\"_blank\">Redux Logger</a> and conditional dispatching of actions with <a href=\"https://github.com/gaearon/redux-thunk\" target=\"_blank\">Redux Thunk</a> middleware.</p> <h2 id=\"tree-view\">Tree View</h2> <p>Run the <a href=\"https://github.com/reactjs/redux/tree/master/examples/tree-view\" target=\"_blank\">Tree View</a> example:</p> <pre>git clone https://github.com/reactjs/redux.git\n\ncd redux/examples/tree-view\nnpm install\nnpm start\n\nopen http://localhost:3000/\n</pre>\n<p>This example demonstrates rendering a deeply nested tree view and representing its state in a normalized form so it is easy to update from reducers. Good rendering performance is achieved by the container components granularly subscribing only to the tree nodes that they render.</p> <p>This example includes tests.</p> <h2 id=\"async\">Async</h2> <p>Run the <a href=\"https://github.com/reactjs/redux/tree/master/examples/async\" target=\"_blank\">Async</a> example:</p> <pre>git clone https://github.com/reactjs/redux.git\n\ncd redux/examples/async\nnpm install\nnpm start\n\nopen http://localhost:3000/\n</pre>\n<p>This example includes reading from an asynchronous API, fetching data in response to user input, showing loading indicators, caching the response, and invalidating the cache. It uses <a href=\"https://github.com/gaearon/redux-thunk\" target=\"_blank\">Redux Thunk</a> middleware to encapsulate asynchronous side effects.</p> <h2 id=\"universal\">Universal</h2> <p>Run the <a href=\"https://github.com/reactjs/redux/tree/master/examples/universal\" target=\"_blank\">Universal</a> example:</p> <pre>git clone https://github.com/reactjs/redux.git\n\ncd redux/examples/universal\nnpm install\nnpm start\n\nopen http://localhost:3000/\n</pre>\n<p>This is a basic demonstration of <a href=\"../recipes/serverrendering\">server rendering</a> with Redux and React. It shows how to prepare the initial store state on the server, and pass it down to the client so the client store can boot up from an existing state.</p> <h2 id=\"real-world\">Real World</h2> <p>Run the <a href=\"https://github.com/reactjs/redux/tree/master/examples/real-world\" target=\"_blank\">Real World</a> example:</p> <pre>git clone https://github.com/reactjs/redux.git\n\ncd redux/examples/real-world\nnpm install\nnpm start\n\nopen http://localhost:3000/\n</pre>\n<p>This is the most advanced example. It is dense by design. It covers keeping fetched entities in a normalized cache, implementing a custom middleware for API calls, rendering partially loaded data, pagination, caching responses, displaying error messages, and routing. Additionally, it includes Redux DevTools.</p> <h2 id=\"more-examples\">More Examples</h2> <p>You can find more examples in <a href=\"https://github.com/xgrommx/awesome-redux\" target=\"_blank\">Awesome Redux</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/introduction/Examples.html\" class=\"_attribution-link\">http://redux.js.org/docs/introduction/Examples.html</a>\n  </p>\n</div>\n","troubleshooting":"<h1 id=\"troubleshooting\">Troubleshooting</h1> <p>This is a place to share common problems and solutions to them.<br>The examples use React, but you should still find them useful if you use something else.</p> <h3 id=\"nothing-happens-when-i-dispatch-an-action\">Nothing happens when I dispatch an action</h3> <p>Sometimes, you are trying to dispatch an action, but your view does not update. Why does this happen? There may be several reasons for this.</p> <h4 id=\"never-mutate-reducer-arguments\">Never mutate reducer arguments</h4> <p>It is tempting to modify the <code>state</code> or <code>action</code> passed to you by Redux. Don’t do this!</p> <p>Redux assumes that you never mutate the objects it gives to you in the reducer. <strong>Every single time, you must return the new state object.</strong> Even if you don’t use a library like <a href=\"https://facebook.github.io/immutable-js/\" target=\"_blank\">Immutable</a>, you need to completely avoid mutation.</p> <p>Immutability is what lets <a href=\"https://github.com/gaearon/react-redux\" target=\"_blank\">react-redux</a> efficiently subscribe to fine-grained updates of your state. It also enables great developer experience features such as time travel with <a href=\"http://github.com/gaearon/redux-devtools\" target=\"_blank\">redux-devtools</a>.</p> <p>For example, a reducer like this is wrong because it mutates the state:</p> <pre data-language=\"js\">function todos(state = [], action) {\n  switch (action.type) {\n    case 'ADD_TODO':\n      // Wrong! This mutates state\n      state.push({\n        text: action.text,\n        completed: false\n      })\n      return state\n    case 'COMPLETE_TODO':\n      // Wrong! This mutates state[action.index].\n      state[action.index].completed = true\n      return state\n    default:\n      return state\n  }\n}\n</pre> <p>It needs to be rewritten like this:</p> <pre data-language=\"js\">function todos(state = [], action) {\n  switch (action.type) {\n    case 'ADD_TODO':\n      // Return a new array\n      return [\n        ...state,\n        {\n          text: action.text,\n          completed: false\n        }\n      ]\n    case 'COMPLETE_TODO':\n      // Return a new array\n      return state.map((todo, index) =&gt; {\n        if (index === action.index) {\n          // Copy the object before mutating\n          return Object.assign({}, todo, {\n            completed: true\n          })\n        }\n        return todo\n      })\n    default:\n      return state\n  }\n}\n</pre> <p>It’s more code, but it’s exactly what makes Redux predictable and efficient. If you want to have less code, you can use a helper like <a href=\"https://facebook.github.io/react/docs/update.html\" target=\"_blank\"><code>React.addons.update</code></a> to write immutable transformations with a terse syntax:</p> <pre data-language=\"js\">// Before:\nreturn state.map((todo, index) =&gt; {\n  if (index === action.index) {\n    return Object.assign({}, todo, {\n      completed: true\n    })\n  }\n  return todo\n})\n\n// After\nreturn update(state, {\n  [action.index]: {\n    completed: {\n      $set: true\n    }\n  }\n})\n</pre> <p>Finally, to update objects, you’ll need something like <code>_.extend</code> from Underscore, or better, an <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\"><code>Object.assign</code></a> polyfill.</p> <p>Make sure that you use <code>Object.assign</code> correctly. For example, instead of returning something like <code>Object.assign(state, newData)</code> from your reducers, return <code>Object.assign({}, state, newData)</code>. This way you don’t override the previous <code>state</code>.</p> <p>You can also enable the <a href=\"recipes/usingobjectspreadoperator\">object spread operator proposal</a> for a more succinct syntax:</p> <pre data-language=\"js\">// Before:\nreturn state.map((todo, index) =&gt; {\n  if (index === action.index) {\n    return Object.assign({}, todo, {\n      completed: true\n    })\n  }\n  return todo\n})\n\n// After:\nreturn state.map((todo, index) =&gt; {\n  if (index === action.index) {\n    return { ...todo, completed: true }\n  }\n  return todo\n})\n</pre> <p>Note that experimental language features are subject to change.</p> <h4 id=\"don%E2%80%99t-forget-to-call-dispatch-action-api-store-md-dispatch\">Don’t forget to call <a href=\"api/store#dispatch\"><code>dispatch(action)</code></a>\n</h4> <p>If you define an action creator, calling it will <em>not</em> automatically dispatch the action. For example, this code will do nothing:</p> <h4 id=\"-todoactions-js\"><code>TodoActions.js</code></h4> <pre data-language=\"js\">export function addTodo(text) {\n  return { type: 'ADD_TODO', text }\n}\n</pre> <h4 id=\"-addtodo-js\"><code>AddTodo.js</code></h4> <pre data-language=\"js\">import React, { Component } from 'react'\nimport { addTodo } from './TodoActions'\n\nclass AddTodo extends Component {\n  handleClick() {\n    // Won't work!\n    addTodo('Fix the issue')\n  }\n\n  render() {\n    return (\n      &lt;button onClick={() =&gt; this.handleClick()}&gt;\n        Add\n      &lt;/button&gt;\n    )\n  }\n}\n</pre> <p>It doesn’t work because your action creator is just a function that <em>returns</em> an action. It is up to you to actually dispatch it. We can’t bind your action creators to a particular Store instance during the definition because apps that render on the server need a separate Redux store for every request.</p> <p>The fix is to call <a href=\"api/store#dispatch\"><code>dispatch()</code></a> method on the <a href=\"api/store\">store</a> instance:</p> <pre data-language=\"js\">handleClick() {\n  // Works! (but you need to grab store somehow)\n  store.dispatch(addTodo('Fix the issue'))\n}\n</pre> <p>If you’re somewhere deep in the component hierarchy, it is cumbersome to pass the store down manually. This is why <a href=\"https://github.com/gaearon/react-redux\" target=\"_blank\">react-redux</a> lets you use a <code>connect</code> <a href=\"https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750\" target=\"_blank\">higher-order component</a> that will, apart from subscribing you to a Redux store, inject <code>dispatch</code> into your component’s props.</p> <p>The fixed code looks like this:</p> <h4 id=\"-addtodo-js\"><code>AddTodo.js</code></h4> <pre data-language=\"js\">import React, { Component } from 'react'\nimport { connect } from 'react-redux'\nimport { addTodo } from './TodoActions'\n\nclass AddTodo extends Component {\n  handleClick() {\n    // Works!\n    this.props.dispatch(addTodo('Fix the issue'))\n  }\n\n  render() {\n    return (\n      &lt;button onClick={() =&gt; this.handleClick()}&gt;\n        Add\n      &lt;/button&gt;\n    )\n  }\n}\n\n// In addition to the state, `connect` puts `dispatch` in our props.\nexport default connect()(AddTodo)\n</pre> <p>You can then pass <code>dispatch</code> down to other components manually, if you want to.</p> <h4 id=\"make-sure-mapstatetoprops-is-correct\">Make sure mapStateToProps is correct</h4> <p>It's possible you're correctly dispatching an action and applying your reducer but the corresponding state is not being correctly translated into props.</p> <h2 id=\"something-else-doesn%E2%80%99t-work\">Something else doesn’t work</h2> <p>Ask around on the <strong>#redux</strong> <a href=\"http://reactiflux.com/\" target=\"_blank\">Reactiflux</a> Discord channel, or <a href=\"https://github.com/reactjs/redux/issues\" target=\"_blank\">create an issue</a>.<br>If you figure it out, <a href=\"https://github.com/reactjs/redux/edit/master/docs/Troubleshooting.md\" target=\"_blank\">edit this document</a> as a courtesy to the next person having the same problem.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/Troubleshooting.html\" class=\"_attribution-link\">http://redux.js.org/docs/Troubleshooting.html</a>\n  </p>\n</div>\n","introduction/motivation":"<h1 id=\"motivation\">Motivation</h1> <p>As the requirements for JavaScript single-page applications have become increasingly complicated, <strong>our code must manage more state than ever before</strong>. This state can include server responses and cached data, as well as locally created data that has not yet been persisted to the server. UI state is also increasing in complexity, as we need to manage the active route, the selected tab, whether to show a spinner or not, should pagination controls be displayed, and so on.</p> <p>Managing this ever-changing state is hard. If a model can update another model, then a view can update a model, which updates another model, and this, in turn, might cause another view to update. At some point, you no longer understand what happens in your app as you have <strong>lost control over the when, why, and how of its state.</strong> When a system is opaque and non-deterministic, it’s hard to reproduce bugs or add new features.</p> <p>As if this wasn’t bad enough, consider the <strong>new requirements becoming common in front-end product development</strong>. As developers, we are expected to handle optimistic updates, server-side rendering, fetching data before performing route transitions, and so on. We find ourselves trying to manage a complexity that we have never had to deal with before, and we inevitably ask the question: <a href=\"http://www.quirksmode.org/blog/archives/2015/07/stop_pushing_th.html\" target=\"_blank\">is it time to give up?</a> The answer is <em>no</em>.</p> <p>This complexity is difficult to handle as <strong>we’re mixing two concepts</strong> that are very hard for the human mind to reason about: <strong>mutation and asynchronicity.</strong> I call them <a href=\"https://en.wikipedia.org/wiki/Diet_Coke_and_Mentos_eruption\" target=\"_blank\">Mentos and Coke</a>. Both can be great in separation, but together they create a mess. Libraries like <a href=\"http://facebook.github.io/react\" target=\"_blank\">React</a> attempt to solve this problem in the view layer by removing both asynchrony and direct DOM manipulation. However, managing the state of your data is left up to you. This is where Redux enters.</p> <p>Following in the steps of <a href=\"http://facebook.github.io/flux\" target=\"_blank\">Flux</a>, <a href=\"http://martinfowler.com/bliki/CQRS.html\" target=\"_blank\">CQRS</a>, and <a href=\"http://martinfowler.com/eaaDev/EventSourcing.html\" target=\"_blank\">Event Sourcing</a>, <strong>Redux attempts to make state mutations predictable</strong> by imposing certain restrictions on how and when updates can happen. These restrictions are reflected in the <a href=\"threeprinciples\">three principles</a> of Redux.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/introduction/Motivation.html\" class=\"_attribution-link\">http://redux.js.org/docs/introduction/Motivation.html</a>\n  </p>\n</div>\n","advanced/asyncflow":"<h1 id=\"async-flow\">Async Flow</h1> <p>Without <a href=\"middleware\">middleware</a>, Redux store only supports <a href=\"../basics/dataflow\">synchronous data flow</a>. This is what you get by default with <a href=\"../api/createstore\"><code>createStore()</code></a>.</p> <p>You may enhance <a href=\"../api/createstore\"><code>createStore()</code></a> with <a href=\"../api/applymiddleware\"><code>applyMiddleware()</code></a>. It is not required, but it lets you <a href=\"asyncactions\">express asynchronous actions in a convenient way</a>.</p> <p>Asynchronous middleware like <a href=\"https://github.com/gaearon/redux-thunk\" target=\"_blank\">redux-thunk</a> or <a href=\"https://github.com/acdlite/redux-promise\" target=\"_blank\">redux-promise</a> wraps the store’s <a href=\"../api/store#dispatch\"><code>dispatch()</code></a> method and allows you to dispatch something other than actions, for example, functions or Promises. Any middleware you use can then interpret anything you dispatch, and in turn, can pass actions to the next middleware in chain. For example, a Promise middleware can intercept Promises and dispatch a pair of begin/end actions asynchronously in response to each Promise.</p> <p>When the last middleware in the chain dispatches an action, it has to be a plain object. This is when the <a href=\"../basics/dataflow\">synchronous Redux data flow</a> takes place.</p> <p>Check out <a href=\"exampleredditapi\">the full source code for the async example</a>.</p> <h2 id=\"next-steps\">Next Steps</h2> <p>Now you saw an example of what middleware can do in Redux, it’s time to learn how it actually works, and how you can create your own. Go on to the next detailed section about <a href=\"middleware\">Middleware</a>. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/advanced/AsyncFlow.html\" class=\"_attribution-link\">http://redux.js.org/docs/advanced/AsyncFlow.html</a>\n  </p>\n</div>\n","introduction/threeprinciples":"<h1 id=\"three-principles\">Three Principles</h1> <p>Redux can be described in three fundamental principles:</p> <h3 id=\"single-source-of-truth\">Single source of truth</h3> <p><strong>The <a href=\"../glossary#state\">state</a> of your whole application is stored in an object tree within a single <a href=\"../glossary#store\">store</a>.</strong></p> <p>This makes it easy to create universal apps, as the state from your server can be serialized and hydrated into the client with no extra coding effort. A single state tree also makes it easier to debug or introspect an application; it also enables you to persist your app’s state in development, for a faster development cycle. Some functionality which has been traditionally difficult to implement - Undo/Redo, for example - can suddenly become trivial to implement, if all of your state is stored in a single tree.</p> <pre data-language=\"js\">console.log(store.getState())\n\n/* Prints\n{\n  visibilityFilter: 'SHOW_ALL',\n  todos: [\n    {\n      text: 'Consider using Redux',\n      completed: true,\n    },\n    {\n      text: 'Keep all state in a single tree',\n      completed: false\n    }\n  ]\n}\n*/\n</pre> <h3 id=\"state-is-read-only\">State is read-only</h3> <p><strong>The only way to mutate the state is to emit an <a href=\"../glossary#action\">action</a>, an object describing what happened.</strong></p> <p>This ensures that neither the views nor the network callbacks will ever write directly to the state. Instead, they express an intent to mutate. Because all mutations are centralized and happen one by one in a strict order, there are no subtle race conditions to watch out for. As actions are just plain objects, they can be logged, serialized, stored, and later replayed for debugging or testing purposes.</p> <pre data-language=\"js\">store.dispatch({\n  type: 'COMPLETE_TODO',\n  index: 1\n})\n\nstore.dispatch({\n  type: 'SET_VISIBILITY_FILTER',\n  filter: 'SHOW_COMPLETED'\n})\n</pre> <h3 id=\"changes-are-made-with-pure-functions\">Changes are made with pure functions</h3> <p><strong>To specify how the state tree is transformed by actions, you write pure <a href=\"../glossary#reducer\">reducers</a>.</strong></p> <p>Reducers are just pure functions that take the previous state and an action, and return the next state. Remember to return new state objects, instead of mutating the previous state. You can start with a single reducer, and as your app grows, split it off into smaller reducers that manage specific parts of the state tree. Because reducers are just functions, you can control the order in which they are called, pass additional data, or even make reusable reducers for common tasks such as pagination.</p> <pre data-language=\"js\">\nfunction visibilityFilter(state = 'SHOW_ALL', action) {\n  switch (action.type) {\n    case 'SET_VISIBILITY_FILTER':\n      return action.filter\n    default:\n      return state\n  }\n}\n\nfunction todos(state = [], action) {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return [\n        ...state,\n        {\n          text: action.text,\n          completed: false\n        }\n      ]\n    case 'COMPLETE_TODO':\n      return state.map((todo, index) =&gt; {\n        if (index === action.index) {\n          return Object.assign({}, todo, {\n            completed: true\n          })\n        }\n        return todo\n      })\n    default:\n      return state\n  }\n}\n\nimport { combineReducers, createStore } from 'redux'\nlet reducer = combineReducers({ visibilityFilter, todos })\nlet store = createStore(reducer)\n</pre> <p>That’s it! Now you know what Redux is all about.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/introduction/ThreePrinciples.html\" class=\"_attribution-link\">http://redux.js.org/docs/introduction/ThreePrinciples.html</a>\n  </p>\n</div>\n","introduction/priorart":"<h1 id=\"prior-art\">Prior Art</h1> <p>Redux has a mixed heritage. It is similar to some patterns and technologies, but is also different from them in important ways. We’ll explore some of the similarities and the differences below.</p> <h3 id=\"flux\">Flux</h3> <p>Can Redux be considered a <a href=\"https://facebook.github.io/flux/\" target=\"_blank\">Flux</a> implementation?<br><a href=\"https://twitter.com/fisherwebdev/status/616278911886884864\" target=\"_blank\">Yes</a>, and <a href=\"https://twitter.com/andrestaltz/status/616270755605708800\" target=\"_blank\">no</a>.</p> <p>(Don’t worry, <a href=\"https://twitter.com/jingc/status/616608251463909376\" target=\"_blank\">Flux creators</a> <a href=\"https://twitter.com/fisherwebdev/status/616286955693682688\" target=\"_blank\">approve of it</a>, if that’s all you wanted to know.)</p> <p>Redux was inspired by several important qualities of Flux. Like Flux, Redux prescribes that you concentrate your model update logic in a certain layer of your application (“stores” in Flux, “reducers” in Redux). Instead of letting the application code directly mutate the data, both tell you to describe every mutation as a plain object called an “action”.</p> <p>Unlike Flux, <strong>Redux does not have the concept of a Dispatcher</strong>. This is because it relies on pure functions instead of event emitters, and pure functions are easy to compose and don’t need an additional entity managing them. Depending on how you view Flux, you may see this as either a deviation or an implementation detail. Flux has often been <a href=\"https://speakerdeck.com/jmorrell/jsconf-uy-flux-those-who-forget-the-past-dot-dot-dot-1\" target=\"_blank\">described as <code>(state, action) =&gt; state</code></a>. In this sense, Redux is true to the Flux architecture, but makes it simpler thanks to pure functions.</p> <p>Another important difference from Flux is that <strong>Redux assumes you never mutate your data</strong>. You can use plain objects and arrays for your state just fine, but mutating them inside the reducers is strongly discouraged. You should always return a new object, which is easy with the <a href=\"../recipes/usingobjectspreadoperator\">object spread operator proposal</a>, or with a library like <a href=\"https://facebook.github.io/immutable-js\" target=\"_blank\">Immutable</a>.</p> <p>While it is technically <em>possible</em> to <a href=\"https://github.com/reactjs/redux/issues/328#issuecomment-125035516\" target=\"_blank\">write impure reducers</a> that mutate the data for performance corner cases, we actively discourage you from doing this. Development features like time travel, record/replay, or hot reloading will break. Moreover it doesn’t seem like immutability poses performance problems in most real apps, because, as <a href=\"https://github.com/omcljs/om\" target=\"_blank\">Om</a> demonstrates, even if you lose out on object allocation, you still win by avoiding expensive re-renders and re-calculations, as you know exactly what changed thanks to reducer purity.</p> <h3 id=\"elm\">Elm</h3> <p><a href=\"http://elm-lang.org/\" target=\"_blank\">Elm</a> is a functional programming language inspired by Haskell and created by <a href=\"https://twitter.com/czaplic\" target=\"_blank\">Evan Czaplicki</a>. It enforces <a href=\"https://github.com/evancz/elm-architecture-tutorial/\" target=\"_blank\">a “model view update” architecture</a>, where the update has the following signature: <code>(action, state) =&gt; state</code>. Elm “updaters” serve the same purpose as reducers in Redux.</p> <p>Unlike Redux, Elm is a language, so it is able to benefit from many things like enforced purity, static typing, out of the box immutability, and pattern matching (using the <code>case</code> expression). Even if you don’t plan to use Elm, you should read about the Elm architecture, and play with it. There is an interesting <a href=\"https://github.com/paldepind/noname-functional-frontend-framework\" target=\"_blank\">JavaScript library playground implementing similar ideas</a>. We should look there for inspiration on Redux! One way that we can get closer to the static typing of Elm is by <a href=\"https://github.com/reactjs/redux/issues/290\" target=\"_blank\">using a gradual typing solution like Flow</a>.</p> <h3 id=\"immutable\">Immutable</h3> <p><a href=\"https://facebook.github.io/immutable-js\" target=\"_blank\">Immutable</a> is a JavaScript library implementing persistent data structures. It is performant and has an idiomatic JavaScript API.</p> <p>Immutable and most similar libraries are orthogonal to Redux. Feel free to use them together!</p> <p><strong>Redux doesn’t care <em>how</em> you store the state—it can be a plain object, an Immutable object, or anything else.</strong> You’ll probably want a (de)serialization mechanism for writing universal apps and hydrating their state from the server, but other than that, you can use any data storage library <em>as long as it supports immutability</em>. For example, it doesn’t make sense to use Backbone for Redux state, because Backbone models are mutable.</p> <p>Note that, even if your immutable library supports cursors, you shouldn’t use them in a Redux app. The whole state tree should be considered read-only, and you should use Redux for updating the state, and subscribing to the updates. Therefore writing via cursor doesn’t make sense for Redux. <strong>If your only use case for cursors is decoupling the state tree from the UI tree and gradually refining the cursors, you should look at selectors instead.</strong> Selectors are composable getter functions. See <a href=\"http://github.com/faassen/reselect\" target=\"_blank\">reselect</a> for a really great and concise implementation of composable selectors.</p> <h3 id=\"baobab\">Baobab</h3> <p><a href=\"https://github.com/Yomguithereal/baobab\" target=\"_blank\">Baobab</a> is another popular library implementing immutable API for updating plain JavaScript objects. While you can use it with Redux, there is little benefit in using them together.</p> <p>Most of the functionality Baobab provides is related to updating the data with cursors, but Redux enforces that the only way to update the data is to dispatch an action. Therefore they solve the same problem differently, and don’t complement each other.</p> <p>Unlike Immutable, Baobab doesn’t yet implement any special efficient data structures under the hood, so you don’t really win anything from using it together with Redux. It’s easier to just use plain objects in this case.</p> <h3 id=\"rx\">Rx</h3> <p><a href=\"https://github.com/Reactive-Extensions/RxJS\" target=\"_blank\">Reactive Extensions</a> (and their undergoing <a href=\"https://github.com/ReactiveX/RxJS\" target=\"_blank\">modern rewrite</a>) are a superb way to manage the complexity of asynchronous apps. In fact <a href=\"http://cycle.js.org\" target=\"_blank\">there is an effort to create a library that models human-computer interaction as interdependent observables</a>.</p> <p>Does it make sense to use Redux together with Rx? Sure! They work great together. For example, it is easy to expose a Redux store as an observable:</p> <pre data-language=\"js\">function toObservable(store) {\n  return {\n    subscribe({ onNext }) {\n      let dispose = store.subscribe(() =&gt; onNext(store.getState()))\n      onNext(store.getState())\n      return { dispose }\n    }\n  }\n}\n</pre> <p>Similarly, you can compose different asynchronous streams to turn them into actions before feeding them to <code>store.dispatch()</code>.</p> <p>The question is: do you really need Redux if you already use Rx? Maybe not. It’s not hard to <a href=\"https://github.com/jas-chen/rx-redux\" target=\"_blank\">re-implement Redux in Rx</a>. Some say it’s a two-liner using Rx <code>.scan()</code> method. It may very well be!</p> <p>If you’re in doubt, check out the Redux source code (there isn’t much going on there), as well as its ecosystem (for example, <a href=\"https://github.com/gaearon/redux-devtools\" target=\"_blank\">the developer tools</a>). If you don’t care too much about it and want to go with the reactive data flow all the way, you might want to explore something like <a href=\"http://cycle.js.org\" target=\"_blank\">Cycle</a> instead, or even combine it with Redux. Let us know how it goes!</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/introduction/PriorArt.html\" class=\"_attribution-link\">http://redux.js.org/docs/introduction/PriorArt.html</a>\n  </p>\n</div>\n","introduction/ecosystem":"<h1 id=\"ecosystem\">Ecosystem</h1> <p>Redux is a tiny library, but its contracts and APIs are carefully chosen to spawn an ecosystem of tools and extensions.</p> <p>For an extensive list of everything related to Redux, we recommend <a href=\"https://github.com/xgrommx/awesome-redux\" target=\"_blank\">Awesome Redux</a>. It contains examples, boilerplates, middleware, utility libraries, and more. <a href=\"https://github.com/markerikson/react-redux-links\" target=\"_blank\">React/Redux Links</a> contains tutorials and other useful resources for anyone learning React or Redux, and <a href=\"https://github.com/markerikson/redux-ecosystem-links\" target=\"_blank\">Redux Ecosystem Links</a> lists many Redux-related libraries and addons.</p> <p>On this page we will only feature a few of them that the Redux maintainers have vetted personally. Don’t let this discourage you from trying the rest of them! The ecosystem is growing too fast, and we have a limited time to look at everything. Consider these the “staff picks”, and don’t hesitate to submit a PR if you’ve built something wonderful with Redux.</p> <h2 id=\"learning-redux\">Learning Redux</h2> <h3 id=\"screencasts\">Screencasts</h3> <ul> <li>\n<strong><a href=\"https://egghead.io/series/getting-started-with-redux\" target=\"_blank\">Getting Started with Redux</a></strong> — Learn the basics of Redux directly from its creator (30 free videos)</li> <li>\n<strong><a href=\"https://learnredux.com\" target=\"_blank\">Learn Redux</a></strong> — Build a simple photo app that will simplify the core ideas behind Redux, React Router and React.js</li> </ul> <h3 id=\"example-apps\">Example Apps</h3> <ul> <li>\n<a href=\"examples\">Official Examples</a> — A few official examples covering different Redux techniques</li> <li>\n<a href=\"https://github.com/andrewngu/sound-redux\" target=\"_blank\">SoundRedux</a> — A SoundCloud client built with Redux</li> <li>\n<a href=\"https://github.com/mohebifar/grafgiti\" target=\"_blank\">grafgiti</a> — Create graffity on your GitHub contributions wall</li> </ul> <h3 id=\"tutorials-and-articles\">Tutorials and Articles</h3> <ul> <li><a href=\"https://github.com/happypoulp/redux-tutorial\" target=\"_blank\">Redux Tutorial</a></li> <li><a href=\"https://github.com/tayiorbeii/egghead.io_redux_course_notes\" target=\"_blank\">Redux Egghead Course Notes</a></li> <li><a href=\"http://makeitopen.com/tutorials/building-the-f8-app/data/\" target=\"_blank\">Integrating Data with React Native</a></li> <li><a href=\"https://blog.andyet.com/2015/08/06/what-the-flux-lets-redux\" target=\"_blank\">What the Flux?! Let’s Redux.</a></li> <li><a href=\"https://css-tricks.com/learning-react-redux/\" target=\"_blank\">Leveling Up with React: Redux</a></li> <li><a href=\"https://code-cartoons.com/a-cartoon-intro-to-redux-3afb775501a6\" target=\"_blank\">A cartoon intro to Redux</a></li> <li><a href=\"http://www.youhavetolearncomputers.com/blog/2015/9/15/a-conceptual-overview-of-redux-or-how-i-fell-in-love-with-a-javascript-state-container\" target=\"_blank\">Understanding Redux</a></li> <li><a href=\"https://medium.com/@bananaoomarang/handcrafting-an-isomorphic-redux-application-with-love-40ada4468af4\" target=\"_blank\">Handcrafting an Isomorphic Redux Application (With Love)</a></li> <li><a href=\"http://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html\" target=\"_blank\">Full-Stack Redux Tutorial</a></li> <li><a href=\"http://www.theodo.fr/blog/2016/03/getting-started-with-react-redux-and-immutable-a-test-driven-tutorial-part-2/\" target=\"_blank\">Getting Started with React, Redux, and Immutable</a></li> <li><a href=\"https://auth0.com/blog/2016/01/04/secure-your-react-and-redux-app-with-jwt-authentication/\" target=\"_blank\">Secure Your React and Redux App with JWT Authentication</a></li> <li><a href=\"https://medium.com/@meagle/understanding-87566abcfb7a\" target=\"_blank\">Understanding Redux Middleware</a></li> <li><a href=\"https://medium.com/google-developer-experts/angular-2-introduction-to-redux-1cf18af27e6e\" target=\"_blank\">Angular 2 — Introduction to Redux</a></li> <li><a href=\"https://medium.com/apollo-stack/apollo-client-graphql-with-react-and-redux-49b35d0f2641\" target=\"_blank\">Apollo Client: GraphQL with React and Redux</a></li> <li><a href=\"https://shift.infinite.red/using-redux-saga-to-simplify-your-growing-react-native-codebase-2b8036f650de\" target=\"_blank\">Using redux-saga To Simplify Your Growing React Native Codebase</a></li> <li><a href=\"http://joelhooks.com/blog/2016/03/20/build-an-image-gallery-using-redux-saga\" target=\"_blank\">Build an Image Gallery Using Redux Saga</a></li> <li><a href=\"https://www.gitbook.com/book/maxfarseer/redux-course-ru/details\" target=\"_blank\">Working with VK API (in Russian)</a></li> </ul> <h3 id=\"talks\">Talks</h3> <ul> <li>\n<a href=\"http://youtube.com/watch?v=xsSnOQynTHs\" target=\"_blank\">Live React: Hot Reloading and Time Travel</a> — See how constraints enforced by Redux make hot reloading with time travel easy</li> <li>\n<a href=\"https://www.youtube.com/watch?v=qUlRpybs7_c\" target=\"_blank\">Cleaning the Tar: Using React within the Firefox Developer Tools</a> — Learn how to gradually migrate existing MVC applications to Redux</li> <li>\n<a href=\"https://www.youtube.com/watch?v=okdC5gcD-dM\" target=\"_blank\">Redux: Simplifying Application State</a> — An intro to Redux architecture</li> </ul> <h2 id=\"using-redux\">Using Redux</h2> <h3 id=\"bindings\">Bindings</h3> <ul> <li>\n<a href=\"https://github.com/gaearon/react-redux\" target=\"_blank\">react-redux</a> — React</li> <li>\n<a href=\"https://github.com/wbuchwalter/ng-redux\" target=\"_blank\">ng-redux</a> — Angular</li> <li>\n<a href=\"https://github.com/wbuchwalter/ng2-redux\" target=\"_blank\">ng2-redux</a> — Angular 2</li> <li>\n<a href=\"https://github.com/redbooth/backbone-redux\" target=\"_blank\">backbone-redux</a> — Backbone</li> <li>\n<a href=\"https://github.com/ekosz/redux-falcor\" target=\"_blank\">redux-falcor</a> — Falcor</li> <li>\n<a href=\"https://github.com/troch/deku-redux\" target=\"_blank\">deku-redux</a> — Deku</li> </ul> <h3 id=\"middleware\">Middleware</h3> <ul> <li>\n<a href=\"http://github.com/gaearon/redux-thunk\" target=\"_blank\">redux-thunk</a> — The easiest way to write async action creators</li> <li>\n<a href=\"https://github.com/acdlite/redux-promise\" target=\"_blank\">redux-promise</a> — <a href=\"https://github.com/acdlite/flux-standard-action\" target=\"_blank\">FSA</a>-compliant promise middleware</li> <li>\n<a href=\"https://github.com/svrcekmichal/redux-axios-middleware\" target=\"_blank\">redux-axios-middleware</a> — Redux middleware for fetching data with axios HTTP client</li> <li>\n<a href=\"https://github.com/blesh/redux-observable/\" target=\"_blank\">redux-observable</a> — RxJS middleware for Redux</li> <li>\n<a href=\"https://github.com/acdlite/redux-rx\" target=\"_blank\">redux-rx</a> — RxJS utilities for Redux, including a middleware for Observable</li> <li>\n<a href=\"https://github.com/fcomb/redux-logger\" target=\"_blank\">redux-logger</a> — Log every Redux action and the next state</li> <li>\n<a href=\"https://github.com/leoasis/redux-immutable-state-invariant\" target=\"_blank\">redux-immutable-state-invariant</a> — Warns about state mutations in development</li> <li>\n<a href=\"https://github.com/socialtables/redux-unhandled-action\" target=\"_blank\">redux-unhandled-action</a> — Warns about actions that produced no state changes in development</li> <li>\n<a href=\"https://github.com/markdalgleish/redux-analytics\" target=\"_blank\">redux-analytics</a> — Analytics middleware for Redux</li> <li>\n<a href=\"https://github.com/weo-edu/redux-gen\" target=\"_blank\">redux-gen</a> — Generator middleware for Redux</li> <li>\n<a href=\"https://github.com/yelouafi/redux-saga\" target=\"_blank\">redux-saga</a> — An alternative side effect model for Redux apps</li> <li>\n<a href=\"https://github.com/cerebral/redux-action-tree\" target=\"_blank\">redux-action-tree</a> — Composable Cerebral-style signals for Redux</li> <li>\n<a href=\"https://github.com/apollostack/apollo-client\" target=\"_blank\">apollo-client</a> — A simple caching client for any GraphQL server and UI framework built on top of Redux</li> </ul> <h3 id=\"routing\">Routing</h3> <ul> <li>\n<a href=\"https://github.com/reactjs/react-router-redux\" target=\"_blank\">react-router-redux</a> — Ruthlessly simple bindings to keep React Router and Redux in sync</li> <li>\n<a href=\"https://github.com/markdalgleish/redial\" target=\"_blank\">redial</a> — Universal data fetching and route lifecycle management for React that works great with Redux</li> </ul> <h3 id=\"components\">Components</h3> <ul> <li>\n<a href=\"https://github.com/erikras/redux-form\" target=\"_blank\">redux-form</a> — Keep React form state in Redux</li> <li>\n<a href=\"https://github.com/davidkpiano/react-redux-form\" target=\"_blank\">react-redux-form</a> — Create forms easily in React with Redux</li> </ul> <h3 id=\"enhancers\">Enhancers</h3> <ul> <li>\n<a href=\"https://github.com/tappleby/redux-batched-subscribe\" target=\"_blank\">redux-batched-subscribe</a> — Customize batching and debouncing calls to the store subscribers</li> <li>\n<a href=\"https://github.com/johanneslumpe/redux-history-transitions\" target=\"_blank\">redux-history-transitions</a> — History transitions based on arbitrary actions</li> <li>\n<a href=\"https://github.com/ForbesLindesay/redux-optimist\" target=\"_blank\">redux-optimist</a> — Optimistically apply actions that can be later committed or reverted</li> <li>\n<a href=\"https://github.com/mattkrick/redux-optimistic-ui\" target=\"_blank\">redux-optimistic-ui</a> — A reducer enhancer to enable type-agnostic optimistic updates</li> <li>\n<a href=\"https://github.com/omnidan/redux-undo\" target=\"_blank\">redux-undo</a> — Effortless undo/redo and action history for your reducers</li> <li>\n<a href=\"https://github.com/omnidan/redux-ignore\" target=\"_blank\">redux-ignore</a> — Ignore redux actions by array or filter function</li> <li>\n<a href=\"https://github.com/omnidan/redux-recycle\" target=\"_blank\">redux-recycle</a> — Reset the redux state on certain actions</li> <li>\n<a href=\"https://github.com/tshelburne/redux-batched-actions\" target=\"_blank\">redux-batched-actions</a> — Dispatch several actions with a single subscriber notification</li> <li>\n<a href=\"https://github.com/treasure-data/redux-search\" target=\"_blank\">redux-search</a> — Automatically index resources in a web worker and search them without blocking</li> <li>\n<a href=\"https://github.com/samiskin/redux-electron-store\" target=\"_blank\">redux-electron-store</a> — Store enhancers that synchronize Redux stores across Electron processes</li> <li>\n<a href=\"https://github.com/raisemarketplace/redux-loop\" target=\"_blank\">redux-loop</a> — Sequence effects purely and naturally by returning them from your reducers</li> <li>\n<a href=\"https://github.com/salsita/redux-side-effects\" target=\"_blank\">redux-side-effects</a> — Utilize Generators for declarative yielding of side effects from your pure reducers</li> </ul> <h3 id=\"utilities\">Utilities</h3> <ul> <li>\n<a href=\"https://github.com/faassen/reselect\" target=\"_blank\">reselect</a> — Efficient derived data selectors inspired by NuclearJS</li> <li>\n<a href=\"https://github.com/gaearon/normalizr\" target=\"_blank\">normalizr</a> — Normalize nested API responses for easier consumption by the reducers</li> <li>\n<a href=\"https://github.com/acdlite/redux-actions\" target=\"_blank\">redux-actions</a> — Reduces the boilerplate in writing reducers and action creators</li> <li>\n<a href=\"https://github.com/pauldijou/redux-act\" target=\"_blank\">redux-act</a> — An opinionated library for making reducers and action creators</li> <li>\n<a href=\"https://github.com/acdlite/redux-transducers\" target=\"_blank\">redux-transducers</a> — Transducer utilities for Redux</li> <li>\n<a href=\"https://github.com/gajus/redux-immutable\" target=\"_blank\">redux-immutable</a> — Used to create an equivalent function of Redux <code>combineReducers</code> that works with <a href=\"https://facebook.github.io/immutable-js/\" target=\"_blank\">Immutable.js</a> state.</li> <li>\n<a href=\"https://github.com/gcanti/redux-tcomb\" target=\"_blank\">redux-tcomb</a> — Immutable and type-checked state and actions for Redux</li> <li>\n<a href=\"https://github.com/arnaudbenard/redux-mock-store\" target=\"_blank\">redux-mock-store</a> — Mock redux store for testing your app</li> <li>\n<a href=\"https://github.com/dmitry-zaets/redux-actions-assertions\" target=\"_blank\">redux-actions-assertions</a> — Assertions for Redux actions testing</li> </ul> <h3 id=\"devtools\">DevTools</h3> <ul> <li>\n<a href=\"http://github.com/gaearon/redux-devtools\" target=\"_blank\">Redux DevTools</a> — An action logger with time travel UI, hot reloading and error handling for the reducers, <a href=\"https://www.youtube.com/watch?v=xsSnOQynTHs\" target=\"_blank\">first demoed at React Europe</a>\n</li> <li>\n<a href=\"https://github.com/zalmoxisus/redux-devtools-extension\" target=\"_blank\">Redux DevTools Extension</a> — A Chrome extension wrapping Redux DevTools and providing additional functionality</li> </ul> <h3 id=\"devtools-monitors\">DevTools Monitors</h3> <ul> <li>\n<a href=\"https://github.com/gaearon/redux-devtools-log-monitor\" target=\"_blank\">Log Monitor</a> — The default monitor for Redux DevTools with a tree view</li> <li>\n<a href=\"https://github.com/gaearon/redux-devtools-dock-monitor\" target=\"_blank\">Dock Monitor</a> — A resizable and movable dock for Redux DevTools monitors</li> <li>\n<a href=\"https://github.com/calesce/redux-slider-monitor\" target=\"_blank\">Slider Monitor</a> — A custom monitor for Redux DevTools to replay recorded Redux actions</li> <li>\n<a href=\"https://github.com/alexkuz/redux-devtools-inspector\" target=\"_blank\">Inspector</a> — A custom monitor for Redux DevTools that lets you filter actions, inspect diffs, and pin deep paths in the state to observe their changes</li> <li>\n<a href=\"https://github.com/whetstone/redux-devtools-diff-monitor\" target=\"_blank\">Diff Monitor</a> — A monitor for Redux Devtools that diffs the Redux store mutations between actions</li> <li>\n<a href=\"https://github.com/bvaughn/redux-devtools-filterable-log-monitor/\" target=\"_blank\">Filterable Log Monitor</a> — Filterable tree view monitor for Redux DevTools</li> <li>\n<a href=\"https://github.com/romseguy/redux-devtools-chart-monitor\" target=\"_blank\">Chart Monitor</a> — A chart monitor for Redux DevTools</li> <li>\n<a href=\"https://github.com/zalmoxisus/redux-devtools-filter-actions\" target=\"_blank\">Filter Actions</a> — Redux DevTools composable monitor with the ability to filter actions</li> </ul> <h3 id=\"community-conventions\">Community Conventions</h3> <ul> <li>\n<a href=\"https://github.com/acdlite/flux-standard-action\" target=\"_blank\">Flux Standard Action</a> — A human-friendly standard for Flux action objects</li> <li>\n<a href=\"https://github.com/gajus/canonical-reducer-composition\" target=\"_blank\">Canonical Reducer Composition</a> — An opinionated standard for nested reducer composition</li> <li>\n<a href=\"https://github.com/erikras/ducks-modular-redux\" target=\"_blank\">Ducks: Redux Reducer Bundles</a> — A proposal for bundling reducers, action types and actions</li> </ul> <h3 id=\"translations\">Translations</h3> <ul> <li>\n<a href=\"http://camsong.github.io/redux-in-chinese/\" target=\"_blank\">中文文档</a> — Chinese</li> <li>\n<a href=\"https://github.com/chentsulin/redux\" target=\"_blank\">繁體中文文件</a> — Traditional Chinese</li> <li>\n<a href=\"https://github.com/rajdee/redux-in-russian\" target=\"_blank\">Redux in Russian</a> — Russian</li> <li>\n<a href=\"http://es.redux.js.org/\" target=\"_blank\">Redux en Español</a> - Spanish</li> </ul> <h2 id=\"more\">More</h2> <p><a href=\"https://github.com/xgrommx/awesome-redux\" target=\"_blank\">Awesome Redux</a> is an extensive list of Redux-related repositories.<br><a href=\"https://github.com/markerikson/react-redux-links\" target=\"_blank\">React-Redux Links</a> is a curated list of high-quality articles, tutorials, and related content for React, Redux, ES6, and more.<br><a href=\"https://github.com/markerikson/redux-ecosystem-links\" target=\"_blank\">Redux Ecosystem Links</a> is a categorized collection of Redux-related libraries, addons, and utilities.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/introduction/Ecosystem.html\" class=\"_attribution-link\">http://redux.js.org/docs/introduction/Ecosystem.html</a>\n  </p>\n</div>\n","basics/actions":"<h1 id=\"actions\">Actions</h1> <p>First, let’s define some actions.</p> <p><strong>Actions</strong> are payloads of information that send data from your application to your store. They are the <em>only</em> source of information for the store. You send them to the store using <a href=\"../api/store#dispatch\"><code>store.dispatch()</code></a>.</p> <p>Here’s an example action which represents adding a new todo item:</p> <pre data-language=\"js\">const ADD_TODO = 'ADD_TODO'\n</pre> <pre data-language=\"js\">{\n  type: ADD_TODO,\n  text: 'Build my first Redux app'\n}\n</pre> <p>Actions are plain JavaScript objects. Actions must have a <code>type</code> property that indicates the type of action being performed. Types should typically be defined as string constants. Once your app is large enough, you may want to move them into a separate module.</p> <pre data-language=\"js\">import { ADD_TODO, REMOVE_TODO } from '../actionTypes'\n</pre> <blockquote> <h5 id=\"note-on-boilerplate\">Note on Boilerplate</h5> <p>You don’t have to define action type constants in a separate file, or even to define them at all. For a small project, it might be easier to just use string literals for action types. However, there are some benefits to explicitly declaring constants in larger codebases. Read <a href=\"../recipes/reducingboilerplate\">Reducing Boilerplate</a> for more practical tips on keeping your codebase clean.</p> </blockquote> <p>Other than <code>type</code>, the structure of an action object is really up to you. If you’re interested, check out <a href=\"https://github.com/acdlite/flux-standard-action\" target=\"_blank\">Flux Standard Action</a> for recommendations on how actions could be constructed.</p> <p>We’ll add one more action type to describe a user ticking off a todo as completed. We refer to a particular todo by <code>index</code> because we store them in an array. In a real app, it is wiser to generate a unique ID every time something new is created.</p> <pre data-language=\"js\">{\n  type: TOGGLE_TODO,\n  index: 5\n}\n</pre> <p>It’s a good idea to pass as little data in each action as possible. For example, it’s better to pass <code>index</code> than the whole todo object.</p> <p>Finally, we’ll add one more action type for changing the currently visible todos.</p> <pre data-language=\"js\">{\n  type: SET_VISIBILITY_FILTER,\n  filter: SHOW_COMPLETED\n}\n</pre> <h2 id=\"action-creators\">Action Creators</h2> <p><strong>Action creators</strong> are exactly that—functions that create actions. It's easy to conflate the terms “action” and “action creator,” so do your best to use the proper term.</p> <p>In Redux action creators simply return an action:</p> <pre data-language=\"js\">function addTodo(text) {\n  return {\n    type: ADD_TODO,\n    text\n  }\n}\n</pre> <p>This makes them portable and easy to test.</p> <p>In <a href=\"http://facebook.github.io/flux\" target=\"_blank\">traditional Flux</a> action creators often trigger a dispatch when invoked, like so:</p> <pre data-language=\"js\">function addTodoWithDispatch(text) {\n  const action = {\n    type: ADD_TODO,\n    text\n  }\n  dispatch(action)\n}\n</pre> <p>In Redux this is <em>not</em> the case.<br>Instead, to actually initiate a dispatch, pass the result to the <code>dispatch()</code> function:</p> <pre data-language=\"js\">dispatch(addTodo(text))\ndispatch(completeTodo(index))\n</pre> <p>Alternatively, you can create a <strong>bound action creator</strong> that automatically dispatches:</p> <pre data-language=\"js\">const boundAddTodo = (text) =&gt; dispatch(addTodo(text))\nconst boundCompleteTodo = (index) =&gt; dispatch(completeTodo(index))\n</pre> <p>Now you’ll be able to call them directly:</p> <pre>boundAddTodo(text)\nboundCompleteTodo(index)\n</pre>\n<p>The <code>dispatch()</code> function can be accessed directly from the store as <a href=\"../api/store#dispatch\"><code>store.dispatch()</code></a>, but more likely you'll access it using a helper like <a href=\"http://github.com/gaearon/react-redux\" target=\"_blank\">react-redux</a>'s <code>connect()</code>. You can use <a href=\"../api/bindactioncreators\"><code>bindActionCreators()</code></a> to automatically bind many action creators to a <code>dispatch()</code> function.</p> <p>Action creators can also be asynchronous and have side-effects. You can read about <a href=\"../advanced/asyncactions\">async actions</a> in the <a href=\"../advanced/index\">advanced tutorial</a> to learn how to handle AJAX responses and compose action creators into async control flow. Don’t skip ahead to async actions until you’ve completed the basics tutorial, as it covers other important concepts that are prerequisite for the advanced tutorial and async actions.</p> <h2 id=\"source-code\">Source Code</h2> <h3 id=\"-actions-js\"><code>actions.js</code></h3> <pre data-language=\"js\">/*\n * action types\n */\n\nexport const ADD_TODO = 'ADD_TODO'\nexport const TOGGLE_TODO = 'TOGGLE_TODO'\nexport const SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER'\n\n/*\n * other constants\n */\n\nexport const VisibilityFilters = {\n  SHOW_ALL: 'SHOW_ALL',\n  SHOW_COMPLETED: 'SHOW_COMPLETED',\n  SHOW_ACTIVE: 'SHOW_ACTIVE'\n}\n\n/*\n * action creators\n */\n\nexport function addTodo(text) {\n  return { type: ADD_TODO, text }\n}\n\nexport function toggleTodo(index) {\n  return { type: TOGGLE_TODO, index }\n}\n\nexport function setVisibilityFilter(filter) {\n  return { type: SET_VISIBILITY_FILTER, filter }\n}\n</pre> <h2 id=\"next-steps\">Next Steps</h2> <p>Now let’s <a href=\"reducers\">define some reducers</a> to specify how the state updates when you dispatch these actions!</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/basics/Actions.html\" class=\"_attribution-link\">http://redux.js.org/docs/basics/Actions.html</a>\n  </p>\n</div>\n","basics/store":"<h1 id=\"store\">Store</h1> <p>In the previous sections, we defined the <a href=\"actions\">actions</a> that represent the facts about “what happened” and the <a href=\"reducers\">reducers</a> that update the state according to those actions.</p> <p>The <strong>Store</strong> is the object that brings them together. The store has the following responsibilities:</p> <ul> <li>Holds application state;</li> <li>Allows access to state via <a href=\"../api/store#getState\"><code>getState()</code></a>;</li> <li>Allows state to be updated via <a href=\"../api/store#dispatch\"><code>dispatch(action)</code></a>;</li> <li>Registers listeners via <a href=\"../api/store#subscribe\"><code>subscribe(listener)</code></a>;</li> <li>Handles unregistering of listeners via the function returned by <a href=\"../api/store#subscribe\"><code>subscribe(listener)</code></a>.</li> </ul> <p>It’s important to note that you’ll only have a single store in a Redux application. When you want to split your data handling logic, you’ll use <a href=\"reducers#splitting-reducers\">reducer composition</a> instead of many stores.</p> <p>It’s easy to create a store if you have a reducer. In the <a href=\"reducers\">previous section</a>, we used <a href=\"../api/combinereducers\"><code>combineReducers()</code></a> to combine several reducers into one. We will now import it, and pass it to <a href=\"../api/createstore\"><code>createStore()</code></a>.</p> <pre data-language=\"js\">import { createStore } from 'redux'\nimport todoApp from './reducers'\nlet store = createStore(todoApp)\n</pre> <p>You may optionally specify the initial state as the second argument to <a href=\"../api/createstore\"><code>createStore()</code></a>. This is useful for hydrating the state of the client to match the state of a Redux application running on the server.</p> <pre data-language=\"js\">let store = createStore(todoApp, window.STATE_FROM_SERVER)\n</pre> <h2 id=\"dispatching-actions\">Dispatching Actions</h2> <p>Now that we have created a store, let’s verify our program works! Even without any UI, we can already test the update logic.</p> <pre data-language=\"js\">import { addTodo, toggleTodo, setVisibilityFilter, VisibilityFilters } from './actions'\n\n// Log the initial state\nconsole.log(store.getState())\n\n// Every time the state changes, log it\n// Note that subscribe() returns a function for unregistering the listener\nlet unsubscribe = store.subscribe(() =&gt;\n  console.log(store.getState())\n)\n\n// Dispatch some actions\nstore.dispatch(addTodo('Learn about actions'))\nstore.dispatch(addTodo('Learn about reducers'))\nstore.dispatch(addTodo('Learn about store'))\nstore.dispatch(toggleTodo(0))\nstore.dispatch(toggleTodo(1))\nstore.dispatch(setVisibilityFilter(VisibilityFilters.SHOW_COMPLETED))\n\n// Stop listening to state updates\nunsubscribe()\n</pre> <p>You can see how this causes the state held by the store to change:</p> <p><img src=\"http://i.imgur.com/zMMtoMz.png\" width=\"70%\"></p> <p>We specified the behavior of our app before we even started writing the UI. We won’t do this in this tutorial, but at this point you can write tests for your reducers and action creators. You won’t need to mock anything because they are just functions. Call them, and make assertions on what they return.</p> <h2 id=\"source-code\">Source Code</h2> <h4 id=\"-index-js\"><code>index.js</code></h4> <pre data-language=\"js\">import { createStore } from 'redux'\nimport todoApp from './reducers'\n\nlet store = createStore(todoApp)\n</pre> <h2 id=\"next-steps\">Next Steps</h2> <p>Before creating a UI for our todo app, we will take a detour to see <a href=\"dataflow\">how the data flows in a Redux application</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/basics/Store.html\" class=\"_attribution-link\">http://redux.js.org/docs/basics/Store.html</a>\n  </p>\n</div>\n","basics/dataflow":"<h1 id=\"data-flow\">Data Flow</h1> <p>Redux architecture revolves around a <strong>strict unidirectional data flow</strong>.</p> <p>This means that all data in an application follows the same lifecycle pattern, making the logic of your app more predictable and easier to understand. It also encourages data normalization, so that you don't end up with multiple, independent copies of the same data that are unaware of one another.</p> <p>If you're still not convinced, read <a href=\"../introduction/motivation\">Motivation</a> and <a href=\"https://medium.com/@dan_abramov/the-case-for-flux-379b7d1982c6\" target=\"_blank\">The Case for Flux</a> for a compelling argument in favor of unidirectional data flow. Although <a href=\"../introduction/priorart\">Redux is not exactly Flux</a>, it shares the same key benefits.</p> <p>The data lifecycle in any Redux app follows these 4 steps:</p> <ol> <li>\n<p><strong>You call</strong> <a href=\"../api/store#dispatch\"><code>store.dispatch(action)</code></a>.</p> <p>An <a href=\"actions\">action</a> is a plain object describing <em>what happened</em>. For example:</p> <pre data-language=\"js\"> { type: 'LIKE_ARTICLE', articleId: 42 }\n { type: 'FETCH_USER_SUCCESS', response: { id: 3, name: 'Mary' } }\n { type: 'ADD_TODO', text: 'Read the Redux docs.' }\n</pre> <p>Think of an action as a very brief snippet of news. “Mary liked article 42.” or “‘Read the Redux docs.’ was added to the list of todos.”</p> <p>You can call <a href=\"../api/store#dispatch\"><code>store.dispatch(action)</code></a> from anywhere in your app, including components and XHR callbacks, or even at scheduled intervals.</p> </li> <li>\n<p><strong>The Redux store calls the reducer function you gave it.</strong></p> <p>The <a href=\"store\">store</a> will pass two arguments to the <a href=\"reducers\">reducer</a>: the current state tree and the action. For example, in the todo app, the root reducer might receive something like this:</p> <pre data-language=\"js\"> // The current application state (list of todos and chosen filter)\n let previousState = {\n   visibleTodoFilter: 'SHOW_ALL',\n   todos: [ \n     {\n       text: 'Read the docs.',\n       complete: false\n     }\n   ]\n }\n\n // The action being performed (adding a todo)\n let action = {\n   type: 'ADD_TODO',\n   text: 'Understand the flow.'\n }\n\n // Your reducer returns the next application state\n let nextState = todoApp(previousState, action)\n</pre> <p> Note that a reducer is a pure function. It only <em>computes</em> the next state. It should be completely predictable: calling it with the same inputs many times should produce the same outputs. It shouldn’t perform any side effects like API calls or router transitions. These should happen before an action is dispatched.</p> </li> <li>\n<p><strong>The root reducer may combine the output of multiple reducers into a single state tree.</strong></p> <p>How you structure the root reducer is completely up to you. Redux ships with a <a href=\"../api/combinereducers\"><code>combineReducers()</code></a> helper function, useful for “splitting” the root reducer into separate functions that each manage one branch of the state tree.</p> <p>Here’s how <a href=\"../api/combinereducers\"><code>combineReducers()</code></a> works. Let’s say you have two reducers, one for a list of todos, and another for the currently selected filter setting:</p> <pre data-language=\"js\"> function todos(state = [], action) {\n   // Somehow calculate it...\n   return nextState\n }\n\n function visibleTodoFilter(state = 'SHOW_ALL', action) {\n   // Somehow calculate it...\n   return nextState\n }\n\n let todoApp = combineReducers({\n   todos,\n   visibleTodoFilter\n })\n</pre> <p>When you emit an action, <code>todoApp</code> returned by <code>combineReducers</code> will call both reducers:</p> <pre data-language=\"js\"> let nextTodos = todos(state.todos, action)\n let nextVisibleTodoFilter = visibleTodoFilter(state.visibleTodoFilter, action)\n</pre> <p>It will then combine both sets of results into a single state tree:</p> <pre data-language=\"js\"> return {\n   todos: nextTodos,\n   visibleTodoFilter: nextVisibleTodoFilter\n }\n</pre> <p>While <a href=\"../api/combinereducers\"><code>combineReducers()</code></a> is a handy helper utility, you don’t have to use it; feel free to write your own root reducer!</p> </li> <li>\n<p><strong>The Redux store saves the complete state tree returned by the root reducer.</strong></p> <p>This new tree is now the next state of your app! Every listener registered with <a href=\"../api/store#subscribe\"><code>store.subscribe(listener)</code></a> will now be invoked; listeners may call <a href=\"../api/store#getState\"><code>store.getState()</code></a> to get the current state.</p> <p>Now, the UI can be updated to reflect the new state. If you use bindings like <a href=\"https://github.com/gaearon/react-redux\" target=\"_blank\">React Redux</a>, this is the point at which <code>component.setState(newState)</code> is called.</p> </li> </ol> <h2 id=\"next-steps\">Next Steps</h2> <p>Now that you know how Redux works, let’s <a href=\"usagewithreact\">connect it to a React app</a>.</p> <blockquote> <h5 id=\"note-for-advanced-users\">Note for Advanced Users</h5> <p>If you’re already familiar with the basic concepts and have previously completed this tutorial, don’t forget to check out <a href=\"../advanced/asyncflow\">async flow</a> in the <a href=\"../advanced/index\">advanced tutorial</a> to learn how middleware transforms <a href=\"../advanced/asyncactions\">async actions</a> before they reach the reducer.</p> </blockquote><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/basics/DataFlow.html\" class=\"_attribution-link\">http://redux.js.org/docs/basics/DataFlow.html</a>\n  </p>\n</div>\n","basics/exampletodolist":"<h1 id=\"example-todo-list\">Example: Todo List</h1> <p>This is the complete source code of the tiny todo app we built during the <a href=\"index\">basics tutorial</a>.</p> <h2 id=\"entry-point\">Entry Point</h2> <h4 id=\"-index-js\"><code>index.js</code></h4> <pre data-language=\"js\">import React from 'react'\nimport { render } from 'react-dom'\nimport { Provider } from 'react-redux'\nimport { createStore } from 'redux'\nimport todoApp from './reducers'\nimport App from './components/App'\n\nlet store = createStore(todoApp)\n\nrender(\n  &lt;Provider store={store}&gt;\n    &lt;App /&gt;\n  &lt;/Provider&gt;,\n  document.getElementById('root')\n)\n</pre> <h2 id=\"action-creators\">Action Creators</h2> <h4 id=\"-actions-index-js\"><code>actions/index.js</code></h4> <pre data-language=\"js\">let nextTodoId = 0\nexport const addTodo = (text) =&gt; {\n  return {\n    type: 'ADD_TODO',\n    id: nextTodoId++,\n    text\n  }\n}\n\nexport const setVisibilityFilter = (filter) =&gt; {\n  return {\n    type: 'SET_VISIBILITY_FILTER',\n    filter\n  }\n}\n\nexport const toggleTodo = (id) =&gt; {\n  return {\n    type: 'TOGGLE_TODO',\n    id\n  }\n}\n</pre> <h2 id=\"reducers\">Reducers</h2> <h4 id=\"-reducers-todos-js\"><code>reducers/todos.js</code></h4> <pre data-language=\"js\">const todo = (state, action) =&gt; {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return {\n        id: action.id,\n        text: action.text,\n        completed: false\n      }\n    case 'TOGGLE_TODO':\n      if (state.id !== action.id) {\n        return state\n      }\n\n      return Object.assign({}, state, {\n        completed: !state.completed\n      })\n\n    default:\n      return state\n  }\n}\n\nconst todos = (state = [], action) =&gt; {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return [\n        ...state,\n        todo(undefined, action)\n      ]\n    case 'TOGGLE_TODO':\n      return state.map(t =&gt;\n        todo(t, action)\n      )\n    default:\n      return state\n  }\n}\n\nexport default todos\n</pre> <h4 id=\"-reducers-visibilityfilter-js\"><code>reducers/visibilityFilter.js</code></h4> <pre data-language=\"js\">const visibilityFilter = (state = 'SHOW_ALL', action) =&gt; {\n  switch (action.type) {\n    case 'SET_VISIBILITY_FILTER':\n      return action.filter\n    default:\n      return state\n  }\n}\n\nexport default visibilityFilter\n</pre> <h4 id=\"-reducers-index-js\"><code>reducers/index.js</code></h4> <pre data-language=\"js\">import { combineReducers } from 'redux'\nimport todos from './todos'\nimport visibilityFilter from './visibilityFilter'\n\nconst todoApp = combineReducers({\n  todos,\n  visibilityFilter\n})\n\nexport default todoApp\n</pre> <h2 id=\"presentational-components\">Presentational Components</h2> <h4 id=\"-components-todo-js\"><code>components/Todo.js</code></h4> <pre data-language=\"js\">import React, { PropTypes } from 'react'\n\nconst Todo = ({ onClick, completed, text }) =&gt; (\n  &lt;li\n    onClick={onClick}\n    style={{\n      textDecoration: completed ? 'line-through' : 'none'\n    }}\n  &gt;\n    {text}\n  &lt;/li&gt;\n)\n\nTodo.propTypes = {\n  onClick: PropTypes.func.isRequired,\n  completed: PropTypes.bool.isRequired,\n  text: PropTypes.string.isRequired\n}\n\nexport default Todo\n</pre> <h4 id=\"-components-todolist-js\"><code>components/TodoList.js</code></h4> <pre data-language=\"js\">import React, { PropTypes } from 'react'\nimport Todo from './Todo'\n\nconst TodoList = ({ todos, onTodoClick }) =&gt; (\n  &lt;ul&gt;\n    {todos.map(todo =&gt;\n      &lt;Todo\n        key={todo.id}\n        {...todo}\n        onClick={() =&gt; onTodoClick(todo.id)}\n      /&gt;\n    )}\n  &lt;/ul&gt;\n)\n\nTodoList.propTypes = {\n  todos: PropTypes.arrayOf(PropTypes.shape({\n    id: PropTypes.number.isRequired,\n    completed: PropTypes.bool.isRequired,\n    text: PropTypes.string.isRequired\n  }).isRequired).isRequired,\n  onTodoClick: PropTypes.func.isRequired\n}\n\nexport default TodoList\n</pre> <h4 id=\"-components-link-js\"><code>components/Link.js</code></h4> <pre data-language=\"js\">import React, { PropTypes } from 'react'\n\nconst Link = ({ active, children, onClick }) =&gt; {\n  if (active) {\n    return &lt;span&gt;{children}&lt;/span&gt;\n  }\n\n  return (\n    &lt;a href=\"#\"\n       onClick={e =&gt; {\n         e.preventDefault()\n         onClick()\n       }}\n    &gt;\n      {children}\n    &lt;/a&gt;\n  )\n}\n\nLink.propTypes = {\n  active: PropTypes.bool.isRequired,\n  children: PropTypes.node.isRequired,\n  onClick: PropTypes.func.isRequired\n}\n\nexport default Link\n</pre> <h4 id=\"-components-footer-js\"><code>components/Footer.js</code></h4> <pre data-language=\"js\">import React from 'react'\nimport FilterLink from '../containers/FilterLink'\n\nconst Footer = () =&gt; (\n  &lt;p&gt;\n    Show:\n    {\" \"}\n    &lt;FilterLink filter=\"SHOW_ALL\"&gt;\n      All\n    &lt;/FilterLink&gt;\n    {\", \"}\n    &lt;FilterLink filter=\"SHOW_ACTIVE\"&gt;\n      Active\n    &lt;/FilterLink&gt;\n    {\", \"}\n    &lt;FilterLink filter=\"SHOW_COMPLETED\"&gt;\n      Completed\n    &lt;/FilterLink&gt;\n  &lt;/p&gt;\n)\n\nexport default Footer\n</pre> <h4 id=\"-components-app-js\"><code>components/App.js</code></h4> <pre data-language=\"js\">import React from 'react'\nimport Footer from './Footer'\nimport AddTodo from '../containers/AddTodo'\nimport VisibleTodoList from '../containers/VisibleTodoList'\n\nconst App = () =&gt; (\n  &lt;div&gt;\n    &lt;AddTodo /&gt;\n    &lt;VisibleTodoList /&gt;\n    &lt;Footer /&gt;\n  &lt;/div&gt;\n)\n\nexport default App\n</pre> <h2 id=\"container-components\">Container Components</h2> <h4 id=\"-containers-visibletodolist-js\"><code>containers/VisibleTodoList.js</code></h4> <pre data-language=\"js\">import { connect } from 'react-redux'\nimport { toggleTodo } from '../actions'\nimport TodoList from '../components/TodoList'\n\nconst getVisibleTodos = (todos, filter) =&gt; {\n  switch (filter) {\n    case 'SHOW_ALL':\n      return todos\n    case 'SHOW_COMPLETED':\n      return todos.filter(t =&gt; t.completed)\n    case 'SHOW_ACTIVE':\n      return todos.filter(t =&gt; !t.completed)\n  }\n}\n\nconst mapStateToProps = (state) =&gt; {\n  return {\n    todos: getVisibleTodos(state.todos, state.visibilityFilter)\n  }\n}\n\nconst mapDispatchToProps = (dispatch) =&gt; {\n  return {\n    onTodoClick: (id) =&gt; {\n      dispatch(toggleTodo(id))\n    }\n  }\n}\n\nconst VisibleTodoList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(TodoList)\n\nexport default VisibleTodoList\n</pre> <h4 id=\"-containers-filterlink-js\"><code>containers/FilterLink.js</code></h4> <pre data-language=\"js\">import { connect } from 'react-redux'\nimport { setVisibilityFilter } from '../actions'\nimport Link from '../components/Link'\n\nconst mapStateToProps = (state, ownProps) =&gt; {\n  return {\n    active: ownProps.filter === state.visibilityFilter\n  }\n}\n\nconst mapDispatchToProps = (dispatch, ownProps) =&gt; {\n  return {\n    onClick: () =&gt; {\n      dispatch(setVisibilityFilter(ownProps.filter))\n    }\n  }\n}\n\nconst FilterLink = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Link)\n\nexport default FilterLink\n</pre> <h3 id=\"other-components\">Other Components</h3> <h4 id=\"-containers-addtodo-js\"><code>containers/AddTodo.js</code></h4> <pre data-language=\"js\">import React from 'react'\nimport { connect } from 'react-redux'\nimport { addTodo } from '../actions'\n\nlet AddTodo = ({ dispatch }) =&gt; {\n  let input\n\n  return (\n    &lt;div&gt;\n      &lt;form onSubmit={e =&gt; {\n        e.preventDefault()\n        if (!input.value.trim()) {\n          return\n        }\n        dispatch(addTodo(input.value))\n        input.value = ''\n      }}&gt;\n        &lt;input ref={node =&gt; {\n          input = node\n        }} /&gt;\n        &lt;button type=\"submit\"&gt;\n          Add Todo\n        &lt;/button&gt;\n      &lt;/form&gt;\n    &lt;/div&gt;\n  )\n}\nAddTodo = connect()(AddTodo)\n\nexport default AddTodo\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/basics/ExampleTodoList.html\" class=\"_attribution-link\">http://redux.js.org/docs/basics/ExampleTodoList.html</a>\n  </p>\n</div>\n","recipes/migratingtoredux":"<h1 id=\"migrating-to-redux\">Migrating to Redux</h1> <p>Redux is not a monolithic framework, but a set of contracts and a <a href=\"../api/index\">few functions that make them work together</a>. The majority of your “Redux code” will not even use Redux APIs, as most of the time you’ll be writing functions. </p> <p>This makes it easy to migrate both to and from Redux.<br>We don’t want to lock you in!</p> <h2 id=\"from-flux\">From Flux</h2> <p><a href=\"../glossary#reducer\">Reducers</a> capture “the essence” of Flux Stores, so it’s possible to gradually migrate an existing Flux project towards Redux, whether you are using <a href=\"http://github.com/acdlite/flummox\" target=\"_blank\">Flummox</a>, <a href=\"http://github.com/goatslacker/alt\" target=\"_blank\">Alt</a>, <a href=\"https://github.com/facebook/flux\" target=\"_blank\">traditional Flux</a>, or any other Flux library.</p> <p>It is also possible to do the reverse and migrate from Redux to any of these libraries following the same steps.</p> <p>Your process will look like this:</p> <ul> <li>\n<p>Create a function called <code>createFluxStore(reducer)</code> that creates a Flux store compatible with your existing app from a reducer function. Internally it might look similar to <a href=\"../api/createstore\"><code>createStore</code></a> (<a href=\"https://github.com/reactjs/redux/blob/master/src/createStore.js\" target=\"_blank\">source</a>) implementation from Redux. Its dispatch handler should just call the <code>reducer</code> for any action, store the next state, and emit change.</p> </li> <li>\n<p>This allows you to gradually rewrite every Flux Store in your app as a reducer, but still export <code>createFluxStore(reducer)</code> so the rest of your app is not aware that this is happening and sees the Flux stores.</p> </li> <li>\n<p>As you rewrite your Stores, you will find that you need to avoid certain Flux anti-patterns such as fetching API inside the Store, or triggering actions inside the Stores. Your Flux code will be easier to follow once you port it to be based on reducers!</p> </li> <li>\n<p>When you have ported all of your Flux Stores to be implemented on top of reducers, you can replace the Flux library with a single Redux store, and combine those reducers you already have into one using <a href=\"../api/combinereducers\"><code>combineReducers(reducers)</code></a>.</p> </li> <li>\n<p>Now all that’s left to do is to port the UI to <a href=\"../basics/usagewithreact\">use react-redux</a> or equivalent.</p> </li> <li>\n<p>Finally, you might want to begin using some Redux idioms like middleware to further simplify your asynchronous code.</p> </li> </ul> <h2 id=\"from-backbone\">From Backbone</h2> <p>Backbone’s model layer is quite different from Redux, so we don’t suggest mixing them. If possible, it is best that you rewrite your app’s model layer from scratch instead of connecting Backbone to Redux. However, if a rewrite is not feasible, you may use <a href=\"https://github.com/redbooth/backbone-redux\" target=\"_blank\">backbone-redux</a> to migrate gradually, and keep the Redux store in sync with Backbone models and collections.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/recipes/MigratingToRedux.html\" class=\"_attribution-link\">http://redux.js.org/docs/recipes/MigratingToRedux.html</a>\n  </p>\n</div>\n","basics/reducers":"<h1 id=\"reducers\">Reducers</h1> <p><a href=\"actions\">Actions</a> describe the fact that <em>something happened</em>, but don’t specify how the application’s state changes in response. This is the job of a reducer.</p> <h2 id=\"designing-the-state-shape\">Designing the State Shape</h2> <p>In Redux, all application state is stored as a single object. It’s a good idea to think of its shape before writing any code. What’s the minimal representation of your app’s state as an object?</p> <p>For our todo app, we want to store two different things:</p> <ul> <li>The currently selected visibility filter;</li> <li>The actual list of todos.</li> </ul> <p>You’ll often find that you need to store some data, as well as some UI state, in the state tree. This is fine, but try to keep the data separate from the UI state.</p> <pre data-language=\"js\">{\n  visibilityFilter: 'SHOW_ALL',\n  todos: [\n    {\n      text: 'Consider using Redux',\n      completed: true,\n    },\n    {\n      text: 'Keep all state in a single tree',\n      completed: false\n    }\n  ]\n}\n</pre> <blockquote> <h5 id=\"note-on-relationships\">Note on Relationships</h5> <p>In a more complex app, you’re going to want different entities to reference each other. We suggest that you keep your state as normalized as possible, without any nesting. Keep every entity in an object stored with an ID as a key, and use IDs to reference it from other entities, or lists. Think of the app’s state as a database. This approach is described in <a href=\"https://github.com/gaearon/normalizr\" target=\"_blank\">normalizr's</a> documentation in detail. For example, keeping <code>todosById: { id -&gt; todo }</code> and <code>todos: array<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>id</span><span class=\"token punctuation\">&gt;</span></span></code> inside the state would be a better idea in a real app, but we’re keeping the example simple.</p> </blockquote> <h2 id=\"handling-actions\">Handling Actions</h2> <p>Now that we’ve decided what our state object looks like, we’re ready to write a reducer for it. The reducer is a pure function that takes the previous state and an action, and returns the next state.</p> <pre data-language=\"js\">(previousState, action) =&gt; newState\n</pre> <p>It’s called a reducer because it’s the type of function you would pass to <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\" target=\"_blank\"><code>Array.prototype.reduce(reducer, ?initialValue)</code></a>. It’s very important that the reducer stays pure. Things you should <strong>never</strong> do inside a reducer:</p> <ul> <li>Mutate its arguments;</li> <li>Perform side effects like API calls and routing transitions;</li> <li>Call non-pure functions, e.g. <code>Date.now()</code> or <code>Math.random()</code>.</li> </ul> <p>We’ll explore how to perform side effects in the <a href=\"../advanced/index\">advanced walkthrough</a>. For now, just remember that the reducer must be pure. <strong>Given the same arguments, it should calculate the next state and return it. No surprises. No side effects. No API calls. No mutations. Just a calculation.</strong></p> <p>With this out of the way, let’s start writing our reducer by gradually teaching it to understand the <a href=\"actions\">actions</a> we defined earlier.</p> <p>We’ll start by specifying the initial state. Redux will call our reducer with an <code>undefined</code> state for the first time. This is our chance to return the initial state of our app:</p> <pre data-language=\"js\">import { VisibilityFilters } from './actions'\n\nconst initialState = {\n  visibilityFilter: VisibilityFilters.SHOW_ALL,\n  todos: []\n}\n\nfunction todoApp(state, action) {\n  if (typeof state === 'undefined') {\n    return initialState\n  }\n\n  // For now, don’t handle any actions\n  // and just return the state given to us.\n  return state\n}\n</pre> <p>One neat trick is to use the <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/default_parameters\" target=\"_blank\">ES6 default arguments syntax</a> to write this in a more compact way:</p> <pre data-language=\"js\">function todoApp(state = initialState, action) {\n  // For now, don’t handle any actions\n  // and just return the state given to us.\n  return state\n}\n</pre> <p>Now let’s handle <code>SET_VISIBILITY_FILTER</code>. All it needs to do is to change <code>visibilityFilter</code> on the state. Easy:</p> <pre data-language=\"js\">function todoApp(state = initialState, action) {\n  switch (action.type) {\n    case SET_VISIBILITY_FILTER:\n      return Object.assign({}, state, {\n        visibilityFilter: action.filter\n      })\n    default:\n      return state\n  }\n}\n</pre> <p>Note that:</p> <ol> <li>\n<p><strong>We don’t mutate the <code>state</code>.</strong> We create a copy with <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\"><code>Object.assign()</code></a>. <code>Object.assign(state, { visibilityFilter: action.filter })</code> is also wrong: it will mutate the first argument. You <strong>must</strong> supply an empty object as the first parameter. You can also enable the <a href=\"../recipes/usingobjectspreadoperator\">object spread operator proposal</a> to write <code>{ ...state, ...newState }</code> instead.</p> </li> <li>\n<p><strong>We return the previous <code>state</code> in the <code>default</code> case.</strong> It’s important to return the previous <code>state</code> for any unknown action.</p> </li> </ol> <blockquote> <h5 id=\"note-on-object-assign\">Note on <code>Object.assign</code>\n</h5> <p><a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\"><code>Object.assign()</code></a> is a part of ES6, but is not implemented by most browsers yet. You’ll need to either use a polyfill, a <a href=\"https://www.npmjs.com/package/babel-plugin-object-assign\" target=\"_blank\">Babel plugin</a>, or a helper from another library like <a href=\"https://lodash.com/docs#assign\" target=\"_blank\"><code>_.assign()</code></a>.</p> <h5 id=\"note-on-switch-and-boilerplate\">Note on <code>switch</code> and Boilerplate</h5> <p>The <code>switch</code> statement is <em>not</em> the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app). Redux solves these problems by using pure reducers instead of event emitters.</p> <p>It’s unfortunate that many still choose a framework based on whether it uses <code>switch</code> statements in the documentation. If you don’t like <code>switch</code>, you can use a custom <code>createReducer</code> function that accepts a handler map, as shown in <a href=\"../recipes/reducingboilerplate#reducers\">“reducing boilerplate”</a>.</p> </blockquote> <h2 id=\"handling-more-actions\">Handling More Actions</h2> <p>We have two more actions to handle! Let’s extend our reducer to handle <code>ADD_TODO</code>.</p> <pre data-language=\"js\">function todoApp(state = initialState, action) {\n  switch (action.type) {\n    case SET_VISIBILITY_FILTER:\n      return Object.assign({}, state, {\n        visibilityFilter: action.filter\n      })\n    case ADD_TODO:\n      return Object.assign({}, state, {\n        todos: [\n          ...state.todos,\n          {\n            text: action.text,\n            completed: false\n          }\n        ]\n      })    \n    default:\n      return state\n  }\n}\n</pre> <p>Just like before, we never write directly to <code>state</code> or its fields, and instead we return new objects. The new <code>todos</code> is equal to the old <code>todos</code> concatenated with a single new item at the end. The fresh todo was constructed using the data from the action.</p> <p>Finally, the implementation of the <code>TOGGLE_TODO</code> handler shouldn’t come as a complete surprise:</p> <pre data-language=\"js\">case TOGGLE_TODO:\n  return Object.assign({}, state, {\n    todos: state.todos.map((todo, index) =&gt; {\n      if (index === action.index) {\n        return Object.assign({}, todo, {\n          completed: !todo.completed\n        })\n      }\n      return todo\n    })\n  })\n</pre> <p>Because we want to update a specific item in the array without resorting to mutations, we have to create a new array with the same items except the item at the index. If you find yourself often writing such operations, it’s a good idea to use a helper like <a href=\"https://facebook.github.io/react/docs/update.html\" target=\"_blank\">react-addons-update</a>, <a href=\"https://github.com/substantial/updeep\" target=\"_blank\">updeep</a>, or even a library like <a href=\"http://facebook.github.io/immutable-js/\" target=\"_blank\">Immutable</a> that has native support for deep updates. Just remember to never assign to anything inside the <code>state</code> unless you clone it first.</p> <h2 id=\"splitting-reducers\">Splitting Reducers</h2> <p>Here is our code so far. It is rather verbose:</p> <pre data-language=\"js\">function todoApp(state = initialState, action) {\n  switch (action.type) {\n    case SET_VISIBILITY_FILTER:\n      return Object.assign({}, state, {\n        visibilityFilter: action.filter\n      })\n    case ADD_TODO:\n      return Object.assign({}, state, {\n        todos: [\n          ...state.todos,\n          {\n            text: action.text,\n            completed: false\n          }\n        ]\n      })\n    case TOGGLE_TODO:\n      return Object.assign({}, state, {\n        todos: state.todos.map((todo, index) =&gt; {\n          if(index === action.index) {\n            return Object.assign({}, todo, {\n              completed: !todo.completed\n            })\n          }\n          return todo\n        })\n      })\n    default:\n      return state\n  }\n}\n</pre> <p>Is there a way to make it easier to comprehend? It seems like <code>todos</code> and <code>visibilityFilter</code> are updated completely independently. Sometimes state fields depend on one another and more consideration is required, but in our case we can easily split updating <code>todos</code> into a separate function:</p> <pre data-language=\"js\">function todos(state = [], action) {\n  switch (action.type) {\n    case ADD_TODO:\n      return [\n        ...state,\n        {\n          text: action.text,\n          completed: false\n        }\n      ]\n    case TOGGLE_TODO:\n      return state.map((todo, index) =&gt; {\n        if (index === action.index) {\n          return Object.assign({}, todo, {\n            completed: !todo.completed\n          })\n        }\n        return todo\n      })\n    default:\n      return state\n  }\n}\n\nfunction todoApp(state = initialState, action) {\n  switch (action.type) {\n    case SET_VISIBILITY_FILTER:\n      return Object.assign({}, state, {\n        visibilityFilter: action.filter\n      })\n    case ADD_TODO:\n    case TOGGLE_TODO:\n      return Object.assign({}, state, {\n        todos: todos(state.todos, action)\n      })\n    default:\n      return state\n  }\n}\n</pre> <p>Note that <code>todos</code> also accepts <code>state</code>—but it’s an array! Now <code>todoApp</code> just gives it the slice of the state to manage, and <code>todos</code> knows how to update just that slice. <strong>This is called <em>reducer composition</em>, and it’s the fundamental pattern of building Redux apps.</strong></p> <p>Let’s explore reducer composition more. Can we also extract a reducer managing just <code>visibilityFilter</code>? We can:</p> <pre data-language=\"js\">function visibilityFilter(state = SHOW_ALL, action) {\n  switch (action.type) {\n  case SET_VISIBILITY_FILTER:\n    return action.filter\n  default:\n    return state\n  }\n}\n</pre> <p>Now we can rewrite the main reducer as a function that calls the reducers managing parts of the state, and combines them into a single object. It also doesn’t need to know the complete initial state anymore. It’s enough that the child reducers return their initial state when given <code>undefined</code> at first.</p> <pre data-language=\"js\">function todos(state = [], action) {\n  switch (action.type) {\n    case ADD_TODO:\n      return [\n        ...state,\n        {\n          text: action.text,\n          completed: false\n        }\n      ]\n    case TOGGLE_TODO:\n      return state.map((todo, index) =&gt; {\n        if (index === action.index) {\n          return Object.assign({}, todo, {\n            completed: !todo.completed\n          })\n        }\n        return todo\n      })\n    default:\n      return state\n  }\n}\n\nfunction visibilityFilter(state = SHOW_ALL, action) {\n  switch (action.type) {\n    case SET_VISIBILITY_FILTER:\n      return action.filter\n    default:\n      return state\n  }\n}\n\nfunction todoApp(state = {}, action) {\n  return {\n    visibilityFilter: visibilityFilter(state.visibilityFilter, action),\n    todos: todos(state.todos, action)\n  }\n}\n</pre> <p><strong>Note that each of these reducers is managing its own part of the global state. The <code>state</code> parameter is different for every reducer, and corresponds to the part of the state it manages.</strong></p> <p>This is already looking good! When the app is larger, we can split the reducers into separate files and keep them completely independent and managing different data domains.</p> <p>Finally, Redux provides a utility called <a href=\"../api/combinereducers\"><code>combineReducers()</code></a> that does the same boilerplate logic that the <code>todoApp</code> above currently does. With its help, we can rewrite <code>todoApp</code> like this:</p> <pre data-language=\"js\">import { combineReducers } from 'redux'\n\nconst todoApp = combineReducers({\n  visibilityFilter,\n  todos\n})\n\nexport default todoApp\n</pre> <p>Note that this is completely equivalent to:</p> <pre data-language=\"js\">export default function todoApp(state = {}, action) {\n  return {\n    visibilityFilter: visibilityFilter(state.visibilityFilter, action),\n    todos: todos(state.todos, action)\n  }\n}\n</pre> <p>You could also give them different keys, or call functions differently. These two ways to write a combined reducer are completely equivalent:</p> <pre data-language=\"js\">const reducer = combineReducers({\n  a: doSomethingWithA,\n  b: processB,\n  c: c\n})\n</pre> <pre data-language=\"js\">function reducer(state = {}, action) {\n  return {\n    a: doSomethingWithA(state.a, action),\n    b: processB(state.b, action),\n    c: c(state.c, action)\n  }\n}\n</pre> <p>All <a href=\"../api/combinereducers\"><code>combineReducers()</code></a> does is generate a function that calls your reducers <strong>with the slices of state selected according to their keys</strong>, and combining their results into a single object again. <a href=\"https://github.com/reactjs/redux/issues/428#issuecomment-129223274\" target=\"_blank\">It’s not magic.</a></p> <blockquote> <h5 id=\"note-for-es6-savvy-users\">Note for ES6 Savvy Users</h5> <p>Because <code>combineReducers</code> expects an object, we can put all top-level reducers into a separate file, <code>export</code> each reducer function, and use <code>import * as reducers</code> to get them as an object with their names as the keys:</p> <pre data-language=\"js\">import { combineReducers } from 'redux'\nimport * as reducers from './reducers'\n\nconst todoApp = combineReducers(reducers)\n</pre> <p>Because <code>import *</code> is still new syntax, we don’t use it anymore in the documentation to avoid <a href=\"https://github.com/reactjs/redux/issues/428#issuecomment-129223274\" target=\"_blank\">confusion</a>, but you may encounter it in some community examples.</p> </blockquote> <h2 id=\"source-code\">Source Code</h2> <h4 id=\"-reducers-js\"><code>reducers.js</code></h4> <pre data-language=\"js\">import { combineReducers } from 'redux'\nimport { ADD_TODO, TOGGLE_TODO, SET_VISIBILITY_FILTER, VisibilityFilters } from './actions'\nconst { SHOW_ALL } = VisibilityFilters\n\nfunction visibilityFilter(state = SHOW_ALL, action) {\n  switch (action.type) {\n    case SET_VISIBILITY_FILTER:\n      return action.filter\n    default:\n      return state\n  }\n}\n\nfunction todos(state = [], action) {\n  switch (action.type) {\n    case ADD_TODO:\n      return [\n        ...state,\n        {\n          text: action.text,\n          completed: false\n        }\n      ]\n    case TOGGLE_TODO:\n      return state.map((todo, index) =&gt; {\n        if (index === action.index) {\n          return Object.assign({}, todo, {\n            completed: !todo.completed\n          })\n        }\n        return todo\n      })\n    default:\n      return state\n  }\n}\n\nconst todoApp = combineReducers({\n  visibilityFilter,\n  todos\n})\n\nexport default todoApp\n</pre> <h2 id=\"next-steps\">Next Steps</h2> <p>Next, we’ll explore how to <a href=\"store\">create a Redux store</a> that holds the state and takes care of calling your reducer when you dispatch an action.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/basics/Reducers.html\" class=\"_attribution-link\">http://redux.js.org/docs/basics/Reducers.html</a>\n  </p>\n</div>\n","basics/usagewithreact":"<h1 id=\"usage-with-react\">Usage with React</h1> <p>From the very beginning, we need to stress that Redux has no relation to React. You can write Redux apps with React, Angular, Ember, jQuery, or vanilla JavaScript.</p> <p>That said, Redux works especially well with frameworks like <a href=\"http://facebook.github.io/react/\" target=\"_blank\">React</a> and <a href=\"https://github.com/dekujs/deku\" target=\"_blank\">Deku</a> because they let you describe UI as a function of state, and Redux emits state updates in response to actions.</p> <p>We will use React to build our simple todo app.</p> <h2 id=\"installing-react-redux\">Installing React Redux</h2> <p><a href=\"https://github.com/gaearon/react-redux\" target=\"_blank\">React bindings</a> are not included in Redux by default. You need to install them explicitly:</p> <pre>npm install --save react-redux\n</pre>\n<p>If you don’t use npm, you may grab the latest UMD build from unpkg (either a <a href=\"https://unpkg.com/react-redux@latest/dist/react-redux.js\" target=\"_blank\">development</a> or a <a href=\"https://unpkg.com/react-redux@latest/dist/react-redux.min.js\" target=\"_blank\">production</a> build). The UMD build exports a global called <code>window.ReactRedux</code> if you add it to your page via a <code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">&gt;</span></span></code> tag.</p> <h2 id=\"presentational-and-container-components\">Presentational and Container Components</h2> <p>React bindings for Redux embrace the idea of <strong>separating presentational and container components</strong>. If you’re not familiar with these terms, <a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\" target=\"_blank\">read about them first</a>, and then come back. They are important, so we’ll wait!</p> <p>Finished reading the article? Let’s recount their differences:</p> <table> <thead> <tr> <th></th> <th scope=\"col\" style=\"text-align:left\">Presentational Components</th> <th scope=\"col\" style=\"text-align:left\">Container Components</th> </tr> </thead> <tbody> <tr> <th scope=\"row\" style=\"text-align:right\">Purpose</th> <td>How things look (markup, styles)</td> <td>How things work (data fetching, state updates)</td> </tr> <tr> <th scope=\"row\" style=\"text-align:right\">Aware of Redux</th> <td>No </td>\n<td>Yes </td>\n</tr> <tr> <th scope=\"row\" style=\"text-align:right\">To read data</th> <td>Read data from props</td> <td>Subscribe to Redux state</td> </tr> <tr> <th scope=\"row\" style=\"text-align:right\">To change data</th> <td>Invoke callbacks from props</td> <td>Dispatch Redux actions</td> </tr> <tr> <th scope=\"row\" style=\"text-align:right\">Are written</th> <td>By hand</td> <td>Usually generated by React Redux</td> </tr> </tbody> </table> <p>Most of the components we’ll write will be presentational, but we’ll need to generate a few container components to connect them to the Redux store.</p> <p>Technically you could write the container components by hand using <a href=\"../api/store#subscribe\"><code>store.subscribe()</code></a>. We don’t advise you to do this because React Redux makes many performance optimizations that are hard to do by hand. For this reason, rather than write container components, we will generate them using the <a href=\"https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options\" target=\"_blank\"><code>connect()</code></a> function provided by React Redux, as you will see below.</p> <h2 id=\"designing-component-hierarchy\">Designing Component Hierarchy</h2> <p>Remember how we <a href=\"reducers\">designed the shape of the root state object</a>? It’s time we design the UI hierarchy to match it. This is not a Redux-specific task. <a href=\"https://facebook.github.io/react/docs/thinking-in-react.html\" target=\"_blank\">Thinking in React</a> is a great tutorial that explains the process.</p> <p>Our design brief is simple. We want to show a list of todo items. On click, a todo item is crossed out as completed. We want to show a field where the user may add a new todo. In the footer, we want to show a toggle to show all, only completed, or only active todos.</p> <h3 id=\"presentational-components\">Presentational Components</h3> <p>I see the following presentational components and their props emerge from this brief:</p> <ul> <li>\n<strong><code>TodoList</code></strong> is a list showing visible todos.<ul> <li>\n<code>todos: Array</code> is an array of todo items with <code>{ id, text, completed }</code> shape.</li> <li>\n<code>onTodoClick(id: number)</code> is a callback to invoke when a todo is clicked.</li> </ul> </li> <li>\n<strong><code>Todo</code></strong> is a single todo item.<ul> <li>\n<code>text: string</code> is the text to show.</li> <li>\n<code>completed: boolean</code> is whether todo should appear crossed out.</li> <li>\n<code>onClick()</code> is a callback to invoke when a todo is clicked.</li> </ul> </li> <li>\n<strong><code>Link</code></strong> is a link with a callback.<ul> <li>\n<code>onClick()</code> is a callback to invoke when link is clicked.</li> </ul> </li> <li>\n<strong><code>Footer</code></strong> is where we let the user change currently visible todos.</li> <li>\n<strong><code>App</code></strong> is the root component that renders everything else.</li> </ul> <p>They describe the <em>look</em> but don’t know <em>where</em> the data comes from, or <em>how</em> to change it. They only render what’s given to them. If you migrate from Redux to something else, you’ll be able to keep all these components exactly the same. They have no dependency on Redux.</p> <h3 id=\"container-components\">Container Components</h3> <p>We will also need some container components to connect the presentational components to Redux. For example, the presentational <code>TodoList</code> component needs a container like <code>VisibleTodoList</code> that subscribes to the Redux store and knows how to apply the current visibility filter. To change the visibility filter, we will provide a <code>FilterLink</code> container component that renders a <code>Link</code> that dispatches an appropriate action on click:</p> <ul> <li>\n<strong><code>VisibleTodoList</code></strong> filters the todos according to the current visibility filter and renders a <code>TodoList</code>.</li> <li>\n<strong><code>FilterLink</code></strong> gets the current visibility filter and renders a <code>Link</code>.<ul> <li>\n<code>filter: string</code> is the visibility filter it represents.</li> </ul> </li> </ul> <h3 id=\"other-components\">Other Components</h3> <p>Sometimes it’s hard to tell if some component should be a presentational component or a container. For example, sometimes form and function are really coupled together, such as in case of this tiny component:</p> <ul> <li>\n<strong><code>AddTodo</code></strong> is an input field with an “Add” button</li> </ul> <p>Technically we could split it into two components but it might be too early at this stage. It’s fine to mix presentation and logic in a component that is very small. As it grows, it will be more obvious how to split it, so we’ll leave it mixed.</p> <h2 id=\"implementing-components\">Implementing Components</h2> <p>Let’s write the components! We begin with the presentational components so we don’t need to think about binding to Redux yet.</p> <h3 id=\"presentational-components\">Presentational Components</h3> <p>These are all normal React components, so we won’t examine them in detail. We write functional stateless components unless we need to use local state or the lifecycle methods. This doesn’t mean that presentational components <em>have to</em> be functions—it’s just easier to define them this way. If and when you need to add local state, lifecycle methods, or performance optimizations, you can convert them to classes.</p> <h4 id=\"-components-todo-js\"><code>components/Todo.js</code></h4> <pre data-language=\"js\">import React, { PropTypes } from 'react'\n\nconst Todo = ({ onClick, completed, text }) =&gt; (\n  &lt;li\n    onClick={onClick}\n    style={{\n      textDecoration: completed ? 'line-through' : 'none'\n    }}\n  &gt;\n    {text}\n  &lt;/li&gt;\n)\n\nTodo.propTypes = {\n  onClick: PropTypes.func.isRequired,\n  completed: PropTypes.bool.isRequired,\n  text: PropTypes.string.isRequired\n}\n\nexport default Todo\n</pre> <h4 id=\"-components-todolist-js\"><code>components/TodoList.js</code></h4> <pre data-language=\"js\">import React, { PropTypes } from 'react'\nimport Todo from './Todo'\n\nconst TodoList = ({ todos, onTodoClick }) =&gt; (\n  &lt;ul&gt;\n    {todos.map(todo =&gt;\n      &lt;Todo\n        key={todo.id}\n        {...todo}\n        onClick={() =&gt; onTodoClick(todo.id)}\n      /&gt;\n    )}\n  &lt;/ul&gt;\n)\n\nTodoList.propTypes = {\n  todos: PropTypes.arrayOf(PropTypes.shape({\n    id: PropTypes.number.isRequired,\n    completed: PropTypes.bool.isRequired,\n    text: PropTypes.string.isRequired\n  }).isRequired).isRequired,\n  onTodoClick: PropTypes.func.isRequired\n}\n\nexport default TodoList\n</pre> <h4 id=\"-components-link-js\"><code>components/Link.js</code></h4> <pre data-language=\"js\">import React, { PropTypes } from 'react'\n\nconst Link = ({ active, children, onClick }) =&gt; {\n  if (active) {\n    return &lt;span&gt;{children}&lt;/span&gt;\n  }\n\n  return (\n    &lt;a href=\"#\"\n       onClick={e =&gt; {\n         e.preventDefault()\n         onClick()\n       }}\n    &gt;\n      {children}\n    &lt;/a&gt;\n  )\n}\n\nLink.propTypes = {\n  active: PropTypes.bool.isRequired,\n  children: PropTypes.node.isRequired,\n  onClick: PropTypes.func.isRequired\n}\n\nexport default Link\n</pre> <h4 id=\"-components-footer-js\"><code>components/Footer.js</code></h4> <pre data-language=\"js\">import React from 'react'\nimport FilterLink from '../containers/FilterLink'\n\nconst Footer = () =&gt; (\n  &lt;p&gt;\n    Show:\n    {\" \"}\n    &lt;FilterLink filter=\"SHOW_ALL\"&gt;\n      All\n    &lt;/FilterLink&gt;\n    {\", \"}\n    &lt;FilterLink filter=\"SHOW_ACTIVE\"&gt;\n      Active\n    &lt;/FilterLink&gt;\n    {\", \"}\n    &lt;FilterLink filter=\"SHOW_COMPLETED\"&gt;\n      Completed\n    &lt;/FilterLink&gt;\n  &lt;/p&gt;\n)\n\nexport default Footer\n</pre> <h4 id=\"-components-app-js\"><code>components/App.js</code></h4> <pre data-language=\"js\">import React from 'react'\nimport Footer from './Footer'\nimport AddTodo from '../containers/AddTodo'\nimport VisibleTodoList from '../containers/VisibleTodoList'\n\nconst App = () =&gt; (\n  &lt;div&gt;\n    &lt;AddTodo /&gt;\n    &lt;VisibleTodoList /&gt;\n    &lt;Footer /&gt;\n  &lt;/div&gt;\n)\n\nexport default App\n</pre> <h3 id=\"container-components\">Container Components</h3> <p>Now it’s time to hook up those presentational components to Redux by creating some containers. Technically, a container component is just a React component that uses <a href=\"../api/store#subscribe\"><code>store.subscribe()</code></a> to read a part of the Redux state tree and supply props to a presentational component it renders. You could write a container component by hand, but we suggest instead generating container components with the React Redux library’s <a href=\"https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options\" target=\"_blank\"><code>connect()</code></a> function, which provides many useful optimizations to prevent unnecessary re-renders. (One result of this is that you shouldn’t have to worry about the <a href=\"https://facebook.github.io/react/docs/advanced-performance.html\" target=\"_blank\">React performance suggestion</a> of implementing <code>shouldComponentUpdate</code> yourself.)</p> <p>To use <code>connect()</code>, you need to define a special function called <code>mapStateToProps</code> that tells how to transform the current Redux store state into the props you want to pass to a presentational component you are wrapping. For example, <code>VisibleTodoList</code> needs to calculate <code>todos</code> to pass to the <code>TodoList</code>, so we define a function that filters the <code>state.todos</code> according to the <code>state.visibilityFilter</code>, and use it in its <code>mapStateToProps</code>:</p> <pre data-language=\"js\">const getVisibleTodos = (todos, filter) =&gt; {\n  switch (filter) {\n    case 'SHOW_ALL':\n      return todos\n    case 'SHOW_COMPLETED':\n      return todos.filter(t =&gt; t.completed)\n    case 'SHOW_ACTIVE':\n      return todos.filter(t =&gt; !t.completed)\n  }\n}\n\nconst mapStateToProps = (state) =&gt; {\n  return {\n    todos: getVisibleTodos(state.todos, state.visibilityFilter)\n  }\n}\n</pre> <p>In addition to reading the state, container components can dispatch actions. In a similar fashion, you can define a function called <code>mapDispatchToProps()</code> that receives the <a href=\"../api/store#dispatch\"><code>dispatch()</code></a> method and returns callback props that you want to inject into the presentational component. For example, we want the <code>VisibleTodoList</code> to inject a prop called <code>onTodoClick</code> into the <code>TodoList</code> component, and we want <code>onTodoClick</code> to dispatch a <code>TOGGLE_TODO</code> action:</p> <pre data-language=\"js\">const mapDispatchToProps = (dispatch) =&gt; {\n  return {\n    onTodoClick: (id) =&gt; {\n      dispatch(toggleTodo(id))\n    }\n  }\n}\n</pre> <p>Finally, we create the <code>VisibleTodoList</code> by calling <code>connect()</code> and passing these two functions:</p> <pre data-language=\"js\">import { connect } from 'react-redux'\n\nconst VisibleTodoList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(TodoList)\n\nexport default VisibleTodoList\n</pre> <p>These are the basics of the React Redux API, but there are a few shortcuts and power options so we encourage you to check out <a href=\"https://github.com/reactjs/react-redux\" target=\"_blank\">its documentation</a> in detail. In case you are worried about <code>mapStateToProps</code> creating new objects too often, you might want to learn about <a href=\"../recipes/computingderiveddata\">computing derived data</a> with <a href=\"https://github.com/rackt/reselect\" target=\"_blank\">reselect</a>.</p> <p>Find the rest of the container components defined below:</p> <h4 id=\"-containers-filterlink-js\"><code>containers/FilterLink.js</code></h4> <pre data-language=\"js\">import { connect } from 'react-redux'\nimport { setVisibilityFilter } from '../actions'\nimport Link from '../components/Link'\n\nconst mapStateToProps = (state, ownProps) =&gt; {\n  return {\n    active: ownProps.filter === state.visibilityFilter\n  }\n}\n\nconst mapDispatchToProps = (dispatch, ownProps) =&gt; {\n  return {\n    onClick: () =&gt; {\n      dispatch(setVisibilityFilter(ownProps.filter))\n    }\n  }\n}\n\nconst FilterLink = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(Link)\n\nexport default FilterLink\n</pre> <h4 id=\"-containers-visibletodolist-js\"><code>containers/VisibleTodoList.js</code></h4> <pre data-language=\"js\">import { connect } from 'react-redux'\nimport { toggleTodo } from '../actions'\nimport TodoList from '../components/TodoList'\n\nconst getVisibleTodos = (todos, filter) =&gt; {\n  switch (filter) {\n    case 'SHOW_ALL':\n      return todos\n    case 'SHOW_COMPLETED':\n      return todos.filter(t =&gt; t.completed)\n    case 'SHOW_ACTIVE':\n      return todos.filter(t =&gt; !t.completed)\n  }\n}\n\nconst mapStateToProps = (state) =&gt; {\n  return {\n    todos: getVisibleTodos(state.todos, state.visibilityFilter)\n  }\n}\n\nconst mapDispatchToProps = (dispatch) =&gt; {\n  return {\n    onTodoClick: (id) =&gt; {\n      dispatch(toggleTodo(id))\n    }\n  }\n}\n\nconst VisibleTodoList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(TodoList)\n\nexport default VisibleTodoList\n</pre> <h3 id=\"other-components\">Other Components</h3> <h4 id=\"-containers-addtodo-js\"><code>containers/AddTodo.js</code></h4> <pre data-language=\"js\">import React from 'react'\nimport { connect } from 'react-redux'\nimport { addTodo } from '../actions'\n\nlet AddTodo = ({ dispatch }) =&gt; {\n  let input\n\n  return (\n    &lt;div&gt;\n      &lt;form onSubmit={e =&gt; {\n        e.preventDefault()\n        if (!input.value.trim()) {\n          return\n        }\n        dispatch(addTodo(input.value))\n        input.value = ''\n      }}&gt;\n        &lt;input ref={node =&gt; {\n          input = node\n        }} /&gt;\n        &lt;button type=\"submit\"&gt;\n          Add Todo\n        &lt;/button&gt;\n      &lt;/form&gt;\n    &lt;/div&gt;\n  )\n}\nAddTodo = connect()(AddTodo)\n\nexport default AddTodo\n</pre> <h2 id=\"passing-the-store\">Passing the Store</h2> <p>All container components need access to the Redux store so they can subscribe to it. One option would be to pass it as a prop to every container component. However it gets tedious, as you have to wire <code>store</code> even through presentational components just because they happen to render a container deep in the component tree.</p> <p>The option we recommend is to use a special React Redux component called <a href=\"https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store\" target=\"_blank\"><code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Provider</span><span class=\"token punctuation\">&gt;</span></span></code></a> to <a href=\"https://facebook.github.io/react/docs/context.html\" target=\"_blank\">magically</a> make the store available to all container components in the application without passing it explicitly. You only need to use it once when you render the root component:</p> <h4 id=\"-index-js\"><code>index.js</code></h4> <pre data-language=\"js\">import React from 'react'\nimport { render } from 'react-dom'\nimport { Provider } from 'react-redux'\nimport { createStore } from 'redux'\nimport todoApp from './reducers'\nimport App from './components/App'\n\nlet store = createStore(todoApp)\n\nrender(\n  &lt;Provider store={store}&gt;\n    &lt;App /&gt;\n  &lt;/Provider&gt;,\n  document.getElementById('root')\n)\n</pre> <h2 id=\"next-steps\">Next Steps</h2> <p>Read the <a href=\"exampletodolist\">complete source code for this tutorial</a> to better internalize the knowledge you have gained. Then, head straight to the <a href=\"../advanced/index\">advanced tutorial</a> to learn how to handle network requests and routing!</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/basics/UsageWithReact.html\" class=\"_attribution-link\">http://redux.js.org/docs/basics/UsageWithReact.html</a>\n  </p>\n</div>\n","recipes/usingobjectspreadoperator":"<h1 id=\"using-object-spread-operator\">Using Object Spread Operator</h1> <p>Since one of the core tenets of Redux is to never mutate state, you’ll often find yourself using <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\"><code>Object.assign()</code></a> to create copies of objects with new or updated values. For example, in the <code>todoApp</code> below <code>Object.assign()</code> is used to return a new <code>state</code> object with an updated <code>visibilityFilter</code> property:</p> <pre data-language=\"js\">function todoApp(state = initialState, action) {\n  switch (action.type) {\n    case SET_VISIBILITY_FILTER:\n      return Object.assign({}, state, {\n        visibilityFilter: action.filter\n      })\n    default:\n      return state\n  }\n}\n</pre> <p>While effective, using <code>Object.assign()</code> can quickly make simple reducers difficult to read given its rather verbose syntax.</p> <p>An alternative approach is to use the <a href=\"https://github.com/sebmarkbage/ecmascript-rest-spread\" target=\"_blank\">object spread syntax</a> proposed for the next versions of JavaScript which lets you use the spread (<code>...</code>) operator to copy enumerable properties from one object to another in a more succinct way. The object spread operator is conceptually similar to the ES6 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator\" target=\"_blank\">array spread operator</a>. We can simplify the <code>todoApp</code> example above by using the object spread syntax:</p> <pre data-language=\"js\">function todoApp(state = initialState, action) {\n  switch (action.type) {\n    case SET_VISIBILITY_FILTER:\n      return { ...state, visibilityFilter: action.filter }\n    default:\n      return state\n  }\n}\n</pre> <p>The advantage of using the object spread syntax becomes more apparent when you’re composing complex objects. Below <code>getAddedIds</code> maps an array of <code>id</code> values to an array of objects with values returned from <code>getProduct</code> and <code>getQuantity</code>.</p> <pre data-language=\"js\">return getAddedIds(state.cart).map(id =&gt; Object.assign(\n  {},\n  getProduct(state.products, id),\n  {\n    quantity: getQuantity(state.cart, id)\n  }\n))\n</pre> <p>Object spread lets us simplify the above <code>map</code> call to:</p> <pre data-language=\"js\">return getAddedIds(state.cart).map(id =&gt; ({\n  ...getProduct(state.products, id),\n  quantity: getQuantity(state.cart, id)\n}))\n</pre> <p>Since the object spread syntax is still a Stage 2 proposal for ECMAScript you’ll need to use a transpiler such as <a href=\"http://babeljs.io/\" target=\"_blank\">Babel</a> to use it in production. You can use your existing <code>es2015</code> preset, install <a href=\"http://babeljs.io/docs/plugins/transform-object-rest-spread/\" target=\"_blank\"><code>babel-plugin-transform-object-rest-spread</code></a> and add it individually to the <code>plugins</code> array in your <code>.babelrc</code>.</p> <pre data-language=\"js\">{\n  \"presets\": [\"es2015\"],\n  \"plugins\": [\"transform-object-rest-spread\"]\n}\n</pre> <p>Note that this is still an experimental language feature proposal so it may change in the future. Nevertheless some large projects such as <a href=\"https://github.com/facebook/react-native\" target=\"_blank\">React Native</a> already use it extensively so it is safe to say that there will be a good automated migration path if it changes.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/recipes/UsingObjectSpreadOperator.html\" class=\"_attribution-link\">http://redux.js.org/docs/recipes/UsingObjectSpreadOperator.html</a>\n  </p>\n</div>\n","advanced/asyncactions":"<h1 id=\"async-actions\">Async Actions</h1> <p>In the <a href=\"../basics/index\">basics guide</a>, we built a simple todo application. It was fully synchronous. Every time an action was dispatched, the state was updated immediately.</p> <p>In this guide, we will build a different, asynchronous application. It will use the Reddit API to show the current headlines for a select subreddit. How does asynchronicity fit into Redux flow?</p> <h2 id=\"actions\">Actions</h2> <p>When you call an asynchronous API, there are two crucial moments in time: the moment you start the call, and the moment when you receive an answer (or a timeout).</p> <p>Each of these two moments can usually require a change in the application state; to do that, you need to dispatch normal actions that will be processed by reducers synchronously. Usually, for any API request you’ll want to dispatch at least three different kinds of actions:</p> <ul> <li>\n<p><strong>An action informing the reducers that the request began.</strong></p> <p>The reducers may handle this action by toggling an <code>isFetching</code> flag in the state. This way the UI knows it’s time to show a spinner.</p> </li> <li>\n<p><strong>An action informing the reducers that the request finished successfully.</strong></p> <p>The reducers may handle this action by merging the new data into the state they manage and resetting <code>isFetching</code>. The UI would hide the spinner, and display the fetched data.</p> </li> <li>\n<p><strong>An action informing the reducers that the request failed.</strong></p> <p>The reducers may handle this action by resetting <code>isFetching</code>. Additionally, some reducers may want to store the error message so the UI can display it.</p> </li> </ul> <p>You may use a dedicated <code>status</code> field in your actions:</p> <pre data-language=\"js\">{ type: 'FETCH_POSTS' }\n{ type: 'FETCH_POSTS', status: 'error', error: 'Oops' }\n{ type: 'FETCH_POSTS', status: 'success', response: { ... } }\n</pre> <p>Or you can define separate types for them:</p> <pre data-language=\"js\">{ type: 'FETCH_POSTS_REQUEST' }\n{ type: 'FETCH_POSTS_FAILURE', error: 'Oops' }\n{ type: 'FETCH_POSTS_SUCCESS', response: { ... } }\n</pre> <p>Choosing whether to use a single action type with flags, or multiple action types, is up to you. It’s a convention you need to decide with your team. Multiple types leave less room for a mistake, but this is not an issue if you generate action creators and reducers with a helper library like <a href=\"https://github.com/acdlite/redux-actions\" target=\"_blank\">redux-actions</a>.</p> <p>Whatever convention you choose, stick with it throughout the application.<br>We’ll use separate types in this tutorial.</p> <h2 id=\"synchronous-action-creators\">Synchronous Action Creators</h2> <p>Let’s start by defining the several synchronous action types and action creators we need in our example app. Here, the user can select a subreddit to display:</p> <h4 id=\"-actions-js\"><code>actions.js</code></h4> <pre data-language=\"js\">export const SELECT_SUBREDDIT = 'SELECT_SUBREDDIT'\n\nexport function selectSubreddit(subreddit) {\n  return {\n    type: SELECT_SUBREDDIT,\n    subreddit\n  }\n}\n</pre> <p>They can also press a “refresh” button to update it:</p> <pre data-language=\"js\">export const INVALIDATE_SUBREDDIT = 'INVALIDATE_SUBREDDIT'\n\nexport function invalidateSubreddit(subreddit) {\n  return {\n    type: INVALIDATE_SUBREDDIT,\n    subreddit\n  }\n}\n</pre> <p>These were the actions governed by the user interaction. We will also have another kind of action, governed by the network requests. We will see how to dispatch them later, but for now, we just want to define them.</p> <p>When it’s time to fetch the posts for some subreddit, we will dispatch a <code>REQUEST_POSTS</code> action:</p> <pre data-language=\"js\">export const REQUEST_POSTS = 'REQUEST_POSTS'\n\nexport function requestPosts(subreddit) {\n  return {\n    type: REQUEST_POSTS,\n    subreddit\n  }\n}\n</pre> <p>It is important for it to be separate from <code>SELECT_SUBREDDIT</code> or <code>INVALIDATE_SUBREDDIT</code>. While they may occur one after another, as the app grows more complex, you might want to fetch some data independently of the user action (for example, to prefetch the most popular subreddits, or to refresh stale data once in a while). You may also want to fetch in response to a route change, so it’s not wise to couple fetching to some particular UI event early on.</p> <p>Finally, when the network request comes through, we will dispatch <code>RECEIVE_POSTS</code>:</p> <pre data-language=\"js\">export const RECEIVE_POSTS = 'RECEIVE_POSTS'\n\nexport function receivePosts(subreddit, json) {\n  return {\n    type: RECEIVE_POSTS,\n    subreddit,\n    posts: json.data.children.map(child =&gt; child.data),\n    receivedAt: Date.now()\n  }\n}\n</pre> <p>This is all we need to know for now. The particular mechanism to dispatch these actions together with network requests will be discussed later.</p> <blockquote> <h5 id=\"note-on-error-handling\">Note on Error Handling</h5> <p>In a real app, you’d also want to dispatch an action on request failure. We won’t implement error handling in this tutorial, but the <a href=\"../introduction/examples#real-world\">real world example</a> shows one of the possible approaches.</p> </blockquote> <h2 id=\"designing-the-state-shape\">Designing the State Shape</h2> <p>Just like in the basic tutorial, you’ll need to <a href=\"../basics/reducers#designing-the-state-shape\">design the shape of your application’s state</a> before rushing into the implementation. With asynchronous code, there is more state to take care of, so we need to think it through.</p> <p>This part is often confusing to beginners, because it is not immediately clear what information describes the state of an asynchronous application, and how to organize it in a single tree.</p> <p>We’ll start with the most common use case: lists. Web applications often show lists of things. For example, a list of posts, or a list of friends. You’ll need to figure out what sorts of lists your app can show. You want to store them separately in the state, because this way you can cache them and only fetch again if necessary.</p> <p>Here’s what the state shape for our “Reddit headlines” app might look like:</p> <pre data-language=\"js\">{\n  selectedSubreddit: 'frontend',\n  postsBySubreddit: {\n    frontend: {\n      isFetching: true,\n      didInvalidate: false,\n      items: []\n    },\n    reactjs: {\n      isFetching: false,\n      didInvalidate: false,\n      lastUpdated: 1439478405547,\n      items: [\n        {\n          id: 42,\n          title: 'Confusion about Flux and Relay'\n        },\n        {\n          id: 500,\n          title: 'Creating a Simple Application Using React JS and Flux Architecture'\n        }\n      ]\n    }\n  }\n}\n</pre> <p>There are a few important bits here:</p> <ul> <li>\n<p>We store each subreddit’s information separately so we can cache every subreddit. When the user switches between them the second time, the update will be instant, and we won’t need to refetch unless we want to. Don’t worry about all these items being in memory: unless you’re dealing with tens of thousands of items, and your user rarely closes the tab, you won’t need any sort of cleanup.</p> </li> <li>\n<p>For every list of items, you’ll want to store <code>isFetching</code> to show a spinner, <code>didInvalidate</code> so you can later toggle it when the data is stale, <code>lastUpdated</code> so you know when it was fetched the last time, and the <code>items</code> themselves. In a real app, you’ll also want to store pagination state like <code>fetchedPageCount</code> and <code>nextPageUrl</code>.</p> </li> </ul> <blockquote> <h5 id=\"note-on-nested-entities\">Note on Nested Entities</h5> <p>In this example, we store the received items together with the pagination information. However, this approach won’t work well if you have nested entities referencing each other, or if you let the user edit items. Imagine the user wants to edit a fetched post, but this post is duplicated in several places in the state tree. This would be really painful to implement.</p> <p>If you have nested entities, or if you let users edit received entities, you should keep them separately in the state as if it was a database. In pagination information, you would only refer to them by their IDs. This lets you always keep them up to date. The <a href=\"../introduction/examples#real-world\">real world example</a> shows this approach, together with <a href=\"https://github.com/gaearon/normalizr\" target=\"_blank\">normalizr</a> to normalize the nested API responses. With this approach, your state might look like this:</p> <pre data-language=\"js\">{\n  selectedSubreddit: 'frontend',\n  entities: {\n    users: {\n      2: {\n        id: 2,\n        name: 'Andrew'\n      }\n    },\n    posts: {\n      42: {\n        id: 42,\n        title: 'Confusion about Flux and Relay',\n        author: 2\n      },\n      100: {\n        id: 100,\n        title: 'Creating a Simple Application Using React JS and Flux Architecture',\n        author: 2\n      }\n    }\n  },\n  postsBySubreddit: {\n    frontend: {\n      isFetching: true,\n      didInvalidate: false,\n      items: []\n    },\n    reactjs: {\n      isFetching: false,\n      didInvalidate: false,\n      lastUpdated: 1439478405547,\n      items: [ 42, 100 ]\n    }\n  }\n}\n</pre> <p>In this guide, we won’t normalize entities, but it’s something you should consider for a more dynamic application.</p> </blockquote> <h2 id=\"handling-actions\">Handling Actions</h2> <p>Before going into the details of dispatching actions together with network requests, we will write the reducers for the actions we defined above.</p> <blockquote> <h5 id=\"note-on-reducer-composition\">Note on Reducer Composition</h5> <p>Here, we assume that you understand reducer composition with <a href=\"../api/combinereducers\"><code>combineReducers()</code></a>, as described in the <a href=\"../basics/reducers#splitting-reducers\">Splitting Reducers</a> section on the <a href=\"../basics/index\">basics guide</a>. If you don’t, please <a href=\"../basics/reducers#splitting-reducers\">read it first</a>.</p> </blockquote> <h4 id=\"-reducers-js\"><code>reducers.js</code></h4> <pre data-language=\"js\">import { combineReducers } from 'redux'\nimport {\n  SELECT_SUBREDDIT, INVALIDATE_SUBREDDIT,\n  REQUEST_POSTS, RECEIVE_POSTS\n} from '../actions'\n\nfunction selectedSubreddit(state = 'reactjs', action) {\n  switch (action.type) {\n    case SELECT_SUBREDDIT:\n      return action.subreddit\n    default:\n      return state\n  }\n}\n\nfunction posts(state = {\n  isFetching: false,\n  didInvalidate: false,\n  items: []\n}, action) {\n  switch (action.type) {\n    case INVALIDATE_SUBREDDIT:\n      return Object.assign({}, state, {\n        didInvalidate: true\n      })\n    case REQUEST_POSTS:\n      return Object.assign({}, state, {\n        isFetching: true,\n        didInvalidate: false\n      })\n    case RECEIVE_POSTS:\n      return Object.assign({}, state, {\n        isFetching: false,\n        didInvalidate: false,\n        items: action.posts,\n        lastUpdated: action.receivedAt\n      })\n    default:\n      return state\n  }\n}\n\nfunction postsBySubreddit(state = {}, action) {\n  switch (action.type) {\n    case INVALIDATE_SUBREDDIT:\n    case RECEIVE_POSTS:\n    case REQUEST_POSTS:\n      return Object.assign({}, state, {\n        [action.subreddit]: posts(state[action.subreddit], action)\n      })\n    default:\n      return state\n  }\n}\n\nconst rootReducer = combineReducers({\n  postsBySubreddit,\n  selectedSubreddit\n})\n\nexport default rootReducer\n</pre> <p>In this code, there are two interesting parts:</p> <ul> <li>\n<p>We use ES6 computed property syntax so we can update <code>state[action.subreddit]</code> with <code>Object.assign()</code> in a terse way. This:</p> <pre data-language=\"js\">return Object.assign({}, state, {\n  [action.subreddit]: posts(state[action.subreddit], action)\n})\n</pre> <p>is equivalent to this:</p> <pre data-language=\"js\">let nextState = {}\nnextState[action.subreddit] = posts(state[action.subreddit], action)\nreturn Object.assign({}, state, nextState)\n</pre> </li> <li>We extracted <code>posts(state, action)</code> that manages the state of a specific post list. This is just <a href=\"../basics/reducers#splitting-reducers\">reducer composition</a>! It is our choice how to split the reducer into smaller reducers, and in this case, we’re delegating updating items inside an object to a <code>posts</code> reducer. The <a href=\"../introduction/examples#real-world\">real world example</a> goes even further, showing how to create a reducer factory for parameterized pagination reducers.</li> </ul> <p>Remember that reducers are just functions, so you can use functional composition and higher-order functions as much as you feel comfortable.</p> <h2 id=\"async-action-creators\">Async Action Creators</h2> <p>Finally, how do we use the synchronous action creators we <a href=\"#synchronous-action-creators\">defined earlier</a> together with network requests? The standard way to do it with Redux is to use the <a href=\"https://github.com/gaearon/redux-thunk\" target=\"_blank\">Redux Thunk middleware</a>. It comes in a separate package called <code>redux-thunk</code>. We’ll explain how middleware works in general <a href=\"middleware\">later</a>; for now, there is just one important thing you need to know: by using this specific middleware, an action creator can return a function instead of an action object. This way, the action creator becomes a <a href=\"https://en.wikipedia.org/wiki/Thunk\" target=\"_blank\">thunk</a>.</p> <p>When an action creator returns a function, that function will get executed by the Redux Thunk middleware. This function doesn’t need to be pure; it is thus allowed to have side effects, including executing asynchronous API calls. The function can also dispatch actions—like those synchronous actions we defined earlier.</p> <p>We can still define these special thunk action creators inside our <code>actions.js</code> file:</p> <h4 id=\"-actions-js\"><code>actions.js</code></h4> <pre data-language=\"js\">import fetch from 'isomorphic-fetch'\n\nexport const REQUEST_POSTS = 'REQUEST_POSTS'\nfunction requestPosts(subreddit) {\n  return {\n    type: REQUEST_POSTS,\n    subreddit\n  }\n}\n\nexport const RECEIVE_POSTS = 'RECEIVE_POSTS'\nfunction receivePosts(subreddit, json) {\n  return {\n    type: RECEIVE_POSTS,\n    subreddit,\n    posts: json.data.children.map(child =&gt; child.data),\n    receivedAt: Date.now()\n  }\n}\n\n// Meet our first thunk action creator!\n// Though its insides are different, you would use it just like any other action creator:\n// store.dispatch(fetchPosts('reactjs'))\n\nexport function fetchPosts(subreddit) {\n\n  // Thunk middleware knows how to handle functions.\n  // It passes the dispatch method as an argument to the function,\n  // thus making it able to dispatch actions itself.\n\n  return function (dispatch) {\n\n    // First dispatch: the app state is updated to inform\n    // that the API call is starting.\n\n    dispatch(requestPosts(subreddit))\n\n    // The function called by the thunk middleware can return a value,\n    // that is passed on as the return value of the dispatch method.\n\n    // In this case, we return a promise to wait for.\n    // This is not required by thunk middleware, but it is convenient for us.\n\n    return fetch(`http://www.reddit.com/r/${subreddit}.json`)\n      .then(response =&gt; response.json())\n      .then(json =&gt;\n\n        // We can dispatch many times!\n        // Here, we update the app state with the results of the API call.\n\n        dispatch(receivePosts(subreddit, json))\n      )\n\n      // In a real world app, you also want to\n      // catch any error in the network call.\n  }\n}\n</pre> <blockquote> <h5 id=\"note-on-fetch\">Note on <code>fetch</code>\n</h5> <p>We use <a href=\"https://developer.mozilla.org/en/docs/Web/API/Fetch_API\" target=\"_blank\"><code>fetch</code> API</a> in the examples. It is a new API for making network requests that replaces <code>XMLHttpRequest</code> for most common needs. Because most browsers don’t yet support it natively, we suggest that you use <a href=\"https://github.com/matthew-andrews/isomorphic-fetch\" target=\"_blank\"><code>isomorphic-fetch</code></a> library:</p> <pre data-language=\"js\">// Do this in every file where you use `fetch`\nimport fetch from 'isomorphic-fetch'\n</pre> <p>Internally, it uses <a href=\"https://github.com/github/fetch\" target=\"_blank\"><code>whatwg-fetch</code> polyfill</a> on the client, and <a href=\"https://github.com/bitinn/node-fetch\" target=\"_blank\"><code>node-fetch</code></a> on the server, so you won’t need to change API calls if you change your app to be <a href=\"https://medium.com/@mjackson/universal-javascript-4761051b7ae9\" target=\"_blank\">universal</a>.</p> <p>Be aware that any <code>fetch</code> polyfill assumes a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\">Promise</a> polyfill is already present. The easiest way to ensure you have a Promise polyfill is to enable Babel’s ES6 polyfill in your entry point before any other code runs:</p> <pre data-language=\"js\">// Do this once before any other code in your app\nimport 'babel-polyfill'\n</pre> </blockquote> <p>How do we include the Redux Thunk middleware in the dispatch mechanism? We use the <a href=\"../api/applymiddleware\"><code>applyMiddleware()</code></a> store enhancer from Redux, as shown below:</p> <h4 id=\"-index-js\"><code>index.js</code></h4> <pre data-language=\"js\">import thunkMiddleware from 'redux-thunk'\nimport createLogger from 'redux-logger'\nimport { createStore, applyMiddleware } from 'redux'\nimport { selectSubreddit, fetchPosts } from './actions'\nimport rootReducer from './reducers'\n\nconst loggerMiddleware = createLogger()\n\nconst store = createStore(\n  rootReducer,\n  applyMiddleware(\n    thunkMiddleware, // lets us dispatch() functions\n    loggerMiddleware // neat middleware that logs actions\n  )\n)\n\nstore.dispatch(selectSubreddit('reactjs'))\nstore.dispatch(fetchPosts('reactjs')).then(() =&gt;\n  console.log(store.getState())\n)\n</pre> <p>The nice thing about thunks is that they can dispatch results of each other:</p> <h4 id=\"-actions-js\"><code>actions.js</code></h4> <pre data-language=\"js\">import fetch from 'isomorphic-fetch'\n\nexport const REQUEST_POSTS = 'REQUEST_POSTS'\nfunction requestPosts(subreddit) {\n  return {\n    type: REQUEST_POSTS,\n    subreddit\n  }\n}\n\nexport const RECEIVE_POSTS = 'RECEIVE_POSTS'\nfunction receivePosts(subreddit, json) {\n  return {\n    type: RECEIVE_POSTS,\n    subreddit,\n    posts: json.data.children.map(child =&gt; child.data),\n    receivedAt: Date.now()\n  }\n}\n\nfunction fetchPosts(subreddit) {\n  return dispatch =&gt; {\n    dispatch(requestPosts(subreddit))\n    return fetch(`http://www.reddit.com/r/${subreddit}.json`)\n      .then(response =&gt; response.json())\n      .then(json =&gt; dispatch(receivePosts(subreddit, json)))\n  }\n}\n\nfunction shouldFetchPosts(state, subreddit) {\n  const posts = state.postsBySubreddit[subreddit]\n  if (!posts) {\n    return true\n  } else if (posts.isFetching) {\n    return false\n  } else {\n    return posts.didInvalidate\n  }\n}\n\nexport function fetchPostsIfNeeded(subreddit) {\n\n  // Note that the function also receives getState()\n  // which lets you choose what to dispatch next.\n\n  // This is useful for avoiding a network request if\n  // a cached value is already available.\n\n  return (dispatch, getState) =&gt; {\n    if (shouldFetchPosts(getState(), subreddit)) {\n      // Dispatch a thunk from thunk!\n      return dispatch(fetchPosts(subreddit))\n    } else {\n      // Let the calling code know there's nothing to wait for.\n      return Promise.resolve()\n    }\n  }\n}\n</pre> <p>This lets us write more sophisticated async control flow gradually, while the consuming code can stay pretty much the same:</p> <h4 id=\"-index-js\"><code>index.js</code></h4> <pre data-language=\"js\">store.dispatch(fetchPostsIfNeeded('reactjs')).then(() =&gt;\n  console.log(store.getState())\n)\n</pre> <blockquote> <h5 id=\"note-about-server-rendering\">Note about Server Rendering</h5> <p>Async action creators are especially convenient for server rendering. You can create a store, dispatch a single async action creator that dispatches other async action creators to fetch data for a whole section of your app, and only render after the Promise it returns, completes. Then your store will already be hydrated with the state you need before rendering.</p> </blockquote> <p><a href=\"https://github.com/gaearon/redux-thunk\" target=\"_blank\">Thunk middleware</a> isn’t the only way to orchestrate asynchronous actions in Redux. You can use <a href=\"https://github.com/acdlite/redux-promise\" target=\"_blank\">redux-promise</a> or <a href=\"https://github.com/pburtchaell/redux-promise-middleware\" target=\"_blank\">redux-promise-middleware</a> to dispatch Promises instead of functions. You can dispatch Observables with <a href=\"https://github.com/acdlite/redux-rx\" target=\"_blank\">redux-rx</a>. You can even write a custom middleware to describe calls to your API, like the <a href=\"../introduction/examples#real-world\">real world example</a> does. It is up to you to try a few options, choose a convention you like, and follow it, whether with, or without the middleware.</p> <h2 id=\"connecting-to-ui\">Connecting to UI</h2> <p>Dispatching async actions is no different from dispatching synchronous actions, so we won’t discuss this in detail. See <a href=\"../basics/usagewithreact\">Usage with React</a> for an introduction into using Redux from React components. See <a href=\"exampleredditapi\">Example: Reddit API</a> for the complete source code discussed in this example.</p> <h2 id=\"next-steps\">Next Steps</h2> <p>Read <a href=\"asyncflow\">Async Flow</a> to recap how async actions fit into the Redux flow.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/advanced/AsyncActions.html\" class=\"_attribution-link\">http://redux.js.org/docs/advanced/AsyncActions.html</a>\n  </p>\n</div>\n","advanced/middleware":"<h1 id=\"middleware\">Middleware</h1> <p>You’ve seen middleware in action in the <a href=\"asyncactions\">Async Actions</a> example. If you’ve used server-side libraries like <a href=\"http://expressjs.com/\" target=\"_blank\">Express</a> and <a href=\"http://koajs.com/\" target=\"_blank\">Koa</a>, you were also probably already familiar with the concept of <em>middleware</em>. In these frameworks, middleware is some code you can put between the framework receiving a request, and the framework generating a response. For example, Express or Koa middleware may add CORS headers, logging, compression, and more. The best feature of middleware is that it’s composable in a chain. You can use multiple independent third-party middleware in a single project.</p> <p>Redux middleware solves different problems than Express or Koa middleware, but in a conceptually similar way. <strong>It provides a third-party extension point between dispatching an action, and the moment it reaches the reducer.</strong> People use Redux middleware for logging, crash reporting, talking to an asynchronous API, routing, and more.</p> <p>This article is divided into an in-depth intro to help you grok the concept, and <a href=\"#seven-examples\">a few practical examples</a> to show the power of middleware at the very end. You may find it helpful to switch back and forth between them, as you flip between feeling bored and inspired.</p> <h2 id=\"understanding-middleware\">Understanding Middleware</h2> <p>While middleware can be used for a variety of things, including asynchronous API calls, it’s really important that you understand where it comes from. We’ll guide you through the thought process leading to middleware, by using logging and crash reporting as examples.</p> <h3 id=\"problem-logging\">Problem: Logging</h3> <p>One of the benefits of Redux is that it makes state changes predictable and transparent. Every time an action is dispatched, the new state is computed and saved. The state cannot change by itself, it can only change as a consequence of a specific action.</p> <p>Wouldn’t it be nice if we logged every action that happens in the app, together with the state computed after it? When something goes wrong, we can look back at our log, and figure out which action corrupted the state.</p> <p><img src=\"http://i.imgur.com/BjGBlES.png\" width=\"70%\"></p> <p>How do we approach this with Redux?</p> <h3 id=\"attempt-1-logging-manually\">Attempt #1: Logging Manually</h3> <p>The most naïve solution is just to log the action and the next state yourself every time you call <a href=\"../api/store#dispatch\"><code>store.dispatch(action)</code></a>. It’s not really a solution, but just a first step towards understanding the problem.</p> <blockquote> <h5 id=\"note\">Note</h5> <p>If you’re using <a href=\"https://github.com/gaearon/react-redux\" target=\"_blank\">react-redux</a> or similar bindings, you likely won’t have direct access to the store instance in your components. For the next few paragraphs, just assume you pass the store down explicitly.</p> </blockquote> <p>Say, you call this when creating a todo:</p> <pre data-language=\"js\">store.dispatch(addTodo('Use Redux'))\n</pre> <p>To log the action and state, you can change it to something like this:</p> <pre data-language=\"js\">let action = addTodo('Use Redux')\n\nconsole.log('dispatching', action)\nstore.dispatch(action)\nconsole.log('next state', store.getState())\n</pre> <p>This produces the desired effect, but you wouldn’t want to do it every time.</p> <h3 id=\"attempt-2-wrapping-dispatch\">Attempt #2: Wrapping Dispatch</h3> <p>You can extract logging into a function:</p> <pre data-language=\"js\">function dispatchAndLog(store, action) {\n  console.log('dispatching', action)\n  store.dispatch(action)\n  console.log('next state', store.getState())\n}\n</pre> <p>You can then use it everywhere instead of <code>store.dispatch()</code>:</p> <pre data-language=\"js\">dispatchAndLog(store, addTodo('Use Redux'))\n</pre> <p>We could end this here, but it’s not very convenient to import a special function every time.</p> <h3 id=\"attempt-3-monkeypatching-dispatch\">Attempt #3: Monkeypatching Dispatch</h3> <p>What if we just replace the <code>dispatch</code> function on the store instance? The Redux store is just a plain object with <a href=\"../api/store\">a few methods</a>, and we’re writing JavaScript, so we can just monkeypatch the <code>dispatch</code> implementation:</p> <pre data-language=\"js\">let next = store.dispatch\nstore.dispatch = function dispatchAndLog(action) {\n  console.log('dispatching', action)\n  let result = next(action)\n  console.log('next state', store.getState())\n  return result\n}\n</pre> <p>This is already closer to what we want! No matter where we dispatch an action, it is guaranteed to be logged. Monkeypatching never feels right, but we can live with this for now.</p> <h3 id=\"problem-crash-reporting\">Problem: Crash Reporting</h3> <p>What if we want to apply <strong>more than one</strong> such transformation to <code>dispatch</code>?</p> <p>A different useful transformation that comes to my mind is reporting JavaScript errors in production. The global <code>window.onerror</code> event is not reliable because it doesn’t provide stack information in some older browsers, which is crucial to understand why an error is happening.</p> <p>Wouldn’t it be useful if, any time an error is thrown as a result of dispatching an action, we would send it to a crash reporting service like <a href=\"https://getsentry.com/welcome/\" target=\"_blank\">Sentry</a> with the stack trace, the action that caused the error, and the current state? This way it’s much easier to reproduce the error in development.</p> <p>However, it is important that we keep logging and crash reporting separate. Ideally we want them to be different modules, potentially in different packages. Otherwise we can’t have an ecosystem of such utilities. (Hint: we’re slowly getting to what middleware is!)</p> <p>If logging and crash reporting are separate utilities, they might look like this:</p> <pre data-language=\"js\">function patchStoreToAddLogging(store) {\n  let next = store.dispatch\n  store.dispatch = function dispatchAndLog(action) {\n    console.log('dispatching', action)\n    let result = next(action)\n    console.log('next state', store.getState())\n    return result\n  }\n}\n\nfunction patchStoreToAddCrashReporting(store) {\n  let next = store.dispatch\n  store.dispatch = function dispatchAndReportErrors(action) {\n    try {\n      return next(action)\n    } catch (err) {\n      console.error('Caught an exception!', err)\n      Raven.captureException(err, {\n        extra: {\n          action,\n          state: store.getState()\n        }\n      })\n      throw err\n    }\n  }\n}\n</pre> <p>If these functions are published as separate modules, we can later use them to patch our store:</p> <pre data-language=\"js\">patchStoreToAddLogging(store)\npatchStoreToAddCrashReporting(store)\n</pre> <p>Still, this isn’t nice.</p> <h3 id=\"attempt-4-hiding-monkeypatching\">Attempt #4: Hiding Monkeypatching</h3> <p>Monkeypatching is a hack. “Replace any method you like”, what kind of API is that? Let’s figure out the essence of it instead. Previously, our functions replaced <code>store.dispatch</code>. What if they <em>returned</em> the new <code>dispatch</code> function instead?</p> <pre data-language=\"js\">function logger(store) {\n  let next = store.dispatch\n\n  // Previously:\n  // store.dispatch = function dispatchAndLog(action) {\n\n  return function dispatchAndLog(action) {\n    console.log('dispatching', action)\n    let result = next(action)\n    console.log('next state', store.getState())\n    return result\n  }\n}\n</pre> <p>We could provide a helper inside Redux that would apply the actual monkeypatching as an implementation detail:</p> <pre data-language=\"js\">function applyMiddlewareByMonkeypatching(store, middlewares) {\n  middlewares = middlewares.slice()\n  middlewares.reverse()\n\n  // Transform dispatch function with each middleware.\n  middlewares.forEach(middleware =&gt;\n    store.dispatch = middleware(store)\n  )\n}\n</pre> <p>We could use it to apply multiple middleware like this:</p> <pre data-language=\"js\">applyMiddlewareByMonkeypatching(store, [ logger, crashReporter ])\n</pre> <p>However, it is still monkeypatching.<br>The fact that we hide it inside the library doesn’t alter this fact.</p> <h3 id=\"attempt-5-removing-monkeypatching\">Attempt #5: Removing Monkeypatching</h3> <p>Why do we even overwrite <code>dispatch</code>? Of course, to be able to call it later, but there’s also another reason: so that every middleware can access (and call) the previously wrapped <code>store.dispatch</code>:</p> <pre data-language=\"js\">function logger(store) {\n  // Must point to the function returned by the previous middleware:\n  let next = store.dispatch\n\n  return function dispatchAndLog(action) {\n    console.log('dispatching', action)\n    let result = next(action)\n    console.log('next state', store.getState())\n    return result\n  }\n}\n</pre> <p>It is essential to chaining middleware!</p> <p>If <code>applyMiddlewareByMonkeypatching</code> doesn’t assign <code>store.dispatch</code> immediately after processing the first middleware, <code>store.dispatch</code> will keep pointing to the original <code>dispatch</code> function. Then the second middleware will also be bound to the original <code>dispatch</code> function.</p> <p>But there’s also a different way to enable chaining. The middleware could accept the <code>next()</code> dispatch function as a parameter instead of reading it from the <code>store</code> instance.</p> <pre data-language=\"js\">function logger(store) {\n  return function wrapDispatchToAddLogging(next) {\n    return function dispatchAndLog(action) {\n      console.log('dispatching', action)\n      let result = next(action)\n      console.log('next state', store.getState())\n      return result\n    }\n  }\n}\n</pre> <p>It’s a <a href=\"http://knowyourmeme.com/memes/we-need-to-go-deeper\" target=\"_blank\">“we need to go deeper”</a> kind of moment, so it might take a while for this to make sense. The function cascade feels intimidating. ES6 arrow functions make this <a href=\"https://en.wikipedia.org/wiki/Currying\" target=\"_blank\">currying</a> easier on eyes:</p> <pre data-language=\"js\">const logger = store =&gt; next =&gt; action =&gt; {\n  console.log('dispatching', action)\n  let result = next(action)\n  console.log('next state', store.getState())\n  return result\n}\n\nconst crashReporter = store =&gt; next =&gt; action =&gt; {\n  try {\n    return next(action)\n  } catch (err) {\n    console.error('Caught an exception!', err)\n    Raven.captureException(err, {\n      extra: {\n        action,\n        state: store.getState()\n      }\n    })\n    throw err\n  }\n}\n</pre> <p><strong>This is exactly what Redux middleware looks like.</strong></p> <p>Now middleware takes the <code>next()</code> dispatch function, and returns a dispatch function, which in turn serves as <code>next()</code> to the middleware to the left, and so on. It’s still useful to have access to some store methods like <code>getState()</code>, so <code>store</code> stays available as the top-level argument.</p> <h3 id=\"attempt-6-na%C3%AFvely-applying-the-middleware\">Attempt #6: Naïvely Applying the Middleware</h3> <p>Instead of <code>applyMiddlewareByMonkeypatching()</code>, we could write <code>applyMiddleware()</code> that first obtains the final, fully wrapped <code>dispatch()</code> function, and returns a copy of the store using it:</p> <pre data-language=\"js\">// Warning: Naïve implementation!\n// That's *not* Redux API.\n\nfunction applyMiddleware(store, middlewares) {\n  middlewares = middlewares.slice()\n  middlewares.reverse()\n\n  let dispatch = store.dispatch\n  middlewares.forEach(middleware =&gt;\n    dispatch = middleware(store)(dispatch)\n  )\n\n  return Object.assign({}, store, { dispatch })\n}\n</pre> <p>The implementation of <a href=\"../api/applymiddleware\"><code>applyMiddleware()</code></a> that ships with Redux is similar, but <strong>different in three important aspects</strong>:</p> <ul> <li>\n<p>It only exposes a subset of the <a href=\"../api/store\">store API</a> to the middleware: <a href=\"../api/store#dispatch\"><code>dispatch(action)</code></a> and <a href=\"../api/store#getState\"><code>getState()</code></a>.</p> </li> <li>\n<p>It does a bit of trickery to make sure that if you call <code>store.dispatch(action)</code> from your middleware instead of <code>next(action)</code>, the action will actually travel the whole middleware chain again, including the current middleware. This is useful for asynchronous middleware, as we have seen <a href=\"asyncactions\">previously</a>.</p> </li> <li>\n<p>To ensure that you may only apply middleware once, it operates on <code>createStore()</code> rather than on <code>store</code> itself. Instead of <code>(store, middlewares) =&gt; store</code>, its signature is <code>(...middlewares) =&gt; (createStore) =&gt; createStore</code>.</p> </li> </ul> <p>Because it is cumbersome to apply functions to <code>createStore()</code> before using it, <code>createStore()</code> accepts an optional last argument to specify such functions.</p> <h3 id=\"the-final-approach\">The Final Approach</h3> <p>Given this middleware we just wrote:</p> <pre data-language=\"js\">const logger = store =&gt; next =&gt; action =&gt; {\n  console.log('dispatching', action)\n  let result = next(action)\n  console.log('next state', store.getState())\n  return result\n}\n\nconst crashReporter = store =&gt; next =&gt; action =&gt; {\n  try {\n    return next(action)\n  } catch (err) {\n    console.error('Caught an exception!', err)\n    Raven.captureException(err, {\n      extra: {\n        action,\n        state: store.getState()\n      }\n    })\n    throw err\n  }\n}\n</pre> <p>Here’s how to apply it to a Redux store:</p> <pre data-language=\"js\">import { createStore, combineReducers, applyMiddleware } from 'redux'\n\nlet todoApp = combineReducers(reducers)\nlet store = createStore(\n  todoApp,\n  // applyMiddleware() tells createStore() how to handle middleware\n  applyMiddleware(logger, crashReporter)\n)\n</pre> <p>That’s it! Now any actions dispatched to the store instance will flow through <code>logger</code> and <code>crashReporter</code>:</p> <pre data-language=\"js\">// Will flow through both logger and crashReporter middleware!\nstore.dispatch(addTodo('Use Redux'))\n</pre> <h2 id=\"seven-examples\">Seven Examples</h2> <p>If your head boiled from reading the above section, imagine what it was like to write it. This section is meant to be a relaxation for you and me, and will help get your gears turning.</p> <p>Each function below is a valid Redux middleware. They are not equally useful, but at least they are equally fun.</p> <pre data-language=\"js\">/**\n * Logs all actions and states after they are dispatched.\n */\nconst logger = store =&gt; next =&gt; action =&gt; {\n  console.group(action.type)\n  console.info('dispatching', action)\n  let result = next(action)\n  console.log('next state', store.getState())\n  console.groupEnd(action.type)\n  return result\n}\n\n/**\n * Sends crash reports as state is updated and listeners are notified.\n */\nconst crashReporter = store =&gt; next =&gt; action =&gt; {\n  try {\n    return next(action)\n  } catch (err) {\n    console.error('Caught an exception!', err)\n    Raven.captureException(err, {\n      extra: {\n        action,\n        state: store.getState()\n      }\n    })\n    throw err\n  }\n}\n\n/**\n * Schedules actions with { meta: { delay: N } } to be delayed by N milliseconds.\n * Makes `dispatch` return a function to cancel the timeout in this case.\n */\nconst timeoutScheduler = store =&gt; next =&gt; action =&gt; {\n  if (!action.meta || !action.meta.delay) {\n    return next(action)\n  }\n\n  let timeoutId = setTimeout(\n    () =&gt; next(action),\n    action.meta.delay\n  )\n\n  return function cancel() {\n    clearTimeout(timeoutId)\n  }\n}\n\n/**\n * Schedules actions with { meta: { raf: true } } to be dispatched inside a rAF loop\n * frame.  Makes `dispatch` return a function to remove the action from the queue in\n * this case.\n */\nconst rafScheduler = store =&gt; next =&gt; {\n  let queuedActions = []\n  let frame = null\n\n  function loop() {\n    frame = null\n    try {\n      if (queuedActions.length) {\n        next(queuedActions.shift())\n      }\n    } finally {\n      maybeRaf()\n    }\n  }\n\n  function maybeRaf() {\n    if (queuedActions.length &amp;&amp; !frame) {\n      frame = requestAnimationFrame(loop)\n    }\n  }\n\n  return action =&gt; {\n    if (!action.meta || !action.meta.raf) {\n      return next(action)\n    }\n\n    queuedActions.push(action)\n    maybeRaf()\n\n    return function cancel() {\n      queuedActions = queuedActions.filter(a =&gt; a !== action)\n    }\n  }\n}\n\n/**\n * Lets you dispatch promises in addition to actions.\n * If the promise is resolved, its result will be dispatched as an action.\n * The promise is returned from `dispatch` so the caller may handle rejection.\n */\nconst vanillaPromise = store =&gt; next =&gt; action =&gt; {\n  if (typeof action.then !== 'function') {\n    return next(action)\n  }\n\n  return Promise.resolve(action).then(store.dispatch)\n}\n\n/**\n * Lets you dispatch special actions with a { promise } field.\n *\n * This middleware will turn them into a single action at the beginning,\n * and a single success (or failure) action when the `promise` resolves.\n *\n * For convenience, `dispatch` will return the promise so the caller can wait.\n */\nconst readyStatePromise = store =&gt; next =&gt; action =&gt; {\n  if (!action.promise) {\n    return next(action)\n  }\n\n  function makeAction(ready, data) {\n    let newAction = Object.assign({}, action, { ready }, data)\n    delete newAction.promise\n    return newAction\n  }\n\n  next(makeAction(false))\n  return action.promise.then(\n    result =&gt; next(makeAction(true, { result })),\n    error =&gt; next(makeAction(true, { error }))\n  )\n}\n\n/**\n * Lets you dispatch a function instead of an action.\n * This function will receive `dispatch` and `getState` as arguments.\n *\n * Useful for early exits (conditions over `getState()`), as well\n * as for async control flow (it can `dispatch()` something else).\n *\n * `dispatch` will return the return value of the dispatched function.\n */\nconst thunk = store =&gt; next =&gt; action =&gt;\n  typeof action === 'function' ?\n    action(store.dispatch, store.getState) :\n    next(action)\n\n\n// You can use all of them! (It doesn’t mean you should.)\nlet todoApp = combineReducers(reducers)\nlet store = createStore(\n  todoApp,\n  applyMiddleware(\n    rafScheduler,\n    timeoutScheduler,\n    thunk,\n    vanillaPromise,\n    readyStatePromise,\n    logger,\n    crashReporter\n  )\n)\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/advanced/Middleware.html\" class=\"_attribution-link\">http://redux.js.org/docs/advanced/Middleware.html</a>\n  </p>\n</div>\n","recipes/serverrendering":"<h1 id=\"server-rendering\">Server Rendering</h1> <p>The most common use case for server-side rendering is to handle the <em>initial render</em> when a user (or search engine crawler) first requests our app. When the server receives the request, it renders the required component(s) into an HTML string, and then sends it as a response to the client. From that point on, the client takes over rendering duties.</p> <p>We will use React in the examples below, but the same techniques can be used with other view frameworks that can render on the server.</p> <h3 id=\"redux-on-the-server\">Redux on the Server</h3> <p>When using Redux with server rendering, we must also send the state of our app along in our response, so the client can use it as the initial state. This is important because, if we preload any data before generating the HTML, we want the client to also have access to this data. Otherwise, the markup generated on the client won’t match the server markup, and the client would have to load the data again.</p> <p>To send the data down to the client, we need to:</p> <ul> <li>create a fresh, new Redux store instance on every request;</li> <li>optionally dispatch some actions;</li> <li>pull the state out of store;</li> <li>and then pass the state along to the client.</li> </ul> <p>On the client side, a new Redux store will be created and initialized with the state provided from the server.<br>Redux’s <strong><em>only</em></strong> job on the server side is to provide the <strong>initial state</strong> of our app.</p> <h2 id=\"setting-up\">Setting Up</h2> <p>In the following recipe, we are going to look at how to set up server-side rendering. We’ll use the simplistic <a href=\"https://github.com/reactjs/redux/tree/master/examples/counter\" target=\"_blank\">Counter app</a> as a guide and show how the server can render state ahead of time based on the request.</p> <h3 id=\"install-packages\">Install Packages</h3> <p>For this example, we’ll be using <a href=\"http://expressjs.com/\" target=\"_blank\">Express</a> as a simple web server. We also need to install the React bindings for Redux, since they are not included in Redux by default.</p> <pre>npm install --save express react-redux\n</pre>\n<h2 id=\"the-server-side\">The Server Side</h2> <p>The following is the outline for what our server side is going to look like. We are going to set up an <a href=\"http://expressjs.com/guide/using-middleware.html\" target=\"_blank\">Express middleware</a> using <a href=\"http://expressjs.com/api.html#app.use\" target=\"_blank\">app.use</a> to handle all requests that come in to our server. If you’re unfamiliar with Express or middleware, just know that our handleRender function will be called every time the server receives a request.</p> <h5 id=\"-server-js\"><code>server.js</code></h5> <pre data-language=\"js\">import path from 'path'\nimport Express from 'express'\nimport React from 'react'\nimport { createStore } from 'redux'\nimport { Provider } from 'react-redux'\nimport counterApp from './reducers'\nimport App from './containers/App'\n\nconst app = Express()\nconst port = 3000\n\n// This is fired every time the server side receives a request\napp.use(handleRender)\n\n// We are going to fill these out in the sections to follow\nfunction handleRender(req, res) { /* ... */ }\nfunction renderFullPage(html, initialState) { /* ... */ }\n\napp.listen(port)\n</pre> <h3 id=\"handling-the-request\">Handling the Request</h3> <p>The first thing that we need to do on every request is create a new Redux store instance. The only purpose of this store instance is to provide the initial state of our application.</p> <p>When rendering, we will wrap <code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>App</span> <span class=\"token punctuation\">/&gt;</span></span></code>, our root component, inside a <code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Provider</span><span class=\"token punctuation\">&gt;</span></span></code> to make the store available to all components in the component tree, as we saw in <a href=\"../basics/usagewithreact\">Usage with React</a>.</p> <p>The key step in server side rendering is to render the initial HTML of our component <em><strong>before</strong></em> we send it to the client side. To do this, we use <a href=\"https://facebook.github.io/react/docs/top-level-api.html#reactdomserver.rendertostring\" target=\"_blank\">ReactDOMServer.renderToString()</a>.</p> <p>We then get the initial state from our Redux store using <a href=\"../api/store#getState\"><code>store.getState()</code></a>. We will see how this is passed along in our <code>renderFullPage</code> function.</p> <pre data-language=\"js\">import { renderToString } from 'react-dom/server'\n\nfunction handleRender(req, res) {\n  // Create a new Redux store instance\n  const store = createStore(counterApp)\n\n  // Render the component to a string\n  const html = renderToString(\n    &lt;Provider store={store}&gt;\n      &lt;App /&gt;\n    &lt;/Provider&gt;\n  )\n\n  // Grab the initial state from our Redux store\n  const initialState = store.getState()\n\n  // Send the rendered page back to the client\n  res.send(renderFullPage(html, initialState))\n}\n</pre> <h3 id=\"inject-initial-component-html-and-state\">Inject Initial Component HTML and State</h3> <p>The final step on the server side is to inject our initial component HTML and initial state into a template to be rendered on the client side. To pass along the state, we add a <code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">&gt;</span></span></code> tag that will attach <code>initialState</code> to <code>window.__INITIAL_STATE__</code>.</p> <p>The <code>initialState</code> will then be available on the client side by accessing <code>window.__INITIAL_STATE__</code>.</p> <p>We also include our bundle file for the client-side application via a script tag. This is whatever output your bundling tool provides for your client entry point. It may be a static file or a URL to a hot reloading development server.</p> <pre data-language=\"js\">function renderFullPage(html, initialState) {\n  return `\n    &lt;!doctype html&gt;\n    &lt;html&gt;\n      &lt;head&gt;\n        &lt;title&gt;Redux Universal Example&lt;/title&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;div id=\"root\"&gt;${html}&lt;/div&gt;\n        &lt;script&gt;\n          window.__INITIAL_STATE__ = ${JSON.stringify(initialState)}\n        &lt;/script&gt;\n        &lt;script src=\"/static/bundle.js\"&gt;&lt;/script&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n    `\n}\n</pre> <blockquote> <h5 id=\"note-on-string-interpolation-syntax\">Note on String Interpolation Syntax</h5> <p>In the example above, we use ES6 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings\" target=\"_blank\">template strings</a> syntax. It lets us write multiline strings and interpolate values, but it requires ES6 support. If you’d like to write your Node code using ES6, check out <a href=\"https://babeljs.io/docs/usage/require/\" target=\"_blank\">Babel require hook</a> documentation. Or you can just keep writing ES5 code.</p> </blockquote> <h2 id=\"the-client-side\">The Client Side</h2> <p>The client side is very straightforward. All we need to do is grab the initial state from <code>window.__INITIAL_STATE__</code>, and pass it to our <a href=\"../api/createstore\"><code>createStore()</code></a> function as the initial state.</p> <p>Let’s take a look at our new client file:</p> <h4 id=\"-client-js\"><code>client.js</code></h4> <pre data-language=\"js\">import React from 'react'\nimport { render } from 'react-dom'\nimport { createStore } from 'redux'\nimport { Provider } from 'react-redux'\nimport App from './containers/App'\nimport counterApp from './reducers'\n\n// Grab the state from a global injected into server-generated HTML\nconst initialState = window.__INITIAL_STATE__\n\n// Create Redux store with initial state\nconst store = createStore(counterApp, initialState)\n\nrender(\n  &lt;Provider store={store}&gt;\n    &lt;App /&gt;\n  &lt;/Provider&gt;,\n  document.getElementById('root')\n)\n</pre> <p>You can set up your build tool of choice (Webpack, Browserify, etc.) to compile a bundle file into <code>dist/bundle.js</code>.</p> <p>When the page loads, the bundle file will be started up and <a href=\"https://facebook.github.io/react/docs/top-level-api.html#reactdom.render\" target=\"_blank\"><code>ReactDOM.render()</code></a> will hook into the <code>data-react-id</code> attributes from the server-rendered HTML. This will connect our newly-started React instance to the virtual DOM used on the server. Since we have the same initial state for our Redux store and used the same code for all our view components, the result will be the same real DOM.</p> <p>And that’s it! That is all we need to do to implement server side rendering.</p> <p>But the result is pretty vanilla. It essentially renders a static view from dynamic code. What we need to do next is build an initial state dynamically to allow that rendered view to be dynamic.</p> <h2 id=\"preparing-the-initial-state\">Preparing the Initial State</h2> <p>Because the client side executes ongoing code, it can start with an empty initial state and obtain any necessary state on demand and over time. On the server side, rendering is synchronous and we only get one shot to render our view. We need to be able to compile our initial state during the request, which will have to react to input and obtain external state (such as that from an API or database).</p> <h3 id=\"processing-request-parameters\">Processing Request Parameters</h3> <p>The only input for server side code is the request made when loading up a page in your app in your browser. You may choose to configure the server during its boot (such as when you are running in a development vs. production environment), but that configuration is static.</p> <p>The request contains information about the URL requested, including any query parameters, which will be useful when using something like <a href=\"https://github.com/reactjs/react-router\" target=\"_blank\">React Router</a>. It can also contain headers with inputs like cookies or authorization, or POST body data. Let’s see how we can set the initial counter state based on a query parameter.</p> <h4 id=\"-server-js\"><code>server.js</code></h4> <pre data-language=\"js\">import qs from 'qs' // Add this at the top of the file\nimport { renderToString } from 'react-dom/server'\n\nfunction handleRender(req, res) {\n  // Read the counter from the request, if provided\n  const params = qs.parse(req.query)\n  const counter = parseInt(params.counter, 10) || 0\n\n  // Compile an initial state\n  let initialState = { counter }\n\n  // Create a new Redux store instance\n  const store = createStore(counterApp, initialState)\n\n  // Render the component to a string\n  const html = renderToString(\n    &lt;Provider store={store}&gt;\n      &lt;App /&gt;\n    &lt;/Provider&gt;\n  )\n\n  // Grab the initial state from our Redux store\n  const finalState = store.getState()\n\n  // Send the rendered page back to the client\n  res.send(renderFullPage(html, finalState))\n}\n</pre> <p>The code reads from the Express <code>Request</code> object passed into our server middleware. The parameter is parsed into a number and then set in the initial state. If you visit <a href=\"http://localhost:3000/?counter=100\" target=\"_blank\">http://localhost:3000/?counter=100</a> in your browser, you’ll see the counter starts at 100. In the rendered HTML, you’ll see the counter output as 100 and the <code>__INITIAL_STATE__</code> variable has the counter set in it.</p> <h3 id=\"async-state-fetching\">Async State Fetching</h3> <p>The most common issue with server side rendering is dealing with state that comes in asynchronously. Rendering on the server is synchronous by nature, so it’s necessary to map any asynchronous fetches into a synchronous operation.</p> <p>The easiest way to do this is to pass through some callback back to your synchronous code. In this case, that will be a function that will reference the response object and send back our rendered HTML to the client. Don’t worry, it’s not as hard as it may sound.</p> <p>For our example, we’ll imagine there is an external datastore that contains the counter’s initial value (Counter As A Service, or CaaS). We’ll make a mock call over to them and build our initial state from the result. We’ll start by building out our API call:</p> <h4 id=\"-api-counter-js\"><code>api/counter.js</code></h4> <pre data-language=\"js\">function getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min)) + min\n}\n\nexport function fetchCounter(callback) {\n  setTimeout(() =&gt; {\n    callback(getRandomInt(1, 100))\n  }, 500)\n}\n</pre> <p>Again, this is just a mock API, so we use <code>setTimeout</code> to simulate a network request that takes 500 milliseconds to respond (this should be much faster with a real world API). We pass in a callback that returns a random number asynchronously. If you’re using a Promise-based API client, then you would issue this callback in your <code>then</code> handler.</p> <p>On the server side, we simply wrap our existing code in the <code>fetchCounter</code> and receive the result in the callback:</p> <h4 id=\"-server-js\"><code>server.js</code></h4> <pre data-language=\"js\">// Add this to our imports\nimport { fetchCounter } from './api/counter'\nimport { renderToString } from 'react-dom/server'\n\nfunction handleRender(req, res) {\n  // Query our mock API asynchronously\n  fetchCounter(apiResult =&gt; {\n    // Read the counter from the request, if provided\n    const params = qs.parse(req.query)\n    const counter = parseInt(params.counter, 10) || apiResult || 0\n\n    // Compile an initial state\n    let initialState = { counter }\n\n    // Create a new Redux store instance\n    const store = createStore(counterApp, initialState)\n\n    // Render the component to a string\n    const html = renderToString(\n      &lt;Provider store={store}&gt;\n        &lt;App /&gt;\n      &lt;/Provider&gt;\n    )\n\n    // Grab the initial state from our Redux store\n    const finalState = store.getState()\n\n    // Send the rendered page back to the client\n    res.send(renderFullPage(html, finalState))\n  })\n}\n</pre> <p>Because we call <code>res.send()</code> inside of the callback, the server will hold open the connection and won’t send any data until that callback executes. You’ll notice a 500ms delay is now added to each server request as a result of our new API call. A more advanced usage would handle errors in the API gracefully, such as a bad response or timeout.</p> <h3 id=\"security-considerations\">Security Considerations</h3> <p>Because we have introduced more code that relies on user generated content (UGC) and input, we have increased our attack surface area for our application. It is important for any application that you ensure your input is properly sanitized to prevent things like cross-site scripting (XSS) attacks or code injections.</p> <p>In our example, we take a rudimentary approach to security. When we obtain the parameters from the request, we use <code>parseInt</code> on the <code>counter</code> parameter to ensure this value is a number. If we did not do this, you could easily get dangerous data into the rendered HTML by providing a script tag in the request. That might look like this: <code>?counter=<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">&gt;</span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">&gt;</span></span>doSomethingBad();<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">&gt;</span></span></code></p> <p>For our simplistic example, coercing our input into a number is sufficiently secure. If you’re handling more complex input, such as freeform text, then you should run that input through an appropriate sanitization function, such as <a href=\"https://www.npmjs.com/package/validator\" target=\"_blank\">validator.js</a>.</p> <p>Furthermore, you can add additional layers of security by sanitizing your state output. <code>JSON.stringify</code> can be subject to script injections. To counter this, you can scrub the JSON string of HTML tags and other dangerous characters. This can be done with either a simple text replacement on the string or via more sophisticated libraries such as <a href=\"https://github.com/yahoo/serialize-javascript\" target=\"_blank\">serialize-javascript</a>.</p> <h2 id=\"next-steps\">Next Steps</h2> <p>You may want to read <a href=\"../advanced/asyncactions\">Async Actions</a> to learn more about expressing asynchronous flow in Redux with async primitives such as Promises and thunks. Keep in mind that anything you learn there can also be applied to universal rendering.</p> <p>If you use something like <a href=\"https://github.com/reactjs/react-router\" target=\"_blank\">React Router</a>, you might also want to express your data fetching dependencies as static <code>fetchData()</code> methods on your route handler components. They may return <a href=\"../advanced/asyncactions\">async actions</a>, so that your <code>handleRender</code> function can match the route to the route handler component classes, dispatch <code>fetchData()</code> result for each of them, and render only after the Promises have resolved. This way the specific API calls required for different routes are colocated with the route handler component definitions. You can also use the same technique on the client side to prevent the router from switching the page until its data has been loaded.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/recipes/ServerRendering.html\" class=\"_attribution-link\">http://redux.js.org/docs/recipes/ServerRendering.html</a>\n  </p>\n</div>\n","advanced/exampleredditapi":"<h1 id=\"example-reddit-api\">Example: Reddit API</h1> <p>This is the complete source code of the Reddit headline fetching example we built during the <a href=\"index\">advanced tutorial</a>.</p> <h2 id=\"entry-point\">Entry Point</h2> <h4 id=\"-index-js\"><code>index.js</code></h4> <pre data-language=\"js\">import 'babel-polyfill'\n\nimport React from 'react'\nimport { render } from 'react-dom'\nimport Root from './containers/Root'\n\nrender(\n  &lt;Root /&gt;,\n  document.getElementById('root')\n)\n</pre> <h2 id=\"action-creators-and-constants\">Action Creators and Constants</h2> <h4 id=\"-actions-js\"><code>actions.js</code></h4> <pre data-language=\"js\">import fetch from 'isomorphic-fetch'\n\nexport const REQUEST_POSTS = 'REQUEST_POSTS'\nexport const RECEIVE_POSTS = 'RECEIVE_POSTS'\nexport const SELECT_SUBREDDIT = 'SELECT_SUBREDDIT'\nexport const INVALIDATE_SUBREDDIT = 'INVALIDATE_SUBREDDIT'\n\nexport function selectSubreddit(subreddit) {\n  return {\n    type: SELECT_SUBREDDIT,\n    subreddit\n  }\n}\n\nexport function invalidateSubreddit(subreddit) {\n  return {\n    type: INVALIDATE_SUBREDDIT,\n    subreddit\n  }\n}\n\nfunction requestPosts(subreddit) {\n  return {\n    type: REQUEST_POSTS,\n    subreddit\n  }\n}\n\nfunction receivePosts(subreddit, json) {\n  return {\n    type: RECEIVE_POSTS,\n    subreddit,\n    posts: json.data.children.map(child =&gt; child.data),\n    receivedAt: Date.now()\n  }\n}\n\nfunction fetchPosts(subreddit) {\n  return dispatch =&gt; {\n    dispatch(requestPosts(subreddit))\n    return fetch(`http://www.reddit.com/r/${subreddit}.json`)\n      .then(response =&gt; response.json())\n      .then(json =&gt; dispatch(receivePosts(subreddit, json)))\n  }\n}\n\nfunction shouldFetchPosts(state, subreddit) {\n  const posts = state.postsBySubreddit[subreddit]\n  if (!posts) {\n    return true\n  } else if (posts.isFetching) {\n    return false\n  } else {\n    return posts.didInvalidate\n  }\n}\n\nexport function fetchPostsIfNeeded(subreddit) {\n  return (dispatch, getState) =&gt; {\n    if (shouldFetchPosts(getState(), subreddit)) {\n      return dispatch(fetchPosts(subreddit))\n    }\n  }\n}\n</pre> <h2 id=\"reducers\">Reducers</h2> <h4 id=\"-reducers-js\"><code>reducers.js</code></h4> <pre data-language=\"js\">import { combineReducers } from 'redux'\nimport {\n  SELECT_SUBREDDIT, INVALIDATE_SUBREDDIT,\n  REQUEST_POSTS, RECEIVE_POSTS\n} from './actions'\n\nfunction selectedSubreddit(state = 'reactjs', action) {\n  switch (action.type) {\n  case SELECT_SUBREDDIT:\n    return action.subreddit\n  default:\n    return state\n  }\n}\n\nfunction posts(state = {\n  isFetching: false,\n  didInvalidate: false,\n  items: []\n}, action) {\n  switch (action.type) {\n    case INVALIDATE_SUBREDDIT:\n      return Object.assign({}, state, {\n        didInvalidate: true\n      })\n    case REQUEST_POSTS:\n      return Object.assign({}, state, {\n        isFetching: true,\n        didInvalidate: false\n      })\n    case RECEIVE_POSTS:\n      return Object.assign({}, state, {\n        isFetching: false,\n        didInvalidate: false,\n        items: action.posts,\n        lastUpdated: action.receivedAt\n      })\n    default:\n      return state\n  }\n}\n\nfunction postsBySubreddit(state = { }, action) {\n  switch (action.type) {\n    case INVALIDATE_SUBREDDIT:\n    case RECEIVE_POSTS:\n    case REQUEST_POSTS:\n      return Object.assign({}, state, {\n        [action.subreddit]: posts(state[action.subreddit], action)\n      })\n    default:\n      return state\n  }\n}\n\nconst rootReducer = combineReducers({\n  postsBySubreddit,\n  selectedSubreddit\n})\n\nexport default rootReducer\n</pre> <h2 id=\"store\">Store</h2> <h4 id=\"-configurestore-js\"><code>configureStore.js</code></h4> <pre data-language=\"js\">import { createStore, applyMiddleware } from 'redux'\nimport thunkMiddleware from 'redux-thunk'\nimport createLogger from 'redux-logger'\nimport rootReducer from './reducers'\n\nconst loggerMiddleware = createLogger()\n\nexport default function configureStore(initialState) {\n  return createStore(\n    rootReducer,\n    initialState,\n    applyMiddleware(\n      thunkMiddleware,\n      loggerMiddleware\n    )\n  )\n}\n</pre> <h2 id=\"container-components\">Container Components</h2> <h4 id=\"-containers-root-js\"><code>containers/Root.js</code></h4> <pre data-language=\"js\">import React, { Component } from 'react'\nimport { Provider } from 'react-redux'\nimport configureStore from '../configureStore'\nimport AsyncApp from './AsyncApp'\n\nconst store = configureStore()\n\nexport default class Root extends Component {\n  render() {\n    return (\n      &lt;Provider store={store}&gt;\n        &lt;AsyncApp /&gt;\n      &lt;/Provider&gt;\n    )\n  }\n}\n</pre> <h4 id=\"-containers-asyncapp-js\"><code>containers/AsyncApp.js</code></h4> <pre data-language=\"js\">import React, { Component, PropTypes } from 'react'\nimport { connect } from 'react-redux'\nimport { selectSubreddit, fetchPostsIfNeeded, invalidateSubreddit } from '../actions'\nimport Picker from '../components/Picker'\nimport Posts from '../components/Posts'\n\nclass AsyncApp extends Component {\n  constructor(props) {\n    super(props)\n    this.handleChange = this.handleChange.bind(this)\n    this.handleRefreshClick = this.handleRefreshClick.bind(this)\n  }\n\n  componentDidMount() {\n    const { dispatch, selectedSubreddit } = this.props\n    dispatch(fetchPostsIfNeeded(selectedSubreddit))\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.selectedSubreddit !== this.props.selectedSubreddit) {\n      const { dispatch, selectedSubreddit } = nextProps\n      dispatch(fetchPostsIfNeeded(selectedSubreddit))\n    }\n  }\n\n  handleChange(nextSubreddit) {\n    this.props.dispatch(selectSubreddit(nextSubreddit))\n  }\n\n  handleRefreshClick(e) {\n    e.preventDefault()\n\n    const { dispatch, selectedSubreddit } = this.props\n    dispatch(invalidateSubreddit(selectedSubreddit))\n    dispatch(fetchPostsIfNeeded(selectedSubreddit))\n  }\n\n  render() {\n    const { selectedSubreddit, posts, isFetching, lastUpdated } = this.props\n    return (\n      &lt;div&gt;\n        &lt;Picker value={selectedSubreddit}\n                onChange={this.handleChange}\n                options={[ 'reactjs', 'frontend' ]} /&gt;\n        &lt;p&gt;\n          {lastUpdated &amp;&amp;\n            &lt;span&gt;\n              Last updated at {new Date(lastUpdated).toLocaleTimeString()}.\n              {' '}\n            &lt;/span&gt;\n          }\n          {!isFetching &amp;&amp;\n            &lt;a href='#'\n               onClick={this.handleRefreshClick}&gt;\n              Refresh\n            &lt;/a&gt;\n          }\n        &lt;/p&gt;\n        {isFetching &amp;&amp; posts.length === 0 &amp;&amp;\n          &lt;h2&gt;Loading...&lt;/h2&gt;\n        }\n        {!isFetching &amp;&amp; posts.length === 0 &amp;&amp;\n          &lt;h2&gt;Empty.&lt;/h2&gt;\n        }\n        {posts.length &gt; 0 &amp;&amp;\n          &lt;div style={{ opacity: isFetching ? 0.5 : 1 }}&gt;\n            &lt;Posts posts={posts} /&gt;\n          &lt;/div&gt;\n        }\n      &lt;/div&gt;\n    )\n  }\n}\n\nAsyncApp.propTypes = {\n  selectedSubreddit: PropTypes.string.isRequired,\n  posts: PropTypes.array.isRequired,\n  isFetching: PropTypes.bool.isRequired,\n  lastUpdated: PropTypes.number,\n  dispatch: PropTypes.func.isRequired\n}\n\nfunction mapStateToProps(state) {\n  const { selectedSubreddit, postsBySubreddit } = state\n  const {\n    isFetching,\n    lastUpdated,\n    items: posts\n  } = postsBySubreddit[selectedSubreddit] || {\n    isFetching: true,\n    items: []\n  }\n\n  return {\n    selectedSubreddit,\n    posts,\n    isFetching,\n    lastUpdated\n  }\n}\n\nexport default connect(mapStateToProps)(AsyncApp)\n</pre> <h2 id=\"presentational-components\">Presentational Components</h2> <h4 id=\"-components-picker-js\"><code>components/Picker.js</code></h4> <pre data-language=\"js\">import React, { Component, PropTypes } from 'react'\n\nexport default class Picker extends Component {\n  render() {\n    const { value, onChange, options } = this.props\n\n    return (\n      &lt;span&gt;\n        &lt;h1&gt;{value}&lt;/h1&gt;\n        &lt;select onChange={e =&gt; onChange(e.target.value)}\n                value={value}&gt;\n          {options.map(option =&gt;\n            &lt;option value={option} key={option}&gt;\n              {option}\n            &lt;/option&gt;)\n          }\n        &lt;/select&gt;\n      &lt;/span&gt;\n    )\n  }\n}\n\nPicker.propTypes = {\n  options: PropTypes.arrayOf(\n    PropTypes.string.isRequired\n  ).isRequired,\n  value: PropTypes.string.isRequired,\n  onChange: PropTypes.func.isRequired\n}\n</pre> <h4 id=\"-components-posts-js\"><code>components/Posts.js</code></h4> <pre data-language=\"js\">import React, { PropTypes, Component } from 'react'\n\nexport default class Posts extends Component {\n  render() {\n    return (\n      &lt;ul&gt;\n        {this.props.posts.map((post, i) =&gt;\n          &lt;li key={i}&gt;{post.title}&lt;/li&gt;\n        )}\n      &lt;/ul&gt;\n    )\n  }\n}\n\nPosts.propTypes = {\n  posts: PropTypes.array.isRequired\n}\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/advanced/ExampleRedditAPI.html\" class=\"_attribution-link\">http://redux.js.org/docs/advanced/ExampleRedditAPI.html</a>\n  </p>\n</div>\n","api/createstore":"<h1 id=\"-createstore-reducer-initialstate-enhancer\">createStore(reducer, [initialState], [enhancer])</h1> <p>Creates a Redux <a href=\"store\">store</a> that holds the complete state tree of your app.<br>There should only be a single store in your app.</p> <h4 id=\"arguments\">Arguments</h4> <ol> <li>\n<p><code>reducer</code> <em>(Function)</em>: A <a href=\"../glossary#reducer\">reducing function</a> that returns the next <a href=\"../glossary#state\">state tree</a>, given the current state tree and an <a href=\"../glossary#action\">action</a> to handle.</p> </li> <li>\n<p>[<code>initialState</code>] <em>(any)</em>: The initial state. You may optionally specify it to hydrate the state from the server in universal apps, or to restore a previously serialized user session. If you produced <code>reducer</code> with <a href=\"combinereducers\"><code>combineReducers</code></a>, this must be a plain object with the same shape as the keys passed to it. Otherwise, you are free to pass anything that your <code>reducer</code> can understand.</p> </li> <li>\n<p>[<code>enhancer</code>] <em>(Function)</em>: The store enhancer. You may optionally specify it to enhance the store with third-party capabilities such as middleware, time travel, persistence, etc. The only store enhancer that ships with Redux is <a href=\"applymiddleware\"><code>applyMiddleware()</code></a>.</p> </li> </ol> <h4 id=\"returns\">Returns</h4> <p>(<a href=\"store\"><em><code>Store</code></em></a>): An object that holds the complete state of your app. The only way to change its state is by <a href=\"store#dispatch\">dispatching actions</a>. You may also <a href=\"store#subscribe\">subscribe</a> to the changes to its state to update the UI.</p> <h4 id=\"example\">Example</h4> <pre data-language=\"js\">import { createStore } from 'redux'\n\nfunction todos(state = [], action) {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return state.concat([ action.text ])\n    default:\n      return state\n  }\n}\n\nlet store = createStore(todos, [ 'Use Redux' ])\n\nstore.dispatch({\n  type: 'ADD_TODO',\n  text: 'Read the docs'\n})\n\nconsole.log(store.getState())\n// [ 'Use Redux', 'Read the docs' ]\n</pre> <h4 id=\"tips\">Tips</h4> <ul> <li>\n<p>Don’t create more than one store in an application! Instead, use <a href=\"combinereducers\"><code>combineReducers</code></a> to create a single root reducer out of many.</p> </li> <li>\n<p>It is up to you to choose the state format. You can use plain objects or something like <a href=\"http://facebook.github.io/immutable-js/\" target=\"_blank\">Immutable</a>. If you’re not sure, start with plain objects.</p> </li> <li>\n<p>If your state is a plain object, make sure you never mutate it! For example, instead of returning something like <code>Object.assign(state, newData)</code> from your reducers, return <code>Object.assign({}, state, newData)</code>. This way you don’t override the previous <code>state</code>. You can also write <code>return { ...state, ...newData }</code> if you enable the <a href=\"../recipes/usingobjectspreadoperator\">object spread operator proposal</a>.</p> </li> <li>\n<p>For universal apps that run on the server, create a store instance with every request so that they are isolated. Dispatch a few data fetching actions to a store instance and wait for them to complete before rendering the app on the server.</p> </li> <li>\n<p>When a store is created, Redux dispatches a dummy action to your reducer to populate the store with the initial state. You are not meant to handle the dummy action directly. Just remember that your reducer should return some kind of initial state if the state given to it as the first argument is <code>undefined</code>, and you’re all set.</p> </li> <li>\n<p>To apply multiple store enhancers, you may use <a href=\"compose\"><code>compose()</code></a>.</p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/api/createStore.html\" class=\"_attribution-link\">http://redux.js.org/docs/api/createStore.html</a>\n  </p>\n</div>\n","api/compose":"<h1 id=\"-compose-functions\">compose(...functions)</h1> <p>Composes functions from right to left.</p> <p>This is a functional programming utility, and is included in Redux as a convenience.<br>You might want to use it to apply several <a href=\"../glossary#store-enhancer\">store enhancers</a> in a row.</p> <h4 id=\"arguments\">Arguments</h4> <ol> <li>(<em>arguments</em>): The functions to compose. Each function is expected to accept a single parameter. Its return value will be provided as an argument to the function standing to the left, and so on. The exception is the right-most argument which can accept multiple parameters, as it will provide the signature for the resulting composed function.</li> </ol> <h4 id=\"returns\">Returns</h4> <p>(<em>Function</em>): The final function obtained by composing the given functions from right to left.</p> <h4 id=\"example\">Example</h4> <p>This example demonstrates how to use <code>compose</code> to enhance a <a href=\"store\">store</a> with <a href=\"applymiddleware\"><code>applyMiddleware</code></a> and a few developer tools from the <a href=\"https://github.com/gaearon/redux-devtools\" target=\"_blank\">redux-devtools</a> package.</p> <pre data-language=\"js\">import { createStore, combineReducers, applyMiddleware, compose } from 'redux'\nimport thunk from 'redux-thunk'\nimport DevTools from './containers/DevTools'\nimport reducer from '../reducers/index'\n\nconst store = createStore(\n  reducer,\n  compose(\n    applyMiddleware(thunk),\n    DevTools.instrument()\n  )\n)\n</pre> <h4 id=\"tips\">Tips</h4> <ul> <li>All <code>compose</code> does is let you write deeply nested function transformations without the rightward drift of the code. Don’t give it too much credit!</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/api/compose.html\" class=\"_attribution-link\">http://redux.js.org/docs/api/compose.html</a>\n  </p>\n</div>\n","recipes/reducingboilerplate":"<h1 id=\"reducing-boilerplate\">Reducing Boilerplate</h1> <p>Redux is in part <a href=\"../introduction/priorart\">inspired by Flux</a>, and the most common complaint about Flux is how it makes you write a lot of boilerplate. In this recipe, we will consider how Redux lets us choose how verbose we’d like our code to be, depending on personal style, team preferences, longer term maintainability, and so on.</p> <h2 id=\"actions\">Actions</h2> <p>Actions are plain objects describing what happened in the app, and serve as the sole way to describe an intention to mutate the data. It’s important that <strong>actions being objects you have to dispatch is not boilerplate, but one of the <a href=\"../introduction/threeprinciples\">fundamental design choices</a> of Redux</strong>.</p> <p>There are frameworks claiming to be similar to Flux, but without a concept of action objects. In terms of being predictable, this is a step backwards from Flux or Redux. If there are no serializable plain object actions, it is impossible to record and replay user sessions, or to implement <a href=\"https://www.youtube.com/watch?v=xsSnOQynTHs\" target=\"_blank\">hot reloading with time travel</a>. If you’d rather modify data directly, you don’t need Redux.</p> <p>Actions look like this:</p> <pre data-language=\"js\">{ type: 'ADD_TODO', text: 'Use Redux' }\n{ type: 'REMOVE_TODO', id: 42 }\n{ type: 'LOAD_ARTICLE', response: { ... } }\n</pre> <p>It is a common convention that actions have a constant type that helps reducers (or Stores in Flux) identify them. We recommend that you use strings and not <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol\" target=\"_blank\">Symbols</a> for action types, because strings are serializable, and by using Symbols you make recording and replaying harder than it needs to be.</p> <p>In Flux, it is traditionally thought that you would define every action type as a string constant:</p> <pre data-language=\"js\">const ADD_TODO = 'ADD_TODO'\nconst REMOVE_TODO = 'REMOVE_TODO'\nconst LOAD_ARTICLE = 'LOAD_ARTICLE'\n</pre> <p>Why is this beneficial? <strong>It is often claimed that constants are unnecessary, and for small projects, this might be correct.</strong> For larger projects, there are some benefits to defining action types as constants:</p> <ul> <li>It helps keep the naming consistent because all action types are gathered in a single place.</li> <li>Sometimes you want to see all existing actions before working on a new feature. It may be that the action you need was already added by somebody on the team, but you didn’t know.</li> <li>The list of action types that were added, removed, and changed in a Pull Request helps everyone on the team keep track of scope and implementation of new features.</li> <li>If you make a typo when importing an action constant, you will get <code>undefined</code>. Redux will immediately throw when dispatching such an action, and you’ll find the mistake sooner.</li> </ul> <p>It is up to you to choose the conventions for your project. You may start by using inline strings, and later transition to constants, and maybe later group them into a single file. Redux does not have any opinion here, so use your best judgment.</p> <h2 id=\"action-creators\">Action Creators</h2> <p>It is another common convention that, instead of creating action objects inline in the places where you dispatch the actions, you would create functions generating them.</p> <p>For example, instead of calling <code>dispatch</code> with an object literal:</p> <pre data-language=\"js\">// somewhere in an event handler\ndispatch({\n  type: 'ADD_TODO',\n  text: 'Use Redux'\n})\n</pre> <p>You might write an action creator in a separate file, and import it from your component:</p> <h4 id=\"-actioncreators-js\"><code>actionCreators.js</code></h4> <pre data-language=\"js\">export function addTodo(text) {\n  return {\n    type: 'ADD_TODO',\n    text\n  }\n}\n</pre> <h4 id=\"-addtodo-js\"><code>AddTodo.js</code></h4> <pre data-language=\"js\">import { addTodo } from './actionCreators'\n\n// somewhere in an event handler\ndispatch(addTodo('Use Redux'))\n</pre> <p>Action creators have often been criticized as boilerplate. Well, you don’t have to write them! <strong>You can use object literals if you feel this better suits your project.</strong> There are, however, some benefits for writing action creators you should know about.</p> <p>Let’s say a designer comes back to us after reviewing our prototype, and tells that we need to allow three todos maximum. We can enforce this by rewriting our action creator to a callback form with <a href=\"https://github.com/gaearon/redux-thunk\" target=\"_blank\">redux-thunk</a> middleware and adding an early exit:</p> <pre data-language=\"js\">function addTodoWithoutCheck(text) {\n  return {\n    type: 'ADD_TODO',\n    text\n  }\n}\n\nexport function addTodo(text) {\n  // This form is allowed by Redux Thunk middleware\n  // described below in “Async Action Creators” section.\n  return function (dispatch, getState) {\n    if (getState().todos.length === 3) {\n      // Exit early\n      return\n    }\n\n    dispatch(addTodoWithoutCheck(text))\n  }\n}\n</pre> <p>We just modified how the <code>addTodo</code> action creator behaves, completely invisible to the calling code. <strong>We don’t have to worry about looking at each place where todos are being added, to make sure they have this check.</strong> Action creators let you decouple additional logic around dispatching an action, from the actual components emitting those actions. It’s very handy when the application is under heavy development, and the requirements change often.</p> <h3 id=\"generating-action-creators\">Generating Action Creators</h3> <p>Some frameworks like <a href=\"https://github.com/acdlite/flummox\" target=\"_blank\">Flummox</a> generate action type constants automatically from the action creator function definitions. The idea is that you don’t need to both define <code>ADD_TODO</code> constant and <code>addTodo()</code> action creator. Under the hood, such solutions still generate action type constants, but they’re created implicitly so it’s a level of indirection and can cause confusion. We recommend creating your action type constants explicitly.</p> <p>Writing simple action creators can be tiresome and often ends up generating redundant boilerplate code:</p> <pre data-language=\"js\">export function addTodo(text) {\n  return {\n    type: 'ADD_TODO',\n    text\n  }\n}\n\nexport function editTodo(id, text) {\n  return {\n    type: 'EDIT_TODO',\n    id,\n    text\n  }\n}\n\nexport function removeTodo(id) {\n  return {\n    type: 'REMOVE_TODO',\n    id\n  }\n}\n</pre> <p>You can always write a function that generates an action creator:</p> <pre data-language=\"js\">function makeActionCreator(type, ...argNames) {\n  return function(...args) {\n    let action = { type }\n    argNames.forEach((arg, index) =&gt; {\n      action[argNames[index]] = args[index]\n    })\n    return action\n  }\n}\n\nconst ADD_TODO = 'ADD_TODO'\nconst EDIT_TODO = 'EDIT_TODO'\nconst REMOVE_TODO = 'REMOVE_TODO'\n\nexport const addTodo = makeActionCreator(ADD_TODO, 'todo')\nexport const editTodo = makeActionCreator(EDIT_TODO, 'id', 'todo')\nexport const removeTodo = makeActionCreator(REMOVE_TODO, 'id')\n</pre> <p>There are also utility libraries to aid in generating action creators, such as <a href=\"https://github.com/pauldijou/redux-act\" target=\"_blank\">redux-act</a> and <a href=\"https://github.com/acdlite/redux-actions\" target=\"_blank\">redux-actions</a>. These can help reduce boilerplate code and enforce adherence to standards such as <a href=\"https://github.com/acdlite/flux-standard-action\" target=\"_blank\">Flux Standard Action (FSA)</a>.</p> <h2 id=\"async-action-creators\">Async Action Creators</h2> <p><a href=\"../glossary#middleware\">Middleware</a> lets you inject custom logic that interprets every action object before it is dispatched. Async actions are the most common use case for middleware.</p> <p>Without any middleware, <a href=\"../api/store#dispatch\"><code>dispatch</code></a> only accepts a plain object, so we have to perform AJAX calls inside our components:</p> <h4 id=\"-actioncreators-js\"><code>actionCreators.js</code></h4> <pre data-language=\"js\">export function loadPostsSuccess(userId, response) {\n  return {\n    type: 'LOAD_POSTS_SUCCESS',\n    userId,\n    response\n  }\n}\n\nexport function loadPostsFailure(userId, error) {\n  return {\n    type: 'LOAD_POSTS_FAILURE',\n    userId,\n    error\n  }\n}\n\nexport function loadPostsRequest(userId) {\n  return {\n    type: 'LOAD_POSTS_REQUEST',\n    userId\n  }\n}\n</pre> <h4 id=\"-userinfo-js\"><code>UserInfo.js</code></h4> <pre data-language=\"js\">import { Component } from 'react'\nimport { connect } from 'react-redux'\nimport { loadPostsRequest, loadPostsSuccess, loadPostsFailure } from './actionCreators'\n\nclass Posts extends Component {\n  loadData(userId) {\n    // Injected into props by React Redux `connect()` call:\n    let { dispatch, posts } = this.props\n\n    if (posts[userId]) {\n      // There is cached data! Don't do anything.\n      return\n    }\n\n    // Reducer can react to this action by setting\n    // `isFetching` and thus letting us show a spinner.\n    dispatch(loadPostsRequest(userId))\n\n    // Reducer can react to these actions by filling the `users`.\n    fetch(`http://myapi.com/users/${userId}/posts`).then(\n      response =&gt; dispatch(loadPostsSuccess(userId, response)),\n      error =&gt; dispatch(loadPostsFailure(userId, error))\n    )\n  }\n\n  componentDidMount() {\n    this.loadData(this.props.userId)\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.userId !== this.props.userId) {\n      this.loadData(nextProps.userId)\n    }\n  }\n\n  render() {\n    if (this.props.isFetching) {\n      return &lt;p&gt;Loading...&lt;/p&gt;\n    }\n\n    let posts = this.props.posts.map(post =&gt;\n      &lt;Post post={post} key={post.id} /&gt;\n    )\n\n    return &lt;div&gt;{posts}&lt;/div&gt;\n  }\n}\n\nexport default connect(state =&gt; ({\n  posts: state.posts\n}))(Posts)\n</pre> <p>However, this quickly gets repetitive because different components request data from the same API endpoints. Moreover, we want to reuse some of this logic (e.g., early exit when there is cached data available) from many components.</p> <p><strong>Middleware lets us write more expressive, potentially async action creators.</strong> It lets us dispatch something other than plain objects, and interprets the values. For example, middleware can “catch” dispatched Promises and turn them into a pair of request and success/failure actions.</p> <p>The simplest example of middleware is <a href=\"https://github.com/gaearon/redux-thunk\" target=\"_blank\">redux-thunk</a>. <strong>“Thunk” middleware lets you write action creators as “thunks”, that is, functions returning functions.</strong> This inverts the control: you will get <code>dispatch</code> as an argument, so you can write an action creator that dispatches many times.</p> <blockquote> <h5 id=\"note\">Note</h5> <p>Thunk middleware is just one example of middleware. Middleware is not about “letting you dispatch functions”. It’s about letting you dispatch anything that the particular middleware you use knows how to handle. Thunk middleware adds a specific behavior when you dispatch functions, but it really depends on the middleware you use.</p> </blockquote> <p>Consider the code above rewritten with <a href=\"https://github.com/gaearon/redux-thunk\" target=\"_blank\">redux-thunk</a>:</p> <h4 id=\"-actioncreators-js\"><code>actionCreators.js</code></h4> <pre data-language=\"js\">export function loadPosts(userId) {\n  // Interpreted by the thunk middleware:\n  return function (dispatch, getState) {\n    let { posts } = getState()\n    if (posts[userId]) {\n      // There is cached data! Don't do anything.\n      return\n    }\n\n    dispatch({\n      type: 'LOAD_POSTS_REQUEST',\n      userId\n    })\n\n    // Dispatch vanilla actions asynchronously\n    fetch(`http://myapi.com/users/${userId}/posts`).then(\n      response =&gt; dispatch({\n        type: 'LOAD_POSTS_SUCCESS',\n        userId,\n        response\n      }),\n      error =&gt; dispatch({\n        type: 'LOAD_POSTS_FAILURE',\n        userId,\n        error\n      })\n    )\n  }\n}\n</pre> <h4 id=\"-userinfo-js\"><code>UserInfo.js</code></h4> <pre data-language=\"js\">import { Component } from 'react'\nimport { connect } from 'react-redux'\nimport { loadPosts } from './actionCreators'\n\nclass Posts extends Component {\n  componentDidMount() {\n    this.props.dispatch(loadPosts(this.props.userId))\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.userId !== this.props.userId) {\n      this.props.dispatch(loadPosts(nextProps.userId))\n    }\n  }\n\n  render() {\n    if (this.props.isFetching) {\n      return &lt;p&gt;Loading...&lt;/p&gt;\n    }\n\n    let posts = this.props.posts.map(post =&gt;\n      &lt;Post post={post} key={post.id} /&gt;\n    )\n\n    return &lt;div&gt;{posts}&lt;/div&gt;\n  }\n}\n\nexport default connect(state =&gt; ({\n  posts: state.posts\n}))(Posts)\n</pre> <p>This is much less typing! If you’d like, you can still have “vanilla” action creators like <code>loadPostsSuccess</code> which you’d use from a container <code>loadPosts</code> action creator.</p> <p><strong>Finally, you can write your own middleware.</strong> Let’s say you want to generalize the pattern above and describe your async action creators like this instead:</p> <pre data-language=\"js\">export function loadPosts(userId) {\n  return {\n    // Types of actions to emit before and after\n    types: ['LOAD_POSTS_REQUEST', 'LOAD_POSTS_SUCCESS', 'LOAD_POSTS_FAILURE'],\n    // Check the cache (optional):\n    shouldCallAPI: (state) =&gt; !state.posts[userId],\n    // Perform the fetching:\n    callAPI: () =&gt; fetch(`http://myapi.com/users/${userId}/posts`),\n    // Arguments to inject in begin/end actions\n    payload: { userId }\n  }\n}\n</pre> <p>The middleware that interprets such actions could look like this:</p> <pre data-language=\"js\">function callAPIMiddleware({ dispatch, getState }) {\n  return next =&gt; action =&gt; {\n    const {\n      types,\n      callAPI,\n      shouldCallAPI = () =&gt; true,\n      payload = {}\n    } = action\n\n    if (!types) {\n      // Normal action: pass it on\n      return next(action)\n    }\n\n    if (\n      !Array.isArray(types) ||\n      types.length !== 3 ||\n      !types.every(type =&gt; typeof type === 'string')\n    ) {\n      throw new Error('Expected an array of three string types.')\n    }\n\n    if (typeof callAPI !== 'function') {\n      throw new Error('Expected fetch to be a function.')\n    }\n\n    if (!shouldCallAPI(getState())) {\n      return\n    }\n\n    const [ requestType, successType, failureType ] = types\n\n    dispatch(Object.assign({}, payload, {\n      type: requestType\n    }))\n\n    return callAPI().then(\n      response =&gt; dispatch(Object.assign({}, payload, {\n        response,\n        type: successType\n      })),\n      error =&gt; dispatch(Object.assign({}, payload, {\n        error,\n        type: failureType\n      }))\n    )\n  }\n}\n</pre> <p>After passing it once to <a href=\"../api/applymiddleware\"><code>applyMiddleware(...middlewares)</code></a>, you can write all your API-calling action creators the same way:</p> <pre data-language=\"js\">export function loadPosts(userId) {\n  return {\n    types: ['LOAD_POSTS_REQUEST', 'LOAD_POSTS_SUCCESS', 'LOAD_POSTS_FAILURE'],\n    shouldCallAPI: (state) =&gt; !state.posts[userId],\n    callAPI: () =&gt; fetch(`http://myapi.com/users/${userId}/posts`),\n    payload: { userId }\n  }\n}\n\nexport function loadComments(postId) {\n  return {\n    types: ['LOAD_COMMENTS_REQUEST', 'LOAD_COMMENTS_SUCCESS', 'LOAD_COMMENTS_FAILURE'],\n    shouldCallAPI: (state) =&gt; !state.comments[postId],\n    callAPI: () =&gt; fetch(`http://myapi.com/posts/${postId}/comments`),\n    payload: { postId }\n  }\n}\n\nexport function addComment(postId, message) {\n  return {\n    types: ['ADD_COMMENT_REQUEST', 'ADD_COMMENT_SUCCESS', 'ADD_COMMENT_FAILURE'],\n    callAPI: () =&gt; fetch(`http://myapi.com/posts/${postId}/comments`, {\n      method: 'post',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ message })\n    }),\n    payload: { postId, message }\n  }\n}\n</pre> <h2 id=\"reducers\">Reducers</h2> <p>Redux reduces the boilerplate of Flux stores considerably by describing the update logic as a function. A function is simpler than an object, and much simpler than a class.</p> <p>Consider this Flux store:</p> <pre data-language=\"js\">let _todos = []\n\nconst TodoStore = Object.assign({}, EventEmitter.prototype, {\n  getAll() {\n    return _todos\n  }\n})\n\nAppDispatcher.register(function (action) {\n  switch (action.type) {\n    case ActionTypes.ADD_TODO:\n      let text = action.text.trim()\n      _todos.push(text)\n      TodoStore.emitChange()\n  }\n})\n\nexport default TodoStore\n</pre> <p>With Redux, the same update logic can be described as a reducing function:</p> <pre data-language=\"js\">export function todos(state = [], action) {\n  switch (action.type) {\n  case ActionTypes.ADD_TODO:\n    let text = action.text.trim()\n    return [ ...state, text ]\n  default:\n    return state\n  }\n}\n</pre> <p>The <code>switch</code> statement is <em>not</em> the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app).</p> <p>It’s unfortunate that many still choose Flux framework based on whether it uses <code>switch</code> statements in the documentation. If you don’t like <code>switch</code>, you can solve this with a single function, as we show below.</p> <h3 id=\"generating-reducers\">Generating Reducers</h3> <p>Let’s write a function that lets us express reducers as an object mapping from action types to handlers. For example, if we want our <code>todos</code> reducers to be defined like this:</p> <pre data-language=\"js\">export const todos = createReducer([], {\n  [ActionTypes.ADD_TODO](state, action) {\n    let text = action.text.trim()\n    return [ ...state, text ]\n  }\n})\n</pre> <p>We can write the following helper to accomplish this:</p> <pre data-language=\"js\">function createReducer(initialState, handlers) {\n  return function reducer(state = initialState, action) {\n    if (handlers.hasOwnProperty(action.type)) {\n      return handlers[action.type](state, action)\n    } else {\n      return state\n    }\n  }\n}\n</pre> <p>This wasn’t difficult, was it? Redux doesn’t provide such a helper function by default because there are many ways to write it. Maybe you want it to automatically convert plain JS objects to Immutable objects to hydrate the server state. Maybe you want to merge the returned state with the current state. There may be different approaches to a “catch all” handler. All of this depends on the conventions you choose for your team on a specific project.</p> <p>The Redux reducer API is <code>(state, action) =&gt; state</code>, but how you create those reducers is up to you.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/recipes/ReducingBoilerplate.html\" class=\"_attribution-link\">http://redux.js.org/docs/recipes/ReducingBoilerplate.html</a>\n  </p>\n</div>\n","recipes/writingtests":"<h1 id=\"writing-tests\">Writing Tests</h1> <p>Because most of the Redux code you write are functions, and many of them are pure, they are easy to test without mocking.</p> <h3 id=\"setting-up\">Setting Up</h3> <p>We recommend <a href=\"http://mochajs.org/\" target=\"_blank\">Mocha</a> as the testing engine. Note that it runs in a Node environment, so you won’t have access to the DOM.</p> <pre>npm install --save-dev mocha\n</pre>\n<p>To use it together with <a href=\"http://babeljs.io\" target=\"_blank\">Babel</a>, you will need to install <code>babel-register</code>:</p> <pre data-language=\"js\">npm install --save-dev babel-register\n</pre> <p>and configure it to use ES2015 features in <code>.babelrc</code>:</p> <pre data-language=\"js\">{\n  \"presets\": [\"es2015\"]\n}\n</pre> <p>Then, add this to <code>scripts</code> in your <code>package.json</code>:</p> <pre data-language=\"js\">{\n  ...\n  \"scripts\": {\n    ...\n    \"test\": \"mocha --compilers js:babel-register --recursive\",\n    \"test:watch\": \"npm test -- --watch\",\n  },\n  ...\n}\n</pre> <p>and run <code>npm test</code> to run it once, or <code>npm run test:watch</code> to test on every file change.</p> <h3 id=\"action-creators\">Action Creators</h3> <p>In Redux, action creators are functions which return plain objects. When testing action creators we want to test whether the correct action creator was called and also whether the right action was returned.</p> <h4 id=\"example\">Example</h4> <pre data-language=\"js\">export function addTodo(text) {\n  return {\n    type: 'ADD_TODO',\n    text\n  }\n}\n</pre> <p>can be tested like:</p> <pre data-language=\"js\">import expect from 'expect'\nimport * as actions from '../../actions/TodoActions'\nimport * as types from '../../constants/ActionTypes'\n\ndescribe('actions', () =&gt; {\n  it('should create an action to add a todo', () =&gt; {\n    const text = 'Finish docs'\n    const expectedAction = {\n      type: types.ADD_TODO,\n      text\n    }\n    expect(actions.addTodo(text)).toEqual(expectedAction)\n  })\n})\n</pre> <h3 id=\"async-action-creators\">Async Action Creators</h3> <p>For async action creators using <a href=\"https://github.com/gaearon/redux-thunk\" target=\"_blank\">Redux Thunk</a> or other middleware, it’s best to completely mock the Redux store for tests. You can apply the middleware to a mock store using <a href=\"https://github.com/arnaudbenard/redux-mock-store\" target=\"_blank\">redux-mock-store</a>. You can also use <a href=\"https://github.com/pgte/nock\" target=\"_blank\">nock</a> to mock the HTTP requests.</p> <h4 id=\"example\">Example</h4> <pre data-language=\"js\">function fetchTodosRequest() {\n  return {\n    type: FETCH_TODOS_REQUEST\n  }\n}\n\nfunction fetchTodosSuccess(body) {\n  return {\n    type: FETCH_TODOS_SUCCESS,\n    body\n  }\n}\n\nfunction fetchTodosFailure(ex) {\n  return {\n    type: FETCH_TODOS_FAILURE,\n    ex\n  }\n}\n\nexport function fetchTodos() {\n  return dispatch =&gt; {\n    dispatch(fetchTodosRequest())\n    return fetch('http://example.com/todos')\n      .then(res =&gt; res.json())\n      .then(json =&gt; dispatch(fetchTodosSuccess(json.body)))\n      .catch(ex =&gt; dispatch(fetchTodosFailure(ex)))\n  }\n}\n</pre> <p>can be tested like:</p> <pre data-language=\"js\">import configureMockStore from 'redux-mock-store'\nimport thunk from 'redux-thunk'\nimport * as actions from '../../actions/counter'\nimport * as types from '../../constants/ActionTypes'\nimport nock from 'nock'\nimport expect from 'expect' // You can use any testing library\n\nconst middlewares = [ thunk ]\nconst mockStore = configureMockStore(middlewares)\n\ndescribe('async actions', () =&gt; {\n  afterEach(() =&gt; {\n    nock.cleanAll()\n  })\n\n  it('creates FETCH_TODOS_SUCCESS when fetching todos has been done', () =&gt; {\n    nock('http://example.com/')\n      .get('/todos')\n      .reply(200, { body: { todos: ['do something'] }})\n\n    const expectedActions = [\n      { type: types.FETCH_TODOS_REQUEST },\n      { type: types.FETCH_TODOS_SUCCESS, body: { todos: ['do something']  } }\n    ]\n    const store = mockStore({ todos: [] })\n\n    return store.dispatch(actions.fetchTodos())\n      .then(() =&gt; { // return of async actions\n        expect(store.getActions()).toEqual(expectedActions)\n      })\n  })\n})\n</pre> <h3 id=\"reducers\">Reducers</h3> <p>A reducer should return the new state after applying the action to the previous state, and that’s the behavior tested below.</p> <h4 id=\"example\">Example</h4> <pre data-language=\"js\">import { ADD_TODO } from '../constants/ActionTypes'\n\nconst initialState = [\n  {\n    text: 'Use Redux',\n    completed: false,\n    id: 0\n  }\n]\n\nexport default function todos(state = initialState, action) {\n  switch (action.type) {\n    case ADD_TODO:\n      return [\n        {\n          id: state.reduce((maxId, todo) =&gt; Math.max(todo.id, maxId), -1) + 1,\n          completed: false,\n          text: action.text\n        },\n        ...state\n      ]\n\n    default:\n      return state\n  }\n}\n</pre> <p>can be tested like:</p> <pre data-language=\"js\">import expect from 'expect'\nimport reducer from '../../reducers/todos'\nimport * as types from '../../constants/ActionTypes'\n\ndescribe('todos reducer', () =&gt; {\n  it('should return the initial state', () =&gt; {\n    expect(\n      reducer(undefined, {})\n    ).toEqual([\n      {\n        text: 'Use Redux',\n        completed: false,\n        id: 0\n      }\n    ])\n  })\n\n  it('should handle ADD_TODO', () =&gt; {\n    expect(\n      reducer([], {\n        type: types.ADD_TODO,\n        text: 'Run the tests'\n      })\n    ).toEqual(\n      [\n        {\n          text: 'Run the tests',\n          completed: false,\n          id: 0\n        }\n      ]\n    )\n\n    expect(\n      reducer(\n        [\n          {\n            text: 'Use Redux',\n            completed: false,\n            id: 0\n          }\n        ],\n        {\n          type: types.ADD_TODO,\n          text: 'Run the tests'\n        }\n      )\n    ).toEqual(\n      [\n        {\n          text: 'Run the tests',\n          completed: false,\n          id: 1\n        },\n        {\n          text: 'Use Redux',\n          completed: false,\n          id: 0\n        }\n      ]\n    )\n  })\n})\n</pre> <h3 id=\"components\">Components</h3> <p>A nice thing about React components is that they are usually small and only rely on their props. That makes them easy to test.</p> <p>First, we will install <a href=\"https://facebook.github.io/react/docs/test-utils.html\" target=\"_blank\">React Test Utilities</a>:</p> <pre>npm install --save-dev react-addons-test-utils\n</pre>\n<p>To test the components we make a <code>setup()</code> helper that passes the stubbed callbacks as props and renders the component with <a href=\"https://facebook.github.io/react/docs/test-utils.html#shallow-rendering\" target=\"_blank\">React shallow renderer</a>. This lets individual tests assert on whether the callbacks were called when expected.</p> <h4 id=\"example\">Example</h4> <pre data-language=\"js\">import React, { PropTypes, Component } from 'react'\nimport TodoTextInput from './TodoTextInput'\n\nclass Header extends Component {\n  handleSave(text) {\n    if (text.length !== 0) {\n      this.props.addTodo(text)\n    }\n  }\n\n  render() {\n    return (\n      &lt;header className='header'&gt;\n          &lt;h1&gt;todos&lt;/h1&gt;\n          &lt;TodoTextInput newTodo={true}\n                         onSave={this.handleSave.bind(this)}\n                         placeholder='What needs to be done?' /&gt;\n      &lt;/header&gt;\n    )\n  }\n}\n\nHeader.propTypes = {\n  addTodo: PropTypes.func.isRequired\n}\n\nexport default Header\n</pre> <p>can be tested like:</p> <pre data-language=\"js\">import expect from 'expect'\nimport React from 'react'\nimport TestUtils from 'react-addons-test-utils'\nimport Header from '../../components/Header'\nimport TodoTextInput from '../../components/TodoTextInput'\n\nfunction setup() {\n  let props = {\n    addTodo: expect.createSpy()\n  }\n\n  let renderer = TestUtils.createRenderer()\n  renderer.render(&lt;Header {...props} /&gt;)\n  let output = renderer.getRenderOutput()\n\n  return {\n    props,\n    output,\n    renderer\n  }\n}\n\ndescribe('components', () =&gt; {\n  describe('Header', () =&gt; {\n    it('should render correctly', () =&gt; {\n      const { output } = setup()\n\n      expect(output.type).toBe('header')\n      expect(output.props.className).toBe('header')\n\n      let [ h1, input ] = output.props.children\n\n      expect(h1.type).toBe('h1')\n      expect(h1.props.children).toBe('todos')\n\n      expect(input.type).toBe(TodoTextInput)\n      expect(input.props.newTodo).toBe(true)\n      expect(input.props.placeholder).toBe('What needs to be done?')\n    })\n\n    it('should call addTodo if length of text is greater than 0', () =&gt; {\n      const { output, props } = setup()\n      let input = output.props.children[1]\n      input.props.onSave('')\n      expect(props.addTodo.calls.length).toBe(0)\n      input.props.onSave('Use Redux')\n      expect(props.addTodo.calls.length).toBe(1)\n    })\n  })\n})\n</pre> <h4 id=\"fixing-broken-setstate-in-older-react-versions\">Fixing Broken <code>setState()</code> in older React versions</h4> <p>In React &lt;= 0.13, 0.14.4 and 0.14.5, Shallow rendering <a href=\"https://github.com/facebook/react/issues/4019\" target=\"_blank\">used to throw an error if <code>setState</code> is called</a>. React seems to expect that, if you use <code>setState</code>, the DOM is available. To work around the issue, we use jsdom so React doesn’t throw the exception when the DOM isn’t available. Here’s how to <a href=\"https://github.com/facebook/react/issues/5046#issuecomment-146222515\" target=\"_blank\">set it up</a>:</p> <pre>npm install --save-dev jsdom\n</pre>\n<p>Then create a <code>setup.js</code> file in your test directory:</p> <pre data-language=\"js\">import { jsdom } from 'jsdom'\n\nglobal.document = jsdom('&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;')\nglobal.window = document.defaultView\nglobal.navigator = global.window.navigator\n</pre> <p>It’s important that this code is evaluated <em>before</em> React is imported. To ensure this, modify your <code>mocha</code> command to include <code>--require ./test/setup.js</code> in the options in your <code>package.json</code>:</p> <pre data-language=\"js\">{\n  ...\n  \"scripts\": {\n    ...\n    \"test\": \"mocha --compilers js:babel-register --recursive --require ./test/setup.js\",\n  },\n  ...\n}\n</pre> <h3 id=\"connected-components\">Connected Components</h3> <p>If you use a library like <a href=\"https://github.com/reactjs/react-redux\" target=\"_blank\">React Redux</a>, you might be using <a href=\"https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750\" target=\"_blank\">higher-order components</a> like <a href=\"https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options\" target=\"_blank\"><code>connect()</code></a>. This lets you inject Redux state into a regular React component.</p> <p>Consider the following <code>App</code> component:</p> <pre data-language=\"js\">import { connect } from 'react-redux'\n\nclass App extends Component { /* ... */ }\n\nexport default connect(mapStateToProps)(App)\n</pre> <p>In a unit test, you would normally import the <code>App</code> component like this:</p> <pre data-language=\"js\">import App from './App'\n</pre> <p>However, when you import it, you’re actually holding the wrapper component returned by <code>connect()</code>, and not the <code>App</code> component itself. If you want to test its interaction with Redux, this is good news: you can wrap it in a <a href=\"https://github.com/reactjs/react-redux#provider-store\" target=\"_blank\"><code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Provider</span><span class=\"token punctuation\">&gt;</span></span></code></a> with a store created specifically for this unit test. But sometimes you want to test just the rendering of the component, without a Redux store.</p> <p>In order to be able to test the App component itself without having to deal with the decorator, we recommend you to also export the undecorated component:</p> <pre data-language=\"js\">import { connect } from 'react-redux'\n\n// Use named export for unconnected component (for tests)\nexport class App extends Component { /* ... */ }\n\n// Use default export for the connected component (for app)\nexport default connect(mapDispatchToProps)(App)\n</pre> <p>Since the default export is still the decorated component, the import statement pictured above will work as before so you won’t have to change your application code. However, you can now import the undecorated <code>App</code> components in your test file like this:</p> <pre data-language=\"js\">// Note the curly braces: grab the named export instead of default export\nimport { App } from './App'\n</pre> <p>And if you need both:</p> <pre data-language=\"js\">import ConnectedApp, { App } from './App'\n</pre> <p>In the app itself, you would still import it normally:</p> <pre data-language=\"js\">import App from './App'\n</pre> <p>You would only use the named export for tests.</p> <blockquote> <h5 id=\"a-note-on-mixing-es6-modules-and-commonjs\">A Note on Mixing ES6 Modules and CommonJS</h5> <p>If you are using ES6 in your application source, but write your tests in ES5, you should know that Babel handles the interchangeable use of ES6 <code>import</code> and CommonJS <code>require</code> through its <a href=\"http://babeljs.io/docs/usage/modules/#interop\" target=\"_blank\">interop</a> capability to run two module formats side-by-side, but the behavior is <a href=\"https://github.com/babel/babel/issues/2047\" target=\"_blank\">slightly different</a>. If you add a second export beside your default export, you can no longer import the default using <code>require('./App')</code>. Instead you have to use <code>require('./App').default</code>.</p> </blockquote> <h3 id=\"middleware\">Middleware</h3> <p>Middleware functions wrap behavior of <code>dispatch</code> calls in Redux, so to test this modified behavior we need to mock the behavior of the <code>dispatch</code> call.</p> <h4 id=\"example\">Example</h4> <pre data-language=\"js\">import expect from 'expect'\nimport * as types from '../../constants/ActionTypes'\nimport singleDispatch from '../../middleware/singleDispatch'\n\nconst createFakeStore = fakeData =&gt; ({\n  getState() {\n    return fakeData\n  }\n})\n\nconst dispatchWithStoreOf = (storeData, action) =&gt; {\n  let dispatched = null\n  const dispatch = singleDispatch(createFakeStore(storeData))(actionAttempt =&gt; dispatched = actionAttempt)\n  dispatch(action)\n  return dispatched\n}\n\ndescribe('middleware', () =&gt; {\n  it('should dispatch if store is empty', () =&gt; {\n    const action = {\n      type: types.ADD_TODO\n    }\n\n    expect(\n      dispatchWithStoreOf({}, action)\n    ).toEqual(action)\n  })\n\n  it('should not dispatch if store already has type', () =&gt; {\n    const action = {\n      type: types.ADD_TODO\n    }\n\n    expect(\n      dispatchWithStoreOf({\n        [types.ADD_TODO]: 'dispatched'\n      }, action)\n    ).toNotExist()\n  })\n})\n</pre> <h3 id=\"glossary\">Glossary</h3> <ul> <li>\n<p><a href=\"http://facebook.github.io/react/docs/test-utils.html\" target=\"_blank\">React Test Utils</a>: Test Utilities for React.</p> </li> <li>\n<p><a href=\"https://github.com/tmpvar/jsdom\" target=\"_blank\">jsdom</a>: A plain JavaScript implementation of the DOM API. jsdom allows us to run the tests without browser.</p> </li> <li>\n<p><a href=\"http://facebook.github.io/react/docs/test-utils.html#shallow-rendering\" target=\"_blank\">Shallow rendering</a>: Shallow rendering lets you instantiate a component and get the result of its <code>render</code> method just a single level deep instead of rendering components recursively to a DOM. The result of shallow rendering is a <a href=\"https://facebook.github.io/react/docs/glossary.html#react-elements\" target=\"_blank\">ReactElement</a>. That means it is possible to access its children, props and test if it works as expected. This also means that changing a child component won’t affect the tests for parent component.</p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/recipes/WritingTests.html\" class=\"_attribution-link\">http://redux.js.org/docs/recipes/WritingTests.html</a>\n  </p>\n</div>\n","recipes/computingderiveddata":"<h1 id=\"computing-derived-data\">Computing Derived Data</h1> <p><a href=\"https://github.com/reactjs/reselect\" target=\"_blank\">Reselect</a> is a simple library for creating memoized, composable <strong>selector</strong> functions. Reselect selectors can be used to efficiently compute derived data from the Redux store.</p> <h3 id=\"motivation-for-memoized-selectors\">Motivation for Memoized Selectors</h3> <p>Let's revisit the <a href=\"../basics/usagewithreact\">Todos List example</a>:</p> <h4 id=\"-containers-visibletodolist-js\"><code>containers/VisibleTodoList.js</code></h4> <pre data-language=\"js\">import { connect } from 'react-redux'\nimport { toggleTodo } from '../actions'\nimport TodoList from '../components/TodoList'\n\nconst getVisibleTodos = (todos, filter) =&gt; {\n  switch (filter) {\n    case 'SHOW_ALL':\n      return todos\n    case 'SHOW_COMPLETED':\n      return todos.filter(t =&gt; t.completed)\n    case 'SHOW_ACTIVE':\n      return todos.filter(t =&gt; !t.completed)\n  }\n}\n\nconst mapStateToProps = (state) =&gt; {\n  return {\n    todos: getVisibleTodos(state.todos, state.visibilityFilter)\n  }\n}\n\nconst mapDispatchToProps = (dispatch) =&gt; {\n  return {\n    onTodoClick: (id) =&gt; {\n      dispatch(toggleTodo(id))\n    }\n  }\n}\n\nconst VisibleTodoList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(TodoList)\n\nexport default VisibleTodoList\n</pre> <p>In the above example, <code>mapStateToProps</code> calls <code>getVisibleTodos</code> to calculate <code>todos</code>. This works great, but there is a drawback: <code>todos</code> is calculated every time the component is updated. If the state tree is large, or the calculation expensive, repeating the calculation on every update may cause performance problems. Reselect can help to avoid these unnecessary recalculations.</p> <h3 id=\"creating-a-memoized-selector\">Creating a Memoized Selector</h3> <p>We would like to replace <code>getVisibleTodos</code> with a memoized selector that recalculates <code>todos</code> when the value of <code>state.todos</code> or <code>state.visibilityFilter</code> changes, but not when changes occur in other (unrelated) parts of the state tree.</p> <p>Reselect provides a function <code>createSelector</code> for creating memoized selectors. <code>createSelector</code> takes an array of input-selectors and a transform function as its arguments. If the Redux state tree is mutated in a way that causes the value of an input-selector to change, the selector will call its transform function with the values of the input-selectors as arguments and return the result. If the values of the input-selectors are the same as the previous call to the selector, it will return the previously computed value instead of calling the transform function.</p> <p>Let’s define a memoized selector named <code>getVisibleTodos</code> to replace the non-memoized version above:</p> <h4 id=\"-selectors-index-js\"><code>selectors/index.js</code></h4> <pre data-language=\"js\">import { createSelector } from 'reselect'\n\nconst getVisibilityFilter = (state) =&gt; state.visibilityFilter\nconst getTodos = (state) =&gt; state.todos\n\nexport const getVisibleTodos = createSelector(\n  [ getVisibilityFilter, getTodos ],\n  (visibilityFilter, todos) =&gt; {\n    switch (visibilityFilter) {\n      case 'SHOW_ALL':\n        return todos\n      case 'SHOW_COMPLETED':\n        return todos.filter(t =&gt; t.completed)\n      case 'SHOW_ACTIVE':\n        return todos.filter(t =&gt; !t.completed)\n    }\n  }\n)\n</pre> <p>In the example above, <code>getVisibilityFilter</code> and <code>getTodos</code> are input-selectors. They are created as ordinary non-memoized selector functions because they do not transform the data they select. <code>getVisibleTodos</code> on the other hand is a memoized selector. It takes <code>getVisibilityFilter</code> and <code>getTodos</code> as input-selectors, and a transform function that calculates the filtered todos list.</p> <h3 id=\"composing-selectors\">Composing Selectors</h3> <p>A memoized selector can itself be an input-selector to another memoized selector. Here is <code>getVisibleTodos</code> being used as an input-selector to a selector that further filters the todos by keyword:</p> <pre data-language=\"js\">const getKeyword = (state) =&gt; state.keyword\n\nconst getVisibleTodosFilteredByKeyword = createSelector(\n  [ getVisibleTodos, getKeyword ],\n  (visibleTodos, keyword) =&gt; visibleTodos.filter(\n    todo =&gt; todo.text.indexOf(keyword) &gt; -1\n  )\n)\n</pre> <h3 id=\"connecting-a-selector-to-the-redux-store\">Connecting a Selector to the Redux Store</h3> <p>If you are using <a href=\"https://github.com/reactjs/react-redux\" target=\"_blank\">React Redux</a>, you can call selectors as regular functions inside <code>mapStateToProps()</code>:</p> <h4 id=\"-containers-visibletodolist-js\"><code>containers/VisibleTodoList.js</code></h4> <pre data-language=\"js\">import { connect } from 'react-redux'\nimport { toggleTodo } from '../actions'\nimport TodoList from '../components/TodoList'\nimport { getVisibleTodos } from '../selectors'\n\nconst mapStateToProps = (state) =&gt; {\n  return {\n    todos: getVisibleTodos(state)\n  }\n}\n\nconst mapDispatchToProps = (dispatch) =&gt; {\n  return {\n    onTodoClick: (id) =&gt; {\n      dispatch(toggleTodo(id))\n    }\n  }\n}\n\nconst VisibleTodoList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(TodoList)\n\nexport default VisibleTodoList\n</pre> <h3 id=\"accessing-react-props-in-selectors\">Accessing React Props in Selectors</h3> <blockquote> <p>This section introduces an hypothetical extension to our app that allows it to support multiple Todo Lists. Please note that a full implementation of this extension requires changes to the reducers, components, actions etc. that aren’t directly relevant to the topics discussed and have been omitted for brevity.</p> </blockquote> <p>So far we have only seen selectors receive the Redux store state as an argument, but a selector can receive props too.</p> <p>Here is an <code>App</code> component that renders three <code>VisibleTodoList</code> components, each of which has a <code>listId</code> prop:</p> <h4 id=\"-components-app-js\"><code>components/App.js</code></h4> <pre data-language=\"js\">import React from 'react'\nimport Footer from './Footer'\nimport AddTodo from '../containers/AddTodo'\nimport VisibleTodoList from '../containers/VisibleTodoList'\n\nconst App = () =&gt; (\n  &lt;div&gt;\n    &lt;VisibleTodoList listId=\"1\" /&gt;\n    &lt;VisibleTodoList listId=\"2\" /&gt;\n    &lt;VisibleTodoList listId=\"3\" /&gt;\n  &lt;/div&gt;\n)\n</pre> <p>Each <code>VisibleTodoList</code> container should select a different slice of the state depending on the value of the <code>listId</code> prop, so let’s modify <code>getVisibilityFilter</code> and <code>getTodos</code> to accept a props argument:</p> <h4 id=\"-selectors-todoselectors-js\"><code>selectors/todoSelectors.js</code></h4> <pre data-language=\"js\">import { createSelector } from 'reselect'\n\nconst getVisibilityFilter = (state, props) =&gt;\n  state.todoLists[props.listId].visibilityFilter\n\nconst getTodos = (state, props) =&gt;\n  state.todoLists[props.listId].todos\n\nconst getVisibleTodos = createSelector(\n  [ getVisibilityFilter, getTodos ],\n  (visibilityFilter, todos) =&gt; {\n    switch (visibilityFilter) {\n      case 'SHOW_COMPLETED':\n        return todos.filter(todo =&gt; todo.completed)\n      case 'SHOW_ACTIVE':\n        return todos.filter(todo =&gt; !todo.completed)\n      default:\n        return todos\n    }\n  }\n)\n\nexport default getVisibleTodos\n</pre> <p><code>props</code> can be passed to <code>getVisibleTodos</code> from <code>mapStateToProps</code>:</p> <pre data-language=\"js\">const mapStateToProps = (state, props) =&gt; {\n  return {\n    todos: getVisibleTodos(state, props)\n  }\n}\n</pre> <p>So now <code>getVisibleTodos</code> has access to <code>props</code>, and everything seems to be working fine.</p> <p><strong>But there is a problem!</strong></p> <p>Using the <code>getVisibleTodos</code> selector with multiple instances of the <code>visibleTodoList</code> container will not correctly memoize:</p> <h4 id=\"-containers-visibletodolist-js\"><code>containers/VisibleTodoList.js</code></h4> <pre data-language=\"js\">import { connect } from 'react-redux'\nimport { toggleTodo } from '../actions'\nimport TodoList from '../components/TodoList'\nimport { getVisibleTodos } from '../selectors'\n\nconst mapStateToProps = (state, props) =&gt; {\n  return {\n    // WARNING: THE FOLLOWING SELECTOR DOES NOT CORRECTLY MEMOIZE\n    todos: getVisibleTodos(state, props)\n  }\n}\n\nconst mapDispatchToProps = (dispatch) =&gt; {\n  return {\n    onTodoClick: (id) =&gt; {\n      dispatch(toggleTodo(id))\n    }\n  }\n}\n\nconst VisibleTodoList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(TodoList)\n\nexport default VisibleTodoList\n</pre> <p>A selector created with <code>createSelector</code> only returns the cached value when its set of arguments is the same as its previous set of arguments. If we alternate between rendering <code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>VisibleTodoList</span> <span class=\"token attr-name\">listId</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/&gt;</span></span></code> and <code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>VisibleTodoList</span> <span class=\"token attr-name\">listId</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>2<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/&gt;</span></span></code>, the shared selector will alternate between receiving <code>{listId: 1}</code> and <code>{listId: 2}</code> as its <code>props</code> argument. This will cause the arguments to be different on each call, so the selector will always recompute instead of returning the cached value. We’ll see how to overcome this limitation in the next section.</p> <h3 id=\"sharing-selectors-across-multiple-components\">Sharing Selectors Across Multiple Components</h3> <blockquote> <p>The examples in this section require React Redux v4.3.0 or greater</p> </blockquote> <p>In order to share a selector across multiple <code>VisibleTodoList</code> components <strong>and</strong> retain memoization, each instance of the component needs its own private copy of the selector.</p> <p>Let’s create a function named <code>makeGetVisibleTodos</code> that returns a new copy of the <code>getVisibleTodos</code> selector each time it is called:</p> <h4 id=\"-selectors-todoselectors-js\"><code>selectors/todoSelectors.js</code></h4> <pre data-language=\"js\">import { createSelector } from 'reselect'\n\nconst getVisibilityFilter = (state, props) =&gt;\n  state.todoLists[props.listId].visibilityFilter\n\nconst getTodos = (state, props) =&gt;\n  state.todoLists[props.listId].todos\n\nconst makeGetVisibleTodos = () =&gt; {\n  return createSelector(\n    [ getVisibilityFilter, getTodos ],\n    (visibilityFilter, todos) =&gt; {\n      switch (visibilityFilter) {\n        case 'SHOW_COMPLETED':\n          return todos.filter(todo =&gt; todo.completed)\n        case 'SHOW_ACTIVE':\n          return todos.filter(todo =&gt; !todo.completed)\n        default:\n          return todos\n      }\n    }\n  )\n}\n\nexport default makeGetVisibleTodos\n</pre> <p>We also need a way to give each instance of a container access to its own private selector. The <code>mapStateToProps</code> argument of <code>connect</code> can help with this.</p> <p><strong>If the <code>mapStateToProps</code> argument supplied to <code>connect</code> returns a function instead of an object, it will be used to create an individual <code>mapStateToProps</code> function for each instance of the container.</strong></p> <p>In the example below <code>makeMapStateToProps</code> creates a new <code>getVisibleTodos</code> selector, and returns a <code>mapStateToProps</code> function that has exclusive access to the new selector:</p> <pre data-language=\"js\">const makeMapStateToProps = () =&gt; {\n  const getVisibleTodos = makeGetVisibleTodos()\n  const mapStateToProps = (state, props) =&gt; {\n    return {\n      todos: getVisibleTodos(state, props)\n    }\n  }\n  return mapStateToProps\n}\n</pre> <p>If we pass <code>makeMapStateToProps</code> to <code>connect</code>, each instance of the <code>VisibleTodosList</code> container will get its own <code>mapStateToProps</code> function with a private <code>getVisibleTodos</code> selector. Memoization will now work correctly regardless of the render order of the <code>VisibleTodoList</code> containers.</p> <h4 id=\"-containers-visibletodolist-js\"><code>containers/VisibleTodoList.js</code></h4> <pre data-language=\"js\">import { connect } from 'react-redux'\nimport { toggleTodo } from '../actions'\nimport TodoList from '../components/TodoList'\nimport { makeGetVisibleTodos } from '../selectors'\n\nconst makeMapStateToProps = () =&gt; {\n  const getVisibleTodos = makeGetVisibleTodos()\n  const mapStateToProps = (state, props) =&gt; {\n    return {\n      todos: getVisibleTodos(state, props)\n    }\n  }\n  return mapStateToProps\n}\n\nconst mapDispatchToProps = (dispatch) =&gt; {\n  return {\n    onTodoClick: (id) =&gt; {\n      dispatch(toggleTodo(id))\n    }\n  }\n}\n\nconst VisibleTodoList = connect(\n  makeMapStateToProps,\n  mapDispatchToProps\n)(TodoList)\n\nexport default VisibleTodoList\n</pre> <h2 id=\"next-steps\">Next Steps</h2> <p>Check out the <a href=\"https://github.com/reactjs/reselect\" target=\"_blank\">official documentation</a> of Reselect as well as its <a href=\"https://github.com/reactjs/reselect#faq\" target=\"_blank\">FAQ</a>. Most Redux projects start using Reselect when they have performance problems because of too many derived computations and wasted re-renders, so make sure you are familiar with it before you build something big. It can also be useful to study <a href=\"https://github.com/reactjs/reselect/blob/master/src/index.js\" target=\"_blank\">its source code</a> so you don’t think it’s magic.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/recipes/ComputingDerivedData.html\" class=\"_attribution-link\">http://redux.js.org/docs/recipes/ComputingDerivedData.html</a>\n  </p>\n</div>\n","api/store":"<h1 id=\"store\">Store</h1> <p>A store holds the whole <a href=\"../glossary#state\">state tree</a> of your application.<br>The only way to change the state inside it is to dispatch an <a href=\"../glossary#action\">action</a> on it. </p> <p>A store is not a class. It’s just an object with a few methods on it.<br>To create it, pass your root <a href=\"../glossary#reducer\">reducing function</a> to <a href=\"createstore\"><code>createStore</code></a>.</p> <blockquote> <h5 id=\"a-note-for-flux-users\">A Note for Flux Users</h5> <p>If you’re coming from Flux, there is a single important difference you need to understand. Redux doesn’t have a Dispatcher or support many stores. <strong>Instead, there is just a single store with a single root <a href=\"../glossary#reducer\">reducing function</a>.</strong> As your app grows, instead of adding stores, you split the root reducer into smaller reducers independently operating on the different parts of the state tree. You can use a helper like <a href=\"combinereducers\"><code>combineReducers</code></a> to combine them. This is similar to how there is just one root component in a React app, but it is composed out of many small components.</p> </blockquote> <h3 id=\"store-methods\">Store Methods</h3> <ul> <li><a href=\"#getState\"><code>getState()</code></a></li> <li><a href=\"#dispatch\"><code>dispatch(action)</code></a></li> <li><a href=\"#subscribe\"><code>subscribe(listener)</code></a></li> <li><a href=\"#replaceReducer\"><code>replaceReducer(nextReducer)</code></a></li> </ul> <h2 id=\"store-methods\">Store Methods</h2> <h3 id=\"-a-id-getstate-a-getstate-getstate\">\n<a href=\"#getState\" id=\"getState\"><code>getState()</code></a>\n</h3> <p>Returns the current state tree of your application.<br>It is equal to the last value returned by the store’s reducer.</p> <h4 id=\"returns\">Returns</h4> <p><em>(any)</em>: The current state tree of your application.</p>  <h3 id=\"-a-id-dispatch-a-dispatch-action-dispatch\">\n<a href=\"#dispatch\" id=\"dispatch\"><code>dispatch(action)</code></a>\n</h3> <p>Dispatches an action. This is the only way to trigger a state change.</p> <p>The store’s reducing function will be called with the current <a href=\"#getState\"><code>getState()</code></a> result and the given <code>action</code> synchronously. Its return value will be considered the next state. It will be returned from <a href=\"#getState\"><code>getState()</code></a> from now on, and the change listeners will immediately be notified.</p> <blockquote> <h5 id=\"a-note-for-flux-users\">A Note for Flux Users</h5> <p>If you attempt to call <code>dispatch</code> from inside the <a href=\"../glossary#reducer\">reducer</a>, it will throw with an error saying “Reducers may not dispatch actions.” This is similar to “Cannot dispatch in a middle of dispatch” error in Flux, but doesn’t cause the problems associated with it. In Flux, a dispatch is forbidden while Stores are handling the action and emitting updates. This is unfortunate because it makes it impossible to dispatch actions from component lifecycle hooks or other benign places.</p> <p>In Redux, subscriptions are called after the root reducer has returned the new state, so you <em>may</em> dispatch in the subscription listeners. You are only disallowed to dispatch inside the reducers because they must have no side effects. If you want to cause a side effect in response to an action, the right place to do this is in the potentially async <a href=\"../glossary#action-creator\">action creator</a>.</p> </blockquote> <h4 id=\"arguments\">Arguments</h4> <ol> <li>\n<code>action</code> (<em>Object</em><sup>†</sup>): A plain object describing the change that makes sense for your application. Actions are the only way to get data into the store, so any data, whether from the UI events, network callbacks, or other sources such as WebSockets needs to eventually be dispatched as actions. Actions must have a <code>type</code> field that indicates the type of action being performed. Types can be defined as constants and imported from another module. It’s better to use strings for <code>type</code> than <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol\" target=\"_blank\">Symbols</a> because strings are serializable. Other than <code>type</code>, the structure of an action object is really up to you. If you’re interested, check out <a href=\"https://github.com/acdlite/flux-standard-action\" target=\"_blank\">Flux Standard Action</a> for recommendations on how actions could be constructed.</li> </ol> <h4 id=\"returns\">Returns</h4> <p>(Object<sup>†</sup>): The dispatched action (see notes).</p> <h4 id=\"notes\">Notes</h4> <p><sup>†</sup> The “vanilla” store implementation you get by calling <a href=\"createstore\"><code>createStore</code></a> only supports plain object actions and hands them immediately to the reducer.</p> <p>However, if you wrap <a href=\"createstore\"><code>createStore</code></a> with <a href=\"applymiddleware\"><code>applyMiddleware</code></a>, the middleware can interpret actions differently, and provide support for dispatching <a href=\"../glossary#async-action\">async actions</a>. Async actions are usually asynchronous primitives like Promises, Observables, or thunks.</p> <p>Middleware is created by the community and does not ship with Redux by default. You need to explicitly install packages like <a href=\"https://github.com/gaearon/redux-thunk\" target=\"_blank\">redux-thunk</a> or <a href=\"https://github.com/acdlite/redux-promise\" target=\"_blank\">redux-promise</a> to use it. You may also create your own middleware.</p> <p>To learn how to describe asynchronous API calls, read the current state inside action creators, perform side effects, or chain them to execute in a sequence, see the examples for <a href=\"applymiddleware\"><code>applyMiddleware</code></a>.</p> <h4 id=\"example\">Example</h4> <pre data-language=\"js\">import { createStore } from 'redux'\nlet store = createStore(todos, [ 'Use Redux' ])\n\nfunction addTodo(text) {\n  return {\n    type: 'ADD_TODO',\n    text\n  }\n}\n\nstore.dispatch(addTodo('Read the docs'))\nstore.dispatch(addTodo('Read about the middleware'))\n</pre>  <h3 id=\"-a-id-subscribe-a-subscribe-listener-subscribe\">\n<a href=\"#subscribe\" id=\"subscribe\"><code>subscribe(listener)</code></a>\n</h3> <p>Adds a change listener. It will be called any time an action is dispatched, and some part of the state tree may potentially have changed. You may then call <a href=\"#getState\"><code>getState()</code></a> to read the current state tree inside the callback.</p> <p>You may call <a href=\"#dispatch\"><code>dispatch()</code></a> from a change listener, with the following caveats:</p> <ol> <li>\n<p>The listener should only call <a href=\"#dispatch\"><code>dispatch()</code></a> either in response to user actions or under specific conditions (e. g. dispatching an action when the store has a specific field). Calling <a href=\"#dispatch\"><code>dispatch()</code></a> without any conditions is technically possible, however it leads to infinite loop as every <a href=\"#dispatch\"><code>dispatch()</code></a> call usually triggers the listener again.</p> </li> <li>\n<p>The subscriptions are snapshotted just before every <a href=\"#dispatch\"><code>dispatch()</code></a> call. If you subscribe or unsubscribe while the listeners are being invoked, this will not have any effect on the <a href=\"#dispatch\"><code>dispatch()</code></a> that is currently in progress. However, the next <a href=\"#dispatch\"><code>dispatch()</code></a> call, whether nested or not, will use a more recent snapshot of the subscription list.</p> </li> <li>\n<p>The listener should not expect to see all state changes, as the state might have been updated multiple times during a nested <a href=\"#dispatch\"><code>dispatch()</code></a> before the listener is called. It is, however, guaranteed that all subscribers registered before the <a href=\"#dispatch\"><code>dispatch()</code></a> started will be called with the latest state by the time it exits.</p> </li> </ol> <p>It is a low-level API. Most likely, instead of using it directly, you’ll use React (or other) bindings. If you feel that the callback needs to be invoked with the current state, you might want to <a href=\"https://github.com/reactjs/redux/issues/303#issuecomment-125184409\" target=\"_blank\">convert the store to an Observable or write a custom <code>observeStore</code> utility instead</a>.</p> <p>To unsubscribe the change listener, invoke the function returned by <code>subscribe</code>.</p> <h4 id=\"arguments\">Arguments</h4> <ol> <li>\n<code>listener</code> (<em>Function</em>): The callback to be invoked any time an action has been dispatched, and the state tree might have changed. You may call <a href=\"#getState\"><code>getState()</code></a> inside this callback to read the current state tree. It is reasonable to expect that the store’s reducer is a pure function, so you may compare references to some deep path in the state tree to learn whether its value has changed.</li> </ol> <h5 id=\"returns\">Returns</h5> <p>(<em>Function</em>): A function that unsubscribes the change listener.</p> <h5 id=\"example\">Example</h5> <pre data-language=\"js\">function select(state) {\n  return state.some.deep.property\n}\n\nlet currentValue\nfunction handleChange() {\n  let previousValue = currentValue\n  currentValue = select(store.getState())\n\n  if (previousValue !== currentValue) {\n    console.log('Some deep nested property changed from', previousValue, 'to', currentValue)\n  }\n}\n\nlet unsubscribe = store.subscribe(handleChange)\nhandleChange()\n</pre>  <h3 id=\"-a-id-replacereducer-a-replacereducer-nextreducer-replacereducer\">\n<a href=\"#replaceReducer\" id=\"replaceReducer\"><code>replaceReducer(nextReducer)</code></a>\n</h3> <p>Replaces the reducer currently used by the store to calculate the state.</p> <p>It is an advanced API. You might need this if your app implements code splitting, and you want to load some of the reducers dynamically. You might also need this if you implement a hot reloading mechanism for Redux.</p> <h4 id=\"arguments\">Arguments</h4> <ol> <li>\n<code>reducer</code> (<em>Function</em>) The next reducer for the store to use.</li> </ol><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/api/Store.html\" class=\"_attribution-link\">http://redux.js.org/docs/api/Store.html</a>\n  </p>\n</div>\n","api/combinereducers":"<h1 id=\"-combinereducers-reducers\">combineReducers(reducers)</h1> <p>As your app grows more complex, you’ll want to split your <a href=\"../glossary#reducer\">reducing function</a> into separate functions, each managing independent parts of the <a href=\"../glossary#state\">state</a>.</p> <p>The <code>combineReducers</code> helper function turns an object whose values are different reducing functions into a single reducing function you can pass to <a href=\"createstore\"><code>createStore</code></a>.</p> <p>The resulting reducer calls every child reducer, and gathers their results into a single state object. <strong>The shape of the state object matches the keys of the passed <code>reducers</code></strong>.</p> <p>Consequently, the state object will look like this: </p> <pre>{\n  reducer1: ...\n  reducer2: ...\n}\n</pre>\n<p>You can control state key names by using different keys for the reducers in the passed object. For example, you may call <code>combineReducers({ todos: myTodosReducer, counter: myCounterReducer })</code> for the state shape to be <code>{ todos, counter }</code>.</p> <p>A popular convention is to name reducers after the state slices they manage, so you can use ES6 property shorthand notation: <code>combineReducers({ counter, todos })</code>. This is equivalent to writing <code>combineReducers({ counter: counter, todos: todos })</code>.</p> <blockquote> <h5 id=\"a-note-for-flux-users\">A Note for Flux Users</h5> <p>This function helps you organize your reducers to manage their own slices of state, similar to how you would have different Flux Stores to manage different state. With Redux, there is just one store, but <code>combineReducers</code> helps you keep the same logical division between reducers.</p> </blockquote> <h4 id=\"arguments\">Arguments</h4> <ol> <li>\n<code>reducers</code> (<em>Object</em>): An object whose values correspond to different reducing functions that need to be combined into one. See the notes below for some rules every passed reducer must follow.</li> </ol> <blockquote> <p>Earlier documentation suggested the use of the ES6 <code>import * as reducers</code> syntax to obtain the reducers object. This was the source of a lot of confusion, which is why we now recommend exporting a single reducer obtained using <code>combineReducers()</code> from <code>reducers/index.js</code> instead. An example is included below.</p> </blockquote> <h4 id=\"returns\">Returns</h4> <p>(<em>Function</em>): A reducer that invokes every reducer inside the <code>reducers</code> object, and constructs a state object with the same shape.</p> <h4 id=\"notes\">Notes</h4> <p>This function is mildly opinionated and is skewed towards helping beginners avoid common pitfalls. This is why it attempts to enforce some rules that you don’t have to follow if you write the root reducer manually.</p> <p>Any reducer passed to <code>combineReducers</code> must satisfy these rules:</p> <ul> <li>\n<p>For any action that is not recognized, it must return the <code>state</code> given to it as the first argument.</p> </li> <li>\n<p>It must never return <code>undefined</code>. It is too easy to do this by mistake via an early <code>return</code> statement, so <code>combineReducers</code> throws if you do that instead of letting the error manifest itself somewhere else.</p> </li> <li>\n<p>If the <code>state</code> given to it is <code>undefined</code>, it must return the initial state for this specific reducer. According to the previous rule, the initial state must not be <code>undefined</code> either. It is handy to specify it with ES6 optional arguments syntax, but you can also explicitly check the first argument for being <code>undefined</code>.</p> </li> </ul> <p>While <code>combineReducers</code> attempts to check that your reducers conform to some of these rules, you should remember them, and do your best to follow them.</p> <h4 id=\"example\">Example</h4> <h4 id=\"-reducers-todos-js\"><code>reducers/todos.js</code></h4> <pre data-language=\"js\">export default function todos(state = [], action) {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return state.concat([ action.text ])\n    default:\n      return state\n  }\n}\n</pre> <h4 id=\"-reducers-counter-js\"><code>reducers/counter.js</code></h4> <pre data-language=\"js\">export default function counter(state = 0, action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + 1\n    case 'DECREMENT':\n      return state - 1\n    default:\n      return state\n  }\n}\n</pre> <h4 id=\"-reducers-index-js\"><code>reducers/index.js</code></h4> <pre data-language=\"js\">import { combineReducers } from 'redux'\nimport todos from './todos'\nimport counter from './counter'\n\nexport default combineReducers({\n  todos,\n  counter\n})\n</pre> <h4 id=\"-app-js\"><code>App.js</code></h4> <pre data-language=\"js\">import { createStore } from 'redux'\nimport reducer from './reducers/index'\n\nlet store = createStore(reducer)\nconsole.log(store.getState())\n// {\n//   counter: 0,\n//   todos: []\n// }\n\nstore.dispatch({\n  type: 'ADD_TODO',\n  text: 'Use Redux'\n})\nconsole.log(store.getState())\n// {\n//   counter: 0,\n//   todos: [ 'Use Redux' ]\n// }\n</pre> <h4 id=\"tips\">Tips</h4> <ul> <li>\n<p>This helper is just a convenience! You can write your own <code>combineReducers</code> that <a href=\"https://github.com/acdlite/reduce-reducers\" target=\"_blank\">works differently</a>, or even assemble the state object from the child reducers manually and write a root reducing function explicitly, like you would write any other function.</p> </li> <li>\n<p>You may call <code>combineReducers</code> at any level of the reducer hierarchy. It doesn’t have to happen at the top. In fact you may use it again to split the child reducers that get too complicated into independent grandchildren, and so on.</p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/api/combineReducers.html\" class=\"_attribution-link\">http://redux.js.org/docs/api/combineReducers.html</a>\n  </p>\n</div>\n","api/bindactioncreators":"<h1 id=\"-bindactioncreators-actioncreators-dispatch\">bindActionCreators(actionCreators, dispatch)</h1> <p>Turns an object whose values are <a href=\"../glossary#action-creator\">action creators</a>, into an object with the same keys, but with every action creator wrapped into a <a href=\"store#dispatch\"><code>dispatch</code></a> call so they may be invoked directly.</p> <p>Normally you should just call <a href=\"store#dispatch\"><code>dispatch</code></a> directly on your <a href=\"store\"><code>Store</code></a> instance. If you use Redux with React, <a href=\"https://github.com/gaearon/react-redux\" target=\"_blank\">react-redux</a> will provide you with the <a href=\"store#dispatch\"><code>dispatch</code></a> function so you can call it directly, too.</p> <p>The only use case for <code>bindActionCreators</code> is when you want to pass some action creators down to a component that isn’t aware of Redux, and you don’t want to pass <a href=\"store#dispatch\"><code>dispatch</code></a> or the Redux store to it.</p> <p>For convenience, you can also pass a single function as the first argument, and get a function in return.</p> <h4 id=\"parameters\">Parameters</h4> <ol> <li>\n<p><code>actionCreators</code> (<em>Function</em> or <em>Object</em>): An <a href=\"../glossary#action-creator\">action creator</a>, or an object whose values are action creators.</p> </li> <li>\n<p><code>dispatch</code> (<em>Function</em>): A <a href=\"store#dispatch\"><code>dispatch</code></a> function available on the <a href=\"store\"><code>Store</code></a> instance.</p> </li> </ol> <h4 id=\"returns\">Returns</h4> <p>(<em>Function</em> or <em>Object</em>): An object mimicking the original object, but with each function immediately dispatching the action returned by the corresponding action creator. If you passed a function as <code>actionCreators</code>, the return value will also be a single function.</p> <h4 id=\"example\">Example</h4> <h4 id=\"-todoactioncreators-js\"><code>TodoActionCreators.js</code></h4> <pre data-language=\"js\">export function addTodo(text) {\n  return {\n    type: 'ADD_TODO',\n    text\n  }\n}\n\nexport function removeTodo(id) {\n  return {\n    type: 'REMOVE_TODO',\n    id\n  }\n}\n</pre> <h4 id=\"-somecomponent-js\"><code>SomeComponent.js</code></h4> <pre data-language=\"js\">import { Component } from 'react'\nimport { bindActionCreators } from 'redux'\nimport { connect } from 'react-redux'\n\nimport * as TodoActionCreators from './TodoActionCreators'\nconsole.log(TodoActionCreators)\n// {\n//   addTodo: Function,\n//   removeTodo: Function\n// }\n\nclass TodoListContainer extends Component {\n  componentDidMount() {\n    // Injected by react-redux:\n    let { dispatch } = this.props\n\n    // Note: this won’t work:\n    // TodoActionCreators.addTodo('Use Redux')\n\n    // You’re just calling a function that creates an action.\n    // You must dispatch the action, too!\n\n    // This will work:\n    let action = TodoActionCreators.addTodo('Use Redux')\n    dispatch(action)\n  }\n\n  render() {\n    // Injected by react-redux:\n    let { todos, dispatch } = this.props\n\n    // Here’s a good use case for bindActionCreators:\n    // You want a child component to be completely unaware of Redux.\n\n    let boundActionCreators = bindActionCreators(TodoActionCreators, dispatch)\n    console.log(boundActionCreators)\n    // {\n    //   addTodo: Function,\n    //   removeTodo: Function\n    // }\n\n    return (\n      &lt;TodoList todos={todos}\n                {...boundActionCreators} /&gt;\n    )\n\n    // An alternative to bindActionCreators is to pass\n    // just the dispatch function down, but then your child component\n    // needs to import action creators and know about them.\n\n    // return &lt;TodoList todos={todos} dispatch={dispatch} /&gt;\n  }\n}\n\nexport default connect(\n  state =&gt; ({ todos: state.todos })\n)(TodoListContainer)\n</pre> <h4 id=\"tips\">Tips</h4> <ul> <li>\n<p>You might ask: why don’t we bind the action creators to the store instance right away, like in classical Flux? The problem is that this won’t work well with universal apps that need to render on the server. Most likely you want to have a separate store instance per request so you can prepare them with different data, but binding action creators during their definition means you’re stuck with a single store instance for all requests.</p> </li> <li>\n<p>If you use ES5, instead of <code>import * as</code> syntax you can just pass <code>require('./TodoActionCreators')</code> to <code>bindActionCreators</code> as the first argument. The only thing it cares about is that the values of the <code>actionCreators</code> arguments are functions. The module system doesn’t matter.</p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/api/bindActionCreators.html\" class=\"_attribution-link\">http://redux.js.org/docs/api/bindActionCreators.html</a>\n  </p>\n</div>\n","recipes/implementingundohistory":"<h1 id=\"implementing-undo-history\">Implementing Undo History</h1> <p>Building an Undo and Redo functionality into an app has traditionally required conscious effort from the developer. It is not an easy problem with classical MVC frameworks because you need to keep track of every past state by cloning all relevant models. In addition, you need to be mindful of the undo stack because the user-initiated changes should be undoable.</p> <p>This means that implementing Undo and Redo in an MVC application usually forces you to rewrite parts of your application to use a specific data mutation pattern like <a href=\"https://en.wikipedia.org/wiki/Command_pattern\" target=\"_blank\">Command</a>.</p> <p>With Redux, however, implementing undo history is a breeze. There are three reasons for this:</p> <ul> <li>There are no multiple models—just a state subtree that you want to keep track of.</li> <li>The state is already immutable, and mutations are already described as discrete actions, which is close to the undo stack mental model.</li> <li>The reducer <code>(state, action) =&gt; state</code> signature makes it natural to implement generic “reducer enhancers” or “higher order reducers”. They are functions that take your reducer and enhance it with some additional functionality while preserving its signature. Undo history is exactly such a case.</li> </ul> <p>Before proceeding, make sure you have worked through the <a href=\"../basics/index\">basics tutorial</a> and understand <a href=\"../basics/reducers\">reducer composition</a> well. This recipe will build on top of the example described in the <a href=\"../basics/index\">basics tutorial</a>.</p> <p>In the first part of this recipe, we will explain the underlying concepts that make Undo and Redo possible to implement in a generic way.</p> <p>In the second part of this recipe, we will show how to use <a href=\"https://github.com/omnidan/redux-undo\" target=\"_blank\">Redux Undo</a> package that provides this functionality out of the box.</p> <p><a href=\"https://twitter.com/dan_abramov/status/647038407286390784\" target=\"_blank\"><img src=\"http://i.imgur.com/lvDFHkH.gif\" alt=\"demo of todos-with-undo\"></a></p> <h2 id=\"understanding-undo-history\">Understanding Undo History</h2> <h3 id=\"designing-the-state-shape\">Designing the State Shape</h3> <p>Undo history is also part of your app’s state, and there is no reason why we should approach it differently. Regardless of the type of the state changing over time, when you implement Undo and Redo, you want to keep track of the <em>history</em> of this state at different points in time.</p> <p>For example, the state shape of a counter app might look like this:</p> <pre data-language=\"js\">{\n  counter: 10\n}\n</pre> <p>If we wanted to implement Undo and Redo in such an app, we’d need to store more state so we can answer the following questions:</p> <ul> <li>Is there anything left to undo or redo?</li> <li>What is the current state?</li> <li>What are the past (and future) states in the undo stack?</li> </ul> <p>It is reasonable to suggest that our state shape should change to answer these questions:</p> <pre data-language=\"js\">{\n  counter: {\n    past: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ],\n    present: 10,\n    future: []\n  }\n}\n</pre> <p>Now, if user presses “Undo”, we want it to change to move into the past:</p> <pre data-language=\"js\">{\n  counter: {\n    past: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ],\n    present: 9,\n    future: [ 10 ]\n  }\n}\n</pre> <p>And further yet:</p> <pre data-language=\"js\">{\n  counter: {\n    past: [ 0, 1, 2, 3, 4, 5, 6, 7 ],\n    present: 8,\n    future: [ 9, 10 ]\n  }\n}\n</pre> <p>When the user presses “Redo”, we want to move one step back into the future:</p> <pre data-language=\"js\">{\n  counter: {\n    past: [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ],\n    present: 9,\n    future: [ 10 ]\n  }\n}\n</pre> <p>Finally, if the user performs an action (e.g. decrement the counter) while we’re in the middle of the undo stack, we’re going to discard the existing future:</p> <pre data-language=\"js\">{\n  counter: {\n    past: [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ],\n    present: 8,\n    future: []\n  }\n}\n</pre> <p>The interesting part here is that it does not matter whether we want to keep an undo stack of numbers, strings, arrays, or objects. The structure will always be the same:</p> <pre data-language=\"js\">{\n  counter: {\n    past: [ 0, 1, 2 ],\n    present: 3,\n    future: [ 4 ]\n  }\n}\n</pre> <pre data-language=\"js\">{\n  todos: {\n    past: [\n      [],\n      [ { text: 'Use Redux' } ],\n      [ { text: 'Use Redux', complete: true } ]\n    ],\n    present: [ { text: 'Use Redux', complete: true }, { text: 'Implement Undo' } ],\n    future: [\n      [ { text: 'Use Redux', complete: true }, { text: 'Implement Undo', complete: true } ]\n    ]\n  }\n}\n</pre> <p>In general, it looks like this:</p> <pre data-language=\"js\">{\n  past: Array&lt;T&gt;,\n  present: T,\n  future: Array&lt;T&gt;\n}\n</pre> <p>It is also up to us whether to keep a single top-level history:</p> <pre data-language=\"js\">{\n  past: [\n    { counterA: 1, counterB: 1 },\n    { counterA: 1, counterB: 0 },\n    { counterA: 0, counterB: 0 }\n  ],\n  present: { counterA: 2, counterB: 1 },\n  future: []\n}\n</pre> <p>Or many granular histories so user can undo and redo actions in them independently:</p> <pre data-language=\"js\">{\n  counterA: {\n    past: [ 1, 0 ],\n    present: 2,\n    future: []\n  },\n  counterB: {\n    past: [ 0 ],\n    present: 1,\n    future: []\n  }\n}\n</pre> <p>We will see later how the approach we take lets us choose how granular Undo and Redo need to be.</p> <h3 id=\"designing-the-algorithm\">Designing the Algorithm</h3> <p>Regardless of the specific data type, the shape of the undo history state is the same:</p> <pre data-language=\"js\">{\n  past: Array&lt;T&gt;,\n  present: T,\n  future: Array&lt;T&gt;\n}\n</pre> <p>Let’s talk through the algorithm to manipulate the state shape described above. We can define two actions to operate on this state: <code>UNDO</code> and <code>REDO</code>. In our reducer, we will do the following steps to handle these actions:</p> <h4 id=\"handling-undo\">Handling Undo</h4> <ul> <li>Remove the <em>last</em> element from the <code>past</code>.</li> <li>Set the <code>present</code> to the element we removed in the previous step.</li> <li>Insert the old <code>present</code> state at the <em>beginning</em> of the <code>future</code>.</li> </ul> <h4 id=\"handling-redo\">Handling Redo</h4> <ul> <li>Remove the <em>first</em> element from the <code>future</code>.</li> <li>Set the <code>present</code> to the element we removed in the previous step.</li> <li>Insert the old <code>present</code> state at the <em>end</em> of the <code>past</code>.</li> </ul> <h4 id=\"handling-other-actions\">Handling Other Actions</h4> <ul> <li>Insert the <code>present</code> at the end of the <code>past</code>.</li> <li>Set the <code>present</code> to the new state after handling the action.</li> <li>Clear the <code>future</code>.</li> </ul> <h3 id=\"first-attempt-writing-a-reducer\">First Attempt: Writing a Reducer</h3> <pre data-language=\"js\">const initialState = {\n  past: [],\n  present: null, // (?) How do we initialize the present?\n  future: []\n}\n\nfunction undoable(state = initialState, action) {\n  const { past, present, future } = state\n\n  switch (action.type) {\n    case 'UNDO':\n      const previous = past[past.length - 1]\n      const newPast = past.slice(0, past.length - 1)\n      return {\n        past: newPast,\n        present: previous,\n        future: [ present, ...future ]\n      }\n    case 'REDO':\n      const next = future[0]\n      const newFuture = future.slice(1)\n      return {\n        past: [ ...past, present ],\n        present: next,\n        future: newFuture\n      }\n    default:\n      // (?) How do we handle other actions?\n      return state\n  }\n}\n</pre> <p>This implementation isn’t usable because it leaves out three important questions:</p> <ul> <li>Where do we get the initial <code>present</code> state from? We don’t seem to know it beforehand.</li> <li>Where do we react to the external actions to save the <code>present</code> to the <code>past</code>?</li> <li>How do we actually delegate the control over the <code>present</code> state to a custom reducer?</li> </ul> <p>It seems that reducer isn’t the right abstraction, but we’re very close.</p> <h3 id=\"meet-reducer-enhancers\">Meet Reducer Enhancers</h3> <p>You might be familiar with <a href=\"https://en.wikipedia.org/wiki/Higher-order_function\" target=\"_blank\">higher order functions</a>. If you use React, you might be familiar with <a href=\"https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750\" target=\"_blank\">higher order components</a>. Here is a variation on the same pattern, applied to reducers.</p> <p>A <em>reducer enhancer</em> (or a <em>higher order reducer</em>) is a function that takes a reducer, and returns a new reducer that is able to handle new actions, or to hold more state, delegating control to the inner reducer for the actions it doesn’t understand. This isn’t a new pattern—technically, <a href=\"../api/combinereducers\"><code>combineReducers()</code></a> is also a reducer enhancer because it takes reducers and returns a new reducer.</p> <p>A reducer enhancer that doesn’t do anything looks like this:</p> <pre data-language=\"js\">function doNothingWith(reducer) {\n  return function (state, action) {\n    // Just call the passed reducer\n    return reducer(state, action)\n  }\n}\n</pre> <p>A reducer enhancer that combines other reducers might look like this:</p> <pre data-language=\"js\">function combineReducers(reducers) {\n  return function (state = {}, action) {\n    return Object.keys(reducers).reduce((nextState, key) =&gt; {\n      // Call every reducer with the part of the state it manages\n      nextState[key] = reducers[key](state[key], action)\n      return nextState\n    }, {})\n  }\n}\n</pre> <h3 id=\"second-attempt-writing-a-reducer-enhancer\">Second Attempt: Writing a Reducer Enhancer</h3> <p>Now that we have a better understanding of reducer enhancers, we can see that this is exactly what <code>undoable</code> should have been:</p> <pre data-language=\"js\">function undoable(reducer) {\n  // Call the reducer with empty action to populate the initial state\n  const initialState = {\n    past: [],\n    present: reducer(undefined, {}),\n    future: []\n  }\n\n  // Return a reducer that handles undo and redo\n  return function (state = initialState, action) {\n    const { past, present, future } = state\n\n    switch (action.type) {\n      case 'UNDO':\n        const previous = past[past.length - 1]\n        const newPast = past.slice(0, past.length - 1)\n        return {\n          past: newPast,\n          present: previous,\n          future: [ present, ...future ]\n        }\n      case 'REDO':\n        const next = future[0]\n        const newFuture = future.slice(1)\n        return {\n          past: [ ...past, present ],\n          present: next,\n          future: newFuture\n        }\n      default:\n        // Delegate handling the action to the passed reducer\n        const newPresent = reducer(present, action)\n        if (present === newPresent) {\n          return state\n        }\n        return {\n          past: [ ...past, present ],\n          present: newPresent,\n          future: []\n        }\n    }\n  }\n}\n</pre> <p>We can now wrap any reducer into <code>undoable</code> reducer enhancer to teach it to react to <code>UNDO</code> and <code>REDO</code> actions.</p> <pre data-language=\"js\">// This is a reducer\nfunction todos(state = [], action) {\n  /* ... */\n}\n\n// This is also a reducer!\nconst undoableTodos = undoable(todos)\n\nimport { createStore } from 'redux'\nconst store = createStore(undoableTodos)\n\nstore.dispatch({\n  type: 'ADD_TODO',\n  text: 'Use Redux'\n})\n\nstore.dispatch({\n  type: 'ADD_TODO',\n  text: 'Implement Undo'\n})\n\nstore.dispatch({\n  type: 'UNDO'\n})\n</pre> <p>There is an important gotcha: you need to remember to append <code>.present</code> to the current state when you retrieve it. You may also check <code>.past.length</code> and <code>.future.length</code> to determine whether to enable or to disable the Undo and Redo buttons, respectively.</p> <p>You might have heard that Redux was influenced by <a href=\"https://github.com/evancz/elm-architecture-tutorial/\" target=\"_blank\">Elm Architecture</a>. It shouldn’t come as a surprise that this example is very similar to <a href=\"http://package.elm-lang.org/packages/TheSeamau5/elm-undo-redo/2.0.0\" target=\"_blank\">elm-undo-redo package</a>.</p> <h2 id=\"using-redux-undo\">Using Redux Undo</h2> <p>This was all very informative, but can’t we just drop a library and use it instead of implementing <code>undoable</code> ourselves? Sure, we can! Meet <a href=\"https://github.com/omnidan/redux-undo\" target=\"_blank\">Redux Undo</a>, a library that provides simple Undo and Redo functionality for any part of your Redux tree.</p> <p>In this part of the recipe, you will learn how to make the <a href=\"../basics/exampletodolist\" target=\"_blank\">Todo List example</a> undoable. You can find the full source of this recipe in the <a href=\"https://github.com/reactjs/redux/tree/master/examples/todos-with-undo\" target=\"_blank\"><code>todos-with-undo</code> example that comes with Redux</a>.</p> <h3 id=\"installation\">Installation</h3> <p>First of all, you need to run</p> <pre>npm install --save redux-undo\n</pre>\n<p>This installs the package that provides the <code>undoable</code> reducer enhancer.</p> <h3 id=\"wrapping-the-reducer\">Wrapping the Reducer</h3> <p>You will need to wrap the reducer you wish to enhance with <code>undoable</code> function. For example, if you exported a <code>todos</code> reducer from a dedicated file, you will want to change it to export the result of calling <code>undoable()</code> with the reducer you wrote:</p> <h4 id=\"-reducers-todos-js\"><code>reducers/todos.js</code></h4> <pre data-language=\"js\">import undoable, { distinctState } from 'redux-undo'\n\n/* ... */\n\nconst todos = (state = [], action) =&gt; {\n  /* ... */\n}\n\nconst undoableTodos = undoable(todos, {\n  filter: distinctState()\n})\n\nexport default undoableTodos\n</pre> <p>The <code>distinctState()</code> filter serves to ignore the actions that didn’t result in a state change. There are <a href=\"https://github.com/omnidan/redux-undo#configuration\" target=\"_blank\">many other options</a> to configure your undoable reducer, like setting the action type for Undo and Redo actions.</p> <p>Note that your <code>combineReducers()</code> call will stay exactly as it was, but the <code>todos</code> reducer will now refer to the reducer enhanced with Redux Undo:</p> <h4 id=\"-reducers-index-js\"><code>reducers/index.js</code></h4> <pre data-language=\"js\">import { combineReducers } from 'redux'\nimport todos from './todos'\nimport visibilityFilter from './visibilityFilter'\n\nconst todoApp = combineReducers({\n  todos,\n  visibilityFilter\n})\n\nexport default todoApp\n</pre> <p>You may wrap one or more reducers in <code>undoable</code> at any level of the reducer composition hierarchy. We choose to wrap <code>todos</code> instead of the top-level combined reducer so that changes to <code>visibilityFilter</code> are not reflected in the undo history.</p> <h3 id=\"updating-the-selectors\">Updating the Selectors</h3> <p>Now the <code>todos</code> part of the state looks like this:</p> <pre data-language=\"js\">{\n  visibilityFilter: 'SHOW_ALL',\n  todos: {\n    past: [\n      [],\n      [ { text: 'Use Redux' } ],\n      [ { text: 'Use Redux', complete: true } ]\n    ],\n    present: [ { text: 'Use Redux', complete: true }, { text: 'Implement Undo' } ],\n    future: [\n      [ { text: 'Use Redux', complete: true }, { text: 'Implement Undo', complete: true } ]\n    ]\n  }\n}\n</pre> <p>This means you need to access your state with <code>state.todos.present</code> instead of just <code>state.todos</code>:</p> <h4 id=\"-containers-visibletodolist-js\"><code>containers/VisibleTodoList.js</code></h4> <pre data-language=\"js\">const mapStateToProps = (state) =&gt; {\n  return {\n    todos: getVisibleTodos(state.todos.present, state.visibilityFilter)\n  }\n}\n</pre> <h3 id=\"adding-the-buttons\">Adding the Buttons</h3> <p>Now all you need to do is add the buttons for the Undo and Redo actions.</p> <p>First, create a new container component called <code>UndoRedo</code> for these buttons. We won’t bother to split the presentational part into a separate file because it is very small:</p> <h4 id=\"-containers-undoredo-js\"><code>containers/UndoRedo.js</code></h4> <pre data-language=\"js\">import React from 'react'\n\n/* ... */\n\nlet UndoRedo = ({ canUndo, canRedo, onUndo, onRedo }) =&gt; (\n  &lt;p&gt;\n    &lt;button onClick={onUndo} disabled={!canUndo}&gt;\n      Undo\n    &lt;/button&gt;\n    &lt;button onClick={onRedo} disabled={!canRedo}&gt;\n      Redo\n    &lt;/button&gt;\n  &lt;/p&gt;\n)\n</pre> <p>You will use <code>connect()</code> from <a href=\"https://github.com/reactjs/react-redux\" target=\"_blank\">React Redux</a> to generate a container component. To determine whether to enable Undo and Redo buttons, you can check <code>state.todos.past.length</code> and <code>state.todos.future.length</code>. You won’t need to write action creators for performing undo and redo because Redux Undo already provides them:</p> <h4 id=\"-containers-undoredo-js\"><code>containers/UndoRedo.js</code></h4> <pre data-language=\"js\">/* ... */\n\nimport { ActionCreators as UndoActionCreators } from 'redux-undo'\nimport { connect } from 'react-redux'\n\n/* ... */\n\nconst mapStateToProps = (state) =&gt; {\n  return {\n    canUndo: state.todos.past.length &gt; 0,\n    canRedo: state.todos.future.length &gt; 0\n  }\n}\n\nconst mapDispatchToProps = (dispatch) =&gt; {\n  return {\n    onUndo: () =&gt; dispatch(UndoActionCreators.undo()),\n    onRedo: () =&gt; dispatch(UndoActionCreators.redo())\n  }\n}\n\nUndoRedo = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(UndoRedo)\n\nexport default UndoRedo\n</pre> <p>Now you can add <code>UndoRedo</code> component to the <code>App</code> component:</p> <h4 id=\"-components-app-js\"><code>components/App.js</code></h4> <pre data-language=\"js\">import React from 'react'\nimport Footer from './Footer'\nimport AddTodo from '../containers/AddTodo'\nimport VisibleTodoList from '../containers/VisibleTodoList'\nimport UndoRedo from '../containers/UndoRedo'\n\nconst App = () =&gt; (\n  &lt;div&gt;\n    &lt;AddTodo /&gt;\n    &lt;VisibleTodoList /&gt;\n    &lt;Footer /&gt;\n    &lt;UndoRedo /&gt;\n  &lt;/div&gt;\n)\n\nexport default App\n</pre> <p>This is it! Run <code>npm install</code> and <code>npm start</code> in the <a href=\"https://github.com/reactjs/redux/tree/master/examples/todos-with-undo\" target=\"_blank\">example folder</a> and try it out!</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/recipes/ImplementingUndoHistory.html\" class=\"_attribution-link\">http://redux.js.org/docs/recipes/ImplementingUndoHistory.html</a>\n  </p>\n</div>\n","api/applymiddleware":"<h1 id=\"-applymiddleware-middlewares\">applyMiddleware(...middlewares)</h1> <p>Middleware is the suggested way to extend Redux with custom functionality. Middleware lets you wrap the store’s <a href=\"store#dispatch\"><code>dispatch</code></a> method for fun and profit. The key feature of middleware is that it is composable. Multiple middleware can be combined together, where each middleware requires no knowledge of what comes before or after it in the chain.</p> <p>The most common use case for middleware is to support asynchronous actions without much boilerplate code or a dependency on a library like <a href=\"https://github.com/Reactive-Extensions/RxJS\" target=\"_blank\">Rx</a>. It does so by letting you dispatch <a href=\"../glossary#async-action\">async actions</a> in addition to normal actions.</p> <p>For example, <a href=\"https://github.com/gaearon/redux-thunk\" target=\"_blank\">redux-thunk</a> lets the action creators invert control by dispatching functions. They would receive <a href=\"store#dispatch\"><code>dispatch</code></a> as an argument and may call it asynchronously. Such functions are called <em>thunks</em>. Another example of middleware is <a href=\"https://github.com/acdlite/redux-promise\" target=\"_blank\">redux-promise</a>. It lets you dispatch a <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\">Promise</a> async action, and dispatches a normal action when the Promise resolves.</p> <p>Middleware is not baked into <a href=\"createstore\"><code>createStore</code></a> and is not a fundamental part of the Redux architecture, but we consider it useful enough to be supported right in the core. This way, there is a single standard way to extend <a href=\"store#dispatch\"><code>dispatch</code></a> in the ecosystem, and different middleware may compete in expressiveness and utility.</p> <h4 id=\"arguments\">Arguments</h4> <ul> <li>\n<code>...middlewares</code> (<em>arguments</em>): Functions that conform to the Redux <em>middleware API</em>. Each middleware receives <a href=\"store\"><code>Store</code></a>’s <a href=\"store#dispatch\"><code>dispatch</code></a> and <a href=\"store#getState\"><code>getState</code></a> functions as named arguments, and returns a function. That function will be given the <code>next</code> middleware’s dispatch method, and is expected to return a function of <code>action</code> calling <code>next(action)</code> with a potentially different argument, or at a different time, or maybe not calling it at all. The last middleware in the chain will receive the real store’s <a href=\"store#dispatch\"><code>dispatch</code></a> method as the <code>next</code> parameter, thus ending the chain. So, the middleware signature is <code>({ getState, dispatch }) =&gt; next =&gt; action</code>.</li> </ul> <h4 id=\"returns\">Returns</h4> <p>(<em>Function</em>) A store enhancer that applies the given middleware. The store enhancer signature is <code>createStore =&gt; createStore'</code> but the easiest way to apply it is to pass it to <a href=\"createstore\"><code>createStore()</code></a> as the last <code>enhancer</code> argument.</p> <h4 id=\"example-custom-logger-middleware\">Example: Custom Logger Middleware</h4> <pre data-language=\"js\">import { createStore, applyMiddleware } from 'redux'\nimport todos from './reducers'\n\nfunction logger({ getState }) {\n  return (next) =&gt; (action) =&gt; {\n    console.log('will dispatch', action)\n\n    // Call the next dispatch method in the middleware chain.\n    let returnValue = next(action)\n\n    console.log('state after dispatch', getState())\n\n    // This will likely be the action itself, unless\n    // a middleware further in chain changed it.\n    return returnValue\n  }\n}\n\nlet store = createStore(\n  todos,\n  [ 'Use Redux' ],\n  applyMiddleware(logger)\n)\n\nstore.dispatch({\n  type: 'ADD_TODO',\n  text: 'Understand the middleware'\n})\n// (These lines will be logged by the middleware:)\n// will dispatch: { type: 'ADD_TODO', text: 'Understand the middleware' }\n// state after dispatch: [ 'Use Redux', 'Understand the middleware' ]\n</pre> <h4 id=\"example-using-thunk-middleware-for-async-actions\">Example: Using Thunk Middleware for Async Actions</h4> <pre data-language=\"js\">import { createStore, combineReducers, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk'\nimport * as reducers from './reducers'\n\nlet reducer = combineReducers(reducers)\n// applyMiddleware supercharges createStore with middleware:\nlet store = createStore(reducer, applyMiddleware(thunk))\n\nfunction fetchSecretSauce() {\n  return fetch('https://www.google.com/search?q=secret+sauce')\n}\n\n// These are the normal action creators you have seen so far.\n// The actions they return can be dispatched without any middleware.\n// However, they only express “facts” and not the “async flow”.\n\nfunction makeASandwich(forPerson, secretSauce) {\n  return {\n    type: 'MAKE_SANDWICH',\n    forPerson,\n    secretSauce\n  }\n}\n\nfunction apologize(fromPerson, toPerson, error) {\n  return {\n    type: 'APOLOGIZE',\n    fromPerson,\n    toPerson,\n    error\n  }\n}\n\nfunction withdrawMoney(amount) {\n  return {\n    type: 'WITHDRAW',\n    amount\n  }\n}\n\n// Even without middleware, you can dispatch an action:\nstore.dispatch(withdrawMoney(100))\n\n// But what do you do when you need to start an asynchronous action,\n// such as an API call, or a router transition?\n\n// Meet thunks.\n// A thunk is a function that returns a function.\n// This is a thunk.\n\nfunction makeASandwichWithSecretSauce(forPerson) {\n\n  // Invert control!\n  // Return a function that accepts `dispatch` so we can dispatch later.\n  // Thunk middleware knows how to turn thunk async actions into actions.\n\n  return function (dispatch) {\n    return fetchSecretSauce().then(\n      sauce =&gt; dispatch(makeASandwich(forPerson, sauce)),\n      error =&gt; dispatch(apologize('The Sandwich Shop', forPerson, error))\n    )\n  }\n}\n\n// Thunk middleware lets me dispatch thunk async actions\n// as if they were actions!\n\nstore.dispatch(\n  makeASandwichWithSecretSauce('Me')\n)\n\n// It even takes care to return the thunk’s return value\n// from the dispatch, so I can chain Promises as long as I return them.\n\nstore.dispatch(\n  makeASandwichWithSecretSauce('My wife')\n).then(() =&gt; {\n  console.log('Done!')\n})\n\n// In fact I can write action creators that dispatch\n// actions and async actions from other action creators,\n// and I can build my control flow with Promises.\n\nfunction makeSandwichesForEverybody() {\n  return function (dispatch, getState) {\n    if (!getState().sandwiches.isShopOpen) {\n\n      // You don’t have to return Promises, but it’s a handy convention\n      // so the caller can always call .then() on async dispatch result.\n\n      return Promise.resolve()\n    }\n\n    // We can dispatch both plain object actions and other thunks,\n    // which lets us compose the asynchronous actions in a single flow.\n\n    return dispatch(\n      makeASandwichWithSecretSauce('My Grandma')\n    ).then(() =&gt;\n      Promise.all([\n        dispatch(makeASandwichWithSecretSauce('Me')),\n        dispatch(makeASandwichWithSecretSauce('My wife'))\n      ])\n    ).then(() =&gt;\n      dispatch(makeASandwichWithSecretSauce('Our kids'))\n    ).then(() =&gt;\n      dispatch(getState().myMoney &gt; 42 ?\n        withdrawMoney(42) :\n        apologize('Me', 'The Sandwich Shop')\n      )\n    )\n  }\n}\n\n// This is very useful for server side rendering, because I can wait\n// until data is available, then synchronously render the app.\n\nimport { renderToString } from 'react-dom/server'\n\nstore.dispatch(\n  makeSandwichesForEverybody()\n).then(() =&gt;\n  response.send(renderToString(&lt;MyApp store={store} /&gt;))\n)\n\n// I can also dispatch a thunk async action from a component\n// any time its props change to load the missing data.\n\nimport { connect } from 'react-redux'\nimport { Component } from 'react'\n\nclass SandwichShop extends Component {\n  componentDidMount() {\n    this.props.dispatch(\n      makeASandwichWithSecretSauce(this.props.forPerson)\n    )\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.forPerson !== this.props.forPerson) {\n      this.props.dispatch(\n        makeASandwichWithSecretSauce(nextProps.forPerson)\n      )\n    }\n  }\n\n  render() {\n    return &lt;p&gt;{this.props.sandwiches.join('mustard')}&lt;/p&gt;\n  }\n}\n\nexport default connect(\n  state =&gt; ({\n    sandwiches: state.sandwiches\n  })\n)(SandwichShop)\n</pre> <h4 id=\"tips\">Tips</h4> <ul> <li>\n<p>Middleware only wraps the store’s <a href=\"store#dispatch\"><code>dispatch</code></a> function. Technically, anything a middleware can do, you can do manually by wrapping every <code>dispatch</code> call, but it’s easier to manage this in a single place and define action transformations on the scale of the whole project.</p> </li> <li>\n<p>If you use other store enhancers in addition to <code>applyMiddleware</code>, make sure to put <code>applyMiddleware</code> before them in the composition chain because the middleware is potentially asynchronous. For example, it should go before <a href=\"https://github.com/gaearon/redux-devtools\" target=\"_blank\">redux-devtools</a> because otherwise the DevTools won’t see the raw actions emitted by the Promise middleware and such.</p> </li> <li>\n<p>If you want to conditionally apply a middleware, make sure to only import it when it’s needed:</p> <pre data-language=\"js\">let middleware = [ a, b ]\nif (process.env.NODE_ENV !== 'production') {\n  let c = require('some-debug-middleware')\n  let d = require('another-debug-middleware')\n  middleware = [ ...middleware, c, d ]\n}\n\nconst store = createStore(\n  reducer,\n  initialState,\n  applyMiddleware(...middleware)\n)\n</pre> <p>This makes it easier for bundling tools to cut out unneeded modules and reduces the size of your builds.</p> </li> <li>\n<p>Ever wondered what <code>applyMiddleware</code> itself is? It ought to be an extension mechanism more powerful than the middleware itself. Indeed, <code>applyMiddleware</code> is an example of the most powerful Redux extension mechanism called <a href=\"../glossary#store-enhancer\">store enhancers</a>. It is highly unlikely you’ll ever want to write a store enhancer yourself. Another example of a store enhancer is <a href=\"https://github.com/gaearon/redux-devtools\" target=\"_blank\">redux-devtools</a>. Middleware is less powerful than a store enhancer, but it is easier to write.</p> </li> <li>\n<p>Middleware sounds much more complicated than it really is. The only way to really understand middleware is to see how the existing middleware works, and try to write your own. The function nesting can be intimidating, but most of the middleware you’ll find are, in fact, 10-liners, and the nesting and composability is what makes the middleware system powerful.</p> </li> <li>\n<p>To apply multiple store enhancers, you may use <a href=\"compose\"><code>compose()</code></a>.</p> </li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/api/applyMiddleware.html\" class=\"_attribution-link\">http://redux.js.org/docs/api/applyMiddleware.html</a>\n  </p>\n</div>\n","faq":"<h1 id=\"redux-faq\">Redux FAQ</h1> <h2 id=\"table-of-contents\">Table of Contents</h2> <ul> <li>\n<strong>General</strong><ul> <li>\n<a href=\"#general-when-to-use\">When should I use Redux?</a> </li> <li>\n<a href=\"#general-only-react\">Can Redux only be used with React?</a> </li> <li>\n<a href=\"#general-build-tools\">Do I need to have a particular build tool to use Redux?</a> </li> </ul> </li> <li>\n<strong>Reducers</strong><ul> <li>\n<a href=\"#reducers-share-state\">How do I share state between two reducers? Do I have to use combineReducers?</a> </li> <li>\n<a href=\"#reducers-use-switch\">Do I have to use the switch statement to handle actions?</a> </li> </ul> </li> <li>\n<strong>Organizing State</strong><ul> <li>\n<a href=\"#organizing-state-only-redux-state\">Do I have to put all my state into Redux? Should I ever use React’s setState()?</a> </li> <li>\n<a href=\"#organizing-state-non-serializable\">Can I put functions, promises, or other non-serializable items in my store state?</a> </li> <li>\n<a href=\"#organizing-state-nested-data\">How do I organize nested or duplicate data in my state?</a> </li> </ul> </li> <li>\n<strong>Store Setup</strong><ul> <li>\n<a href=\"#store-setup-multiple-stores\">Can or should I create multiple stores? Can I import my store directly, and use it in components myself?</a> </li> <li>\n<a href=\"#store-setup-middleware-chains\">Is it OK to have more than one middleware chain in my store enhancer? What is the difference between next and dispatch in a middleware function?</a> </li> <li>\n<a href=\"#store-setup-subscriptions\">How do I subscribe to only a portion of the state? Can I get the dispatched action as part of the subscription?</a> </li> </ul> </li> <li>\n<strong>Actions</strong><ul> <li>\n<a href=\"#actions-string-constants\">Why should type be a string, or at least serializable? Why should my action types be constants?</a> </li> <li><a href=\"#actions-reducer-mappings\">Is there always a one-to-one mapping between reducers and actions?</a></li> <li>\n<a href=\"#actions-side-effects\">How can I represent “side effects” such as AJAX calls? Why do we need things like “action creators”, “thunks”, and “middleware” to do async behavior?</a> </li> <li>\n<a href=\"#actions-multiple-actions\">Should I dispatch multiple actions in a row from one action creator?</a> </li> </ul> </li> <li>\n<strong>Code Structure</strong> <ul> <li><a href=\"#structure-file-structure\">What should my file structure look like? How should I group my action creators and reducers in my project? Where should my selectors go?</a></li> <li>\n<a href=\"#structure-business-logic\">How should I split my logic between reducers and action creators? Where should my “business logic” go?</a> </li> </ul> </li> <li>\n<strong>Performance</strong><ul> <li><a href=\"#performance-scaling\">How well does Redux “scale” in terms of performance and architecture?</a></li> <li><a href=\"#performance-all-reducers\">Won’t calling “all my reducers” for each action be slow?</a></li> <li><a href=\"#performance-clone-state\">Do I have to deep-clone my state in a reducer? Isn’t copying my state going to be slow?</a></li> <li><a href=\"#performance-update-events\">How can I reduce the number of store update events?</a></li> <li><a href=\"#performance-state-memory\">Will having “one state tree” cause memory problems? Will dispatching many actions take up memory?</a></li> </ul> </li> <li>\n<strong>React Redux</strong><ul> <li><a href=\"#react-not-rerendering\">Why isn’t my component re-rendering, or my mapStateToProps running?</a></li> <li><a href=\"#react-rendering-too-often\">Why is my component re-rendering too often?</a></li> <li><a href=\"#react-mapstate-speed\">How can I speed up my mapStateToProps?</a></li> <li><a href=\"#react-props-dispatch\">Why don’t I have this.props.dispatch available in my connected component?</a></li> <li><a href=\"#react-multiple-components\">Should I only connect my top component, or can I connect multiple components in my tree?</a></li> </ul> </li> <li>\n<strong>Miscellaneous</strong><ul> <li><a href=\"#miscellaneous-real-projects\">Are there any larger, “real” Redux projects?</a></li> <li><a href=\"#miscellaneous-authentication\">How can I implement authentication in Redux?</a></li> </ul> </li> </ul> <h2 id=\"general\">General</h2>  <h3 id=\"general-when-to-use\">When should I use Redux?</h3> <p>Pete Hunt, one of the early contributors to React, says:</p> <blockquote> <p>You’ll know when you need Flux. If you aren’t sure if you need it, you don’t need it.</p> </blockquote> <p>Similarly, Dan Abramov, one of the creators of Redux, says:</p> <blockquote> <p>I would like to amend this: don’t use Redux until you have problems with vanilla React.</p> </blockquote> <p>In general, use Redux when you have reasonable amounts of data changing over time, you need a single source of truth, and you find that approaches like keeping everything in a top-level React component’s state are no longer sufficient.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Documentation</strong></p> <ul> <li><a href=\"introduction/motivation\">Introduction: Motivation</a></li> </ul> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/petehunt/react-howto\" target=\"_blank\">React How-To</a></li> <li><a href=\"https://twitter.com/dan_abramov/status/699241546248536064\" target=\"_blank\">Twitter: Don’t use Redux until...</a></li> <li><a href=\"https://medium.com/swlh/the-case-for-flux-379b7d1982c6\" target=\"_blank\">The Case for Flux</a></li> <li><a href=\"http://stackoverflow.com/questions/32461229/why-use-redux-over-facebook-flux\" target=\"_blank\">Stack Overflow: Why use Redux over Facebook Flux?</a></li> <li><a href=\"http://stackoverflow.com/questions/35675339/why-should-i-use-redux-in-this-example\" target=\"_blank\">Stack Overflow: Why should I use Redux in this example?</a></li> <li><a href=\"http://stackoverflow.com/questions/32021763/what-could-be-the-downsides-of-using-redux-instead-of-flux\" target=\"_blank\">Stack Overflow: What could be the downsides of using Redux instead of Flux?</a></li> </ul>  <h3 id=\"general-only-react\">Can Redux only be used with React?</h3> <p>Redux can be used as a data store for any UI layer. The most common usage is with React and React Native, but there are bindings available for Angular, Angular 2, Vue, Mithril, and more. Redux simply provides a subscription mechanism which can be used by any other code. That said it is most useful when combined with a declarative view implementation that can infer the UI updates from the state changes.</p>  <h3 id=\"general-build-tools\">Do I need to have a particular build tool to use Redux?</h3> <p>Redux is originally written in ES6 and transpiled for production into ES5 with Webpack and Babel. You should be able to use it regardless of your JavaScript build process. Redux also offers a UMD build that can be used directly without any build process at all. The <a href=\"https://github.com/reactjs/redux/tree/master/examples/counter-vanilla\" target=\"_blank\">counter-vanilla</a> example demonstrates basic ES5 usage with Redux included as a <code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">&gt;</span></span></code> tag. As the relevant pull request says:</p> <blockquote> <p>The new Counter Vanilla example is aimed to dispel the myth that Redux requires Webpack, React, hot reloading, sagas, action creators, constants, Babel, npm, CSS modules, decorators, fluent Latin, an Egghead subscription, a PhD, or an Exceeds Expectations O.W.L. level.</p> <p>Nope, it’s just HTML, some artisanal <code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">&gt;</span></span></code> tags, and plain old DOM manipulation. Enjoy!</p> </blockquote> <h2 id=\"reducers\">Reducers</h2>  <h3 id=\"reducers-share-state\">How do I share state between two reducers? Do I have to use <code>combineReducers</code>?</h3> <p>The suggested structure for a Redux store is to split the state object into multiple “slices” or “domains” by key, and provide a separate reducer function to manage each individual data slice. This is similar to how the standard Flux pattern has multiple independent stores, and Redux provides the <a href=\"api/combinereducers\"><code>combineReducers</code></a> utility function to make this pattern easier. However, it’s important to note that <code>combineReducers</code> is <em>not</em> required—it is simply a utility function for the common use case of having a single reducer function per state slice, with plain JavaScript objects for the data.</p> <p>Many users later want to try to share data between two reducers, but find that <code>combineReducers</code> does not allow them to do so. There are several approaches that can be used:</p> <ul> <li>If a reducer needs to know data from another slice of state, the state tree shape may need to be reorganized so that a single reducer is handling more of the data.</li> <li>You may need to write some custom functions for handling some of these actions. This may require replacing <code>combineReducers</code> with your own top-level reducer function. You can also use a utility such as <a href=\"https://github.com/acdlite/reduce-reducers\" target=\"_blank\">reduce-reducers</a> to run <code>combineReducers</code> to handle most actions, but also run a more specialized reducer for specific actions that cross state slices.</li> <li>\n<a href=\"advanced/asyncactions\">Async action creators</a> such as <code>redux-thunk</code> have access to the entire state through <code>getState()</code>. An action creator can retrieve additional data from the state and put it in an action, so that each reducer has enough information to update its own state slice.</li> </ul> <p>In general, remember that reducers are just functions—you can organize them and subdivide them any way you want, and you are encouraged to break them down into smaller, reusable functions (“reducer composition”). While you do so, you may pass a custom third argument from a parent reducer if a child reducer needs additional data to calculate its next state. You just need to make sure that together they follow the basic rules of reducers: <code>(state, action) =&gt; newState</code>, and update state immutably rather than mutating it directly.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Documentation</strong></p> <ul> <li><a href=\"api/combinereducers\">API: combineReducers</a></li> </ul> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/reactjs/redux/issues/601\" target=\"_blank\">#601: A concern on combineReducers, when an action is related to multiple reducers</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/1400\" target=\"_blank\">#1400: Is passing top-level state object to branch reducer an anti-pattern?</a></li> <li><a href=\"http://stackoverflow.com/questions/34333979/accessing-other-parts-of-the-state-when-using-combined-reducers\" target=\"_blank\">Stack Overflow: Accessing other parts of the state when using combined reducers?</a></li> <li><a href=\"http://stackoverflow.com/questions/34427851/reducing-an-entire-subtree-with-redux-combinereducers\" target=\"_blank\">Stack Overflow: Reducing an entire subtree with redux combineReducers</a></li> <li><a href=\"https://invalidpatent.wordpress.com/2016/02/18/sharing-state-between-redux-reducers/\" target=\"_blank\">Sharing State Between Redux Reducers</a></li> </ul>  <h3 id=\"reducers-use-switch\">Do I have to use the <code>switch</code> statement to handle actions?</h3> <p>No. You are welcome to use any approach you’d like to respond to an action in a reducer. The <code>switch</code> statement is the most common approach, but it’s fine to use <code>if</code> statements, a lookup table of functions, or to create a function that abstracts this away.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Documentation</strong></p> <ul> <li><a href=\"recipes/reducingboilerplate\">Recipes: Reducing Boilerplate</a></li> </ul> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/reactjs/redux/issues/883\" target=\"_blank\">#883: take away the huge switch block</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/1167\" target=\"_blank\">#1167: Reducer without switch</a></li> </ul> <h2 id=\"organizing-state\">Organizing State</h2>  <h3 id=\"organizing-state-only-redux-state\">Do I have to put all my state into Redux? Should I ever use React’s <code>setState()</code>?</h3> <p>There is no “right” answer for this. Some users prefer to keep every single piece of data in Redux, to maintain a fully serializable and controlled version of their application at all times. Others prefer to keep non-critical or UI state, such as “is this dropdown currently open”, inside a component’s internal state. Find a balance that works for you, and go with it.</p> <p>There are a number of community packages that implement various approaches for storing per-component state in a Redux store instead, such as <a href=\"https://github.com/tonyhb/redux-ui\" target=\"_blank\">redux-ui</a>, <a href=\"https://github.com/tomchentw/redux-component\" target=\"_blank\">redux-component</a>, <a href=\"https://github.com/threepointone/redux-react-local\" target=\"_blank\">redux-react-local</a>, and more.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/reactjs/redux/issues/159\" target=\"_blank\">#159: Investigate using Redux for pseudo-local component state</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/1098\" target=\"_blank\">#1098: Using Redux in reusable React component</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/1287\" target=\"_blank\">#1287: How to choose between Redux's store and React's state?</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/1385\" target=\"_blank\">#1385: What are the disadvantages of storing all your state in a single immutable atom?</a></li> <li><a href=\"http://stackoverflow.com/questions/35664594/redux-why-is-state-all-in-one-place-even-state-that-isnt-global\" target=\"_blank\">Stack Overflow: Why is state all in one place, even state that isn't global?</a></li> <li><a href=\"http://stackoverflow.com/questions/35328056/react-redux-should-all-component-states-be-kept-in-redux-store\" target=\"_blank\">Stack Overflow: Should all component state be kept in Redux store?</a></li> </ul>  <h3 id=\"organizing-state-non-serializable\">Can I put functions, promises, or other non-serializable items in my store state?</h3> <p>It is highly recommended that you only put plain serializable objects, arrays, and primitives into your store. It’s <em>technically</em> possible to insert non-serializable items into the store, but doing so can break the ability to persist and rehydrate the contents of a store.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/reactjs/redux/issues/1248\" target=\"_blank\">#1248: Is it ok and possible to store a react component in a reducer?</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/1279\" target=\"_blank\">#1279: Have any suggestions for where to put a Map Component in Flux?</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/1390\" target=\"_blank\">#1390: Component Loading</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/1407\" target=\"_blank\">#1407: Just sharing a great base class</a></li> </ul>  <h3 id=\"organizing-state-nested-data\">How do I organize nested or duplicate data in my state?</h3> <p>Data with IDs, nesting, or relationships should generally be stored in a “normalized” fashion: each object should be stored once, keyed by ID, and other objects that reference it should only store the ID rather than a copy of the entire object. It may help to think of parts of your store as a database, with individual “tables” per item type. Libraries such as <a href=\"https://github.com/gaearon/normalizr\" target=\"_blank\">normalizr</a> and <a href=\"https://github.com/tommikaikkonen/redux-orm\" target=\"_blank\">redux-orm</a> can provide help and abstractions in managing normalized data.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Documentation</strong></p> <ul> <li><a href=\"advanced/asyncactions\">Advanced: Async Actions</a></li> <li><a href=\"introduction/examples#real-world\">Examples: Real World example</a></li> </ul> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/reactjs/redux/issues/316\" target=\"_blank\">#316: How to create nested reducers?</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/815\" target=\"_blank\">#815: Working with Data Structures</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/946\" target=\"_blank\">#946: Best way to update related state fields with split reducers?</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/994\" target=\"_blank\">#994: How to cut the boilerplate when updating nested entities?</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/1255\" target=\"_blank\">#1255: Normalizr usage with nested objects in React/Redux</a></li> <li><a href=\"https://twitter.com/dan_abramov/status/715507260244496384\" target=\"_blank\">Twitter: state shape should be normalized</a></li> </ul> <h2 id=\"store-setup\">Store Setup</h2>  <h3 id=\"store-setup-multiple-stores\">Can or should I create multiple stores? Can I import my store directly, and use it in components myself?</h3> <p>The original Flux pattern describes having multiple “stores” in an app, each one holding a different area of domain data. This can introduce issues such as needing to have one store “<code>waitFor</code>” another store to update. This is not necessary in Redux because the separation between data domains is already achieved by splitting a single reducer into smaller reducers.</p> <p>As with several other questions, it is <em>possible</em> to create multiple distinct Redux stores in a page, but the intended pattern is to have only a single store. Having a single store enables using the Redux DevTools, makes persisting and rehydrating data simpler, and simplifies the subscription logic.</p> <p>Some valid reasons for using multiple stores in Redux might include:</p> <ul> <li>Solving a performance issue caused by too frequent updates of some part of the state, when confirmed by profiling the app.</li> <li>Isolating a Redux app as a component in a bigger application, in which case you might want to create a store per root component instance.</li> </ul> <p>However, creating new stores shouldn’t be your first instinct, especially if you come from a Flux background. Try reducer composition first, and only use multiple stores if it doesn’t solve your problem.</p> <p>Similarly, while you <em>can</em> reference your store instance by importing it directly, this is not a recommended pattern in Redux. If you create a store instance and export it from a module, it will become a singleton. This means it will be harder to isolate a Redux app as a component of a larger app, if this is ever necessary, or to enable server rendering, because on the server you want to create separate store instances for every request.</p> <p>With <a href=\"https://github.com/rackt/react-redux\" target=\"_blank\">React Redux</a>, the wrapper classes generated by the <code>connect()</code> function do actually look for <code>props.store</code> if it exists, but it’s best if you wrap your root component in <code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Provider</span> <span class=\"token attr-name\">store</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span>{store}</span><span class=\"token punctuation\">&gt;</span></span></code> and let React Redux worry about passing the store down. This way components don’t need to worry about importing a store module, and isolating a Redux app or enabling server rendering is much easier to do later.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Documentation</strong></p> <ul> <li><a href=\"api/store\">API: Store</a></li> </ul> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/reactjs/redux/issues/1436\" target=\"_blank\">#1346: Is it bad practice to just have a 'stores' directory?</a></li> <li><a href=\"http://stackoverflow.com/questions/33619775/redux-multiple-stores-why-not\" target=\"_blank\">Stack Overflow: Redux multiple stores, why not?</a></li> <li><a href=\"http://stackoverflow.com/questions/35667249/accessing-redux-state-in-an-action-creator\" target=\"_blank\">Stack Overflow: Accessing Redux state in an action creator</a></li> <li><a href=\"https://gist.github.com/gaearon/eeee2f619620ab7b55673a4ee2bf8400\" target=\"_blank\">Gist: Breaking out of Redux paradigm to isolate apps</a></li> </ul>  <h3 id=\"store-setup-middleware-chains\">Is it OK to have more than one middleware chain in my store enhancer? What is the difference between <code>next</code> and <code>dispatch</code> in a middleware function?</h3> <p>Redux middleware act like a linked list. Each middleware function can either call <code>next(action)</code> to pass an action along to the next middleware in line, call <code>dispatch(action)</code> to restart the processing at the beginning of the list, or do nothing at all to stop the action from being processed further.</p> <p>This chain of middleware is defined by the arguments passed to the <code>applyMiddleware</code> function used when creating a store. Defining multiple chains will not work correctly, as they would have distinctly different <code>dispatch</code> references and the different chains would effectively be disconnected.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Documentation</strong></p> <ul> <li><a href=\"advanced/middleware\">Advanced: Middleware</a></li> <li><a href=\"api/applymiddleware\">API: applyMiddleware</a></li> </ul> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/reactjs/redux/issues/1051\" target=\"_blank\">#1051: Shortcomings of the current applyMiddleware and composing createStore</a></li> <li><a href=\"https://medium.com/@meagle/understanding-87566abcfb7a\" target=\"_blank\">Understanding Redux Middleware</a></li> <li><a href=\"http://blog.krawaller.se/posts/exploring-redux-middleware/\" target=\"_blank\">Exploring Redux Middleware</a></li> </ul>  <h3 id=\"store-setup-subscriptions\">How do I subscribe to only a portion of the state? Can I get the dispatched action as part of the subscription?</h3> <p>Redux provides a single <code>store.subscribe</code> method for notifying listeners that the store has updated. Listener callbacks do not receive the current state as an argument—it is simply an indication that <em>something</em> has changed. The subscriber logic can then call <code>getState()</code> to get the current state value.</p> <p>This API is intended as a low-level primitive with no dependencies or complications, and can be used to build higher-level subscription logic. UI bindings such as React Redux can create a subscription for each connected component. It is also possible to write functions that can intelligently compare the old state vs the new state, and execute additional logic if certain pieces have changed. Examples include <a href=\"https://github.com/jprichardson/redux-watch\" target=\"_blank\">redux-watch</a> and <a href=\"https://github.com/ashaffer/redux-subscribe\" target=\"_blank\">redux-subscribe</a> which offer different approaches to specifying subscriptions and handling changes.</p> <p>The new state is not passed to the listeners in order to simplify implementing store enhancers such as the Redux DevTools. In addition, subscribers are intended to react to the state value itself, not the action. Middleware can be used if the action is important and needs to be handled specifically.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Documentation</strong></p> <ul> <li><a href=\"basics/store\">Basics: Store</a></li> <li><a href=\"api/store\">API: Store</a></li> </ul> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/reactjs/redux/issues/303\" target=\"_blank\">#303: subscribe API with state as an argument</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/580\" target=\"_blank\">#580: Is it possible to get action and state in store.subscribe?</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/922\" target=\"_blank\">#922: Proposal: add subscribe to middleware API</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/1057\" target=\"_blank\">#1057: subscribe listener can get action param?</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/1300\" target=\"_blank\">#1300: Redux is great but major feature is missing</a></li> </ul> <h2 id=\"actions\">Actions</h2>  <h3 id=\"actions-string-constants\">Why should <code>type</code> be a string, or at least serializable? Why should my action types be constants?</h3> <p>As with state, serializable actions enable several of Redux’s defining features, such as time travel debugging, and recording and replaying actions. Using something like a <code>Symbol</code> for the <code>type</code> value or using <code>instanceof</code> checks for actions themselves would break that. Strings are serializable and easily self-descriptive, and so are a better choice. Note that it <em>is</em> okay to use Symbols, Promises, or other non-serializable values in an action if the action is intended for use by middleware. Actions only need to be serializable by the time they actually reach the store and are passed to the reducers.</p> <p>We can’t reliably enforce serializable actions for performance reasons, so Redux only checks that every action is a plain object, and that the <code>type</code> is defined. The rest is up to you, but you might find that keeping everything serializable helps debug and reproduce issues.</p> <p>Encapsulating and centralizing commonly used pieces of code is a key concept in programming. While it is certainly possible to manually create action objects everywhere, and write each <code>type</code> value by hand, defining reusable constants makes maintaining code easier. If you put constants in a separate file, you can <a href=\"https://www.npmjs.com/package/eslint-plugin-import\" target=\"_blank\">check your <code>import</code> statements against typos</a> so you can’t accidentally use the wrong string.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Documentation</strong></p> <ul> <li><a href=\"http://rackt.github.io/redux/docs/recipes/ReducingBoilerplate.html#actions\" target=\"_blank\">Reducing Boilerplate</a></li> </ul> <p><strong>Discussion</strong></p> <ul> <li><a href=\"https://github.com/reactjs/redux/issues/384\" target=\"_blank\">#384: Recommend that Action constants be named in the past tense</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/628\" target=\"_blank\">#628: Solution for simple action creation with less boilerplate</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/1024\" target=\"_blank\">#1024: Proposal: Declarative reducers</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/1167\" target=\"_blank\">#1167: Reducer without switch</a></li> <li><a href=\"http://stackoverflow.com/q/34759047/62937\" target=\"_blank\">Stack Overflow: Why do you need 'Actions' as data in Redux?</a></li> <li><a href=\"http://stackoverflow.com/q/34965856/62937\" target=\"_blank\">Stack Overflow: What is the point of the constants in Redux?</a></li> </ul>  <h3 id=\"actions-reducer-mappings\">Is there always a one-to-one mapping between reducers and actions?</h3> <p>No. We suggest you write independent small reducer functions that are each responsible for updates to a specific slice of state. We call this pattern “reducer composition”. A given action could be handled by all, some, or none of them. This keep components decoupled from the actual data changes, as one action may affect different parts of the state tree, and there is no need for the component to be aware of this. Some users do choose to bind them more tightly together, such as the “ducks” file structure, but there is definitely no one-to-one mapping by default, and you should break out of such a paradigm any time you feel you want to handle an action in many reducers.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Documentation</strong></p> <ul> <li><a href=\"basics/reducers\">Basics: Reducers</a></li> </ul> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://twitter.com/dan_abramov/status/682923564006248448\" target=\"_blank\">Twitter: most common Redux misconception</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/1167\" target=\"_blank\">#1167: Reducer without switch</a></li> <li><a href=\"https://github.com/reduxible/reduxible/issues/8\" target=\"_blank\">Reduxible #8: Reducers and action creators aren't a one-to-one mapping</a></li> <li><a href=\"http://stackoverflow.com/questions/35493352/can-i-dispatch-multiple-actions-without-redux-thunk-middleware/35642783\" target=\"_blank\">Stack Overflow: Can I dispatch multiple actions without Redux Thunk middleware?</a></li> </ul>  <h3 id=\"actions-side-effects\">How can I represent “side effects” such as AJAX calls? Why do we need things like “action creators”, “thunks”, and “middleware” to do async behavior?</h3> <p>This is a long and complex topic, with a wide variety of opinions on how code should be organized and what approaches should be used.</p> <p>Any meaningful web app needs to execute complex logic, usually including asynchronous work such as making AJAX requests. That code is no longer purely a function of its inputs, and the interactions with the outside world are known as <a href=\"https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29\" target=\"_blank\">“side effects”</a></p> <p>Redux is inspired by functional programming, and out of the box, has no place for side effects to be executed. In particular, reducer functions <em>must</em> always be pure functions of <code>(state, action) =&gt; newState</code>. However, Redux’s middleware makes it possible to intercept dispatched actions and add additional complex behavior around them, including side effects.</p> <p>In general, Redux suggests that code with side effects should be part of the action creation process. While that logic <em>can</em> be performed inside of a UI component, it generally makes sense to extract that logic into a reusable function so that the same logic can be called from multiple places—in other words, an action creator function.</p> <p>The simplest and most common way to do this is to add the <a href=\"https://github.com/gaearon/redux-thunk\" target=\"_blank\">Redux Thunk</a> middleware that lets you write action creators with more complex and asynchronous logic. Another widely-used method is <a href=\"https://github.com/yelouafi/redux-saga\" target=\"_blank\">Redux Saga</a> which lets you write more synchronous-looking code using generators, and can act like “background threads” or “daemons” in a Redux app. Yet another approach is <a href=\"https://github.com/raisemarketplace/redux-loop\" target=\"_blank\">Redux Loop</a>, which inverts the process by allowing your reducers to declare side effects in response to state changes and have them executed separately. Beyond that, there are <em>many</em> other community-developed libraries and ideas, each with their own take on how side effects should be managed.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Documentation</strong></p> <ul> <li><a href=\"advanced/asyncactions\">Advanced: Async Actions</a></li> <li><a href=\"advanced/asyncflow\">Advanced: Async Flow</a></li> <li><a href=\"advanced/middleware\">Advanced: Middleware</a></li> </ul> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/reactjs/redux/issues/291\" target=\"_blank\">#291: Trying to put API calls in the right place</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/455\" target=\"_blank\">#455: Modeling side effects</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/533\" target=\"_blank\">#533: Simpler introduction to async action creators</a></li> <li><a href=\"https://github.com/reactjs/redux/pull/569\" target=\"_blank\">#569: Proposal: API for explicit side effects</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/1139\" target=\"_blank\">#1139: An alternative side effect model based on generators and sagas</a></li> <li><a href=\"http://stackoverflow.com/questions/34570758/why-do-we-need-middleware-for-async-flow-in-redux\" target=\"_blank\">Stack Overflow: Why do we need middleware for async flow in Redux?</a></li> <li><a href=\"http://stackoverflow.com/questions/35411423/how-to-dispatch-a-redux-action-with-a-timeout/35415559\" target=\"_blank\">Stack Overflow: How to dispatch a Redux action with a timeout?</a></li> <li><a href=\"http://stackoverflow.com/questions/32982237/where-should-i-put-synchronous-side-effects-linked-to-actions-in-redux/33036344\" target=\"_blank\">Stack Overflow: Where should I put synchronous side effects linked to actions in redux?</a></li> <li><a href=\"http://stackoverflow.com/questions/32925837/how-to-handle-complex-side-effects-in-redux/33036594\" target=\"_blank\">Stack Overflow: How to handle complex side-effects in Redux?</a></li> <li><a href=\"http://stackoverflow.com/questions/33011729/how-to-unit-test-async-redux-actions-to-mock-ajax-response/33053465\" target=\"_blank\">Stack Overflow: How to unit test async Redux actions to mock ajax response</a></li> <li><a href=\"http://stackoverflow.com/questions/35262692/how-to-fire-ajax-calls-in-response-to-the-state-changes-with-redux/35675447\" target=\"_blank\">Stack Overflow: How to fire AJAX calls in response to the state changes with Redux?</a></li> <li><a href=\"https://www.reddit.com/r/reactjs/comments/469iyc/help_performing_async_api_calls_with_reduxpromise/\" target=\"_blank\">Reddit: Help performing Async API calls with Redux-Promise Middleware.</a></li> <li><a href=\"https://twitter.com/dan_abramov/status/689639582120415232\" target=\"_blank\">Twitter: possible comparison between sagas, loops, and other approaches</a></li> <li><a href=\"https://medium.com/@fward/redux-side-effects-and-you-66f2e0842fc3\" target=\"_blank\">Redux Side-Effects and You</a></li> <li><a href=\"http://blog.hivejs.org/building-the-ui-2/\" target=\"_blank\">Pure functionality and side effects in Redux</a></li> </ul>  <h3 id=\"actions-multiple-actions\">Should I dispatch multiple actions in a row from one action creator?</h3> <p>There’s no specific rule for how you should structure your actions. Using an async middleware like Redux Thunk certainly enables scenarios such as dispatching multiple distinct but related actions in a row, dispatching actions to represent progression of an AJAX request, dispatching actions conditionally based on state, or even dispatching an action and checking the updated state immediately afterwards.</p> <p>In general, ask if these actions are related but independent, or should actually be represented as one action. Do what makes sense for your own situation but try to balance the readability of reducers with readability of the action log. For example, an action that includes the whole new state tree would make your reducer a one-liner, but the downside is now you have no history of <em>why</em> the changes are happening, so debugging gets really difficult. On the other hand, if you emit actions in a loop to keep them granular, it’s a sign that you might want to introduce a new action type that is handled in a different way.</p> <p>Try to avoid dispatching several times synchronously in a row in the places where you’re concerned about performance. If you use React, note that you can improve performance of multiple synchronous dispatches by wrapping them in <code>ReactDOM.unstable_batchedUpdates()</code>, but this API is experimental and may be removed in any React release so don’t rely on it too heavily. Take a look at <a href=\"https://github.com/tshelburne/redux-batched-actions\" target=\"_blank\">redux-batched-actions</a> that lets you dispatch several actions as if it was one and “unpack” them in the reducer, and <a href=\"https://github.com/tappleby/redux-batched-subscribe\" target=\"_blank\">redux-batched-subscribe</a> which lets you debounce subscriber calls for multiple dispatches.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/reactjs/redux/issues/597\" target=\"_blank\">#597: Valid to dispatch multiple actions from an event handler?</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/959\" target=\"_blank\">#959: Multiple actions one dispatch?</a></li> <li><a href=\"http://stackoverflow.com/questions/33637740/should-i-use-one-or-several-action-types-to-represent-this-async-action/33816695\" target=\"_blank\">Stack Overflow: Should I use one or several action types to represent this async action?</a></li> <li><a href=\"http://stackoverflow.com/questions/35406707/do-events-and-actions-have-a-11-relationship-in-redux/35410524\" target=\"_blank\">Stack Overflow: Do events and actions have a 1:1 relationship in Redux?</a></li> <li><a href=\"http://stackoverflow.com/questions/33220776/should-actions-like-showing-hiding-loading-screens-be-handled-by-reducers-to-rel/33226443#33226443\" target=\"_blank\">Stack Overflow: Should actions be handled by reducers to related actions or generated by action creators themselves?</a></li> </ul> <h2 id=\"code-structure\">Code Structure</h2>  <h3 id=\"structure-file-structure\">What should my file structure look like? How should I group my action creators and reducers in my project? Where should my selectors go?</h3> <p>Since Redux is just a data store library, it has no direct opinion on how your project should be structured. However, there are a few common patterns that most Redux developers tend to use:</p> <ul> <li>Rails-style: separate folders for “actions”, “constants”, “reducers”, “containers”, and “components”</li> <li>Domain-style: separate folders per feature or domain, possibly with sub-folders per file type</li> <li>“Ducks”: similar to domain style, but explicitly tying together actions and reducers, often by defining them in the same file</li> </ul> <p>It’s generally suggested that selectors are defined alongside reducers and exported, and then reused elsewhere (such as in <code>mapStateToProps</code> functions, in async action creators, or sagas) to colocate all the code that knows about the actual shape of the state tree in the reducer files.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/reactjs/redux/issues/839\" target=\"_blank\">#839: Emphasize defining selectors alongside reducers</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/943\" target=\"_blank\">#943: Reducer querying</a></li> <li><a href=\"https://github.com/mxstbr/react-boilerplate/issues/27\" target=\"_blank\">React Boilerplate #27: Application Structure</a></li> <li><a href=\"http://stackoverflow.com/questions/32634320/how-to-structure-redux-components-containers/32921576\" target=\"_blank\">Stack Overflow: How to structure Redux components/containers</a></li> <li><a href=\"https://medium.com/lexical-labs-engineering/redux-best-practices-64d59775802e\" target=\"_blank\">Redux Best Practices</a></li> <li><a href=\"http://jaysoo.ca/2016/02/28/organizing-redux-application/\" target=\"_blank\">Rules For Structuring (Redux) Applications </a></li> <li><a href=\"http://marmelab.com/blog/2015/12/17/react-directory-structure.html\" target=\"_blank\">A Better File Structure for React/Redux Applications</a></li> <li><a href=\"http://engineering.kapost.com/2016/01/organizing-large-react-applications/\" target=\"_blank\">Organizing Large React Applications</a></li> <li><a href=\"https://medium.com/@msandin/strategies-for-organizing-code-2c9d690b6f33\" target=\"_blank\">Four Strategies for Organizing Code</a></li> </ul>  <h3 id=\"structure-business-logic\">How should I split my logic between reducers and action creators? Where should my “business logic” go?</h3> <p>There’s no single clear answer to exactly what pieces of logic should go in a reducer or an action creator. Some developers prefer to have “fat” action creators, with “thin” reducers that simply take the data in an action and blindly merge it into the corresponding state. Others try to emphasize keeping actions as small as possible, and minimize the usage of <code>getState()</code> in an action creator.</p> <p>This comment sums up the dichotomy nicely:</p> <blockquote> <p>Now, the problem is what to put in the action creator and what in the reducer, the choice between fat and thin action objects. If you put all the logic in the action creator, you end up with fat action objects that basically declare the updates to the state. Reducers become pure, dumb, add-this, remove that, update these functions. They will be easy to compose. But not much of your business logic will be there. If you put more logic in the reducer, you end up with nice, thin action objects, most of your data logic in one place, but your reducers are harder to compose since you might need info from other branches. You end up with large reducers or reducers that take additional arguments from higher up in the state.</p> </blockquote> <p>Find the balance between these two extremes, and you will master Redux.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/reactjs/redux/issues/1165\" target=\"_blank\">#1165: Where to put business logic / validation?</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/1171\" target=\"_blank\">#1171: Recommendations for best practices regarding action-creators, reducers, and selectors</a></li> <li><a href=\"http://stackoverflow.com/questions/35667249/accessing-redux-state-in-an-action-creator/35674575\" target=\"_blank\">Stack Overflow: Accessing Redux state in an action creator?</a></li> </ul> <h2 id=\"performance\">Performance</h2>  <h3 id=\"performance-scaling\">How well does Redux “scale” in terms of performance and architecture?</h3> <p>While there’s no single definitive answer to this, most of the time this should not be a concern in either case.</p> <p>The work done by Redux generally falls into a few areas: processing actions in middleware and reducers (including object duplication for immutable updates), notifying subscribers after actions are dispatched, and updating UI components based on the state changes. While it’s certainly <em>possible</em> for each of these to become a performance concern in sufficiently complex situations, there’s nothing inherently slow or inefficient about how Redux is implemented. In fact, React Redux in particular is heavily optimized to cut down on unnecessary re-renders.</p> <p>As for architecture, anecdotal evidence is that Redux works well for varying project and team sizes. Redux is currently used by hundreds of companies and thousands of developers, with several hundred thousand monthly installations from NPM. One developer reported:</p> <blockquote> <p>for scale, we have ~500 action types, ~400 reducer cases, ~150 components, 5 middlewares, ~200 actions, ~2300 tests</p> </blockquote> <h4 id=\"further-information\">Further information</h4> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/reactjs/redux/issues/310\" target=\"_blank\">#310: Who uses Redux?</a></li> <li><a href=\"https://www.reddit.com/r/reactjs/comments/47m9h5/whats_the_best_place_to_keep_the_initial_state/\" target=\"_blank\">Reddit: What's the best place to keep the initial state?</a></li> <li><a href=\"https://www.reddit.com/r/reactjs/comments/48k852/help_designing_redux_state_for_a_single_page/\" target=\"_blank\">Reddit: Help designing Redux state for a single page app</a></li> <li><a href=\"https://www.reddit.com/r/reactjs/comments/41wdqn/redux_performance_issues_with_a_large_state_object/\" target=\"_blank\">Reddit: Redux performance issues with a large state object?</a></li> <li><a href=\"https://www.reddit.com/r/javascript/comments/49box8/reactredux_for_ultra_large_scale_apps/\" target=\"_blank\">Reddit: React/Redux for Ultra Large Scale apps</a></li> <li><a href=\"https://twitter.com/NickPresta/status/684058236828266496\" target=\"_blank\">Twitter: Redux scaling</a></li> </ul>  <h3 id=\"performance-all-reducers\">Won’t calling “all my reducers” for each action be slow?</h3> <p>It’s important to note that a Redux store really only has a single reducer function. The store passes the current state and dispatched action to that one reducer function, and lets the reducer handle things appropriately.</p> <p>Obviously, trying to handle every possible action in a single function does not scale well, simply in terms of function size and readability, so it makes sense to split the actual work into separate functions that can be called by the top-level reducer. In particular, the common suggested pattern is to have a separate sub-reducer function that is responsible for managing updates to a particular slice of state at a specific key. The <code>combineReducers()</code> that comes with Redux is one of the many possible ways to achieve this. It’s also highly suggested to keep your store state as flat and as normalized as possible. Ultimately, though, you are in charge of organizing your reducer logic any way you want.</p> <p>However, even if you happen to have many different independent sub-reducers, and even have deeply nested state, reducer speed is unlikely to be a problem. JavaScript engines are capable of running a very large number of function calls per second, and most of your sub-reducers are probably just using a <code>switch</code> statement and returning the existing state by default in response to most actions.</p> <p>If you actually are concerned about reducer performance, you can use a utility such as <a href=\"https://github.com/omnidan/redux-ignore\" target=\"_blank\">redux-ignore</a> or <a href=\"https://github.com/chrisdavies/reduxr-scoped-reducer\" target=\"_blank\">reduxr-scoped-reducer</a> to ensure that only certain reducers listen to specific actions. You can also use <a href=\"https://github.com/michaelcontento/redux-log-slow-reducers\" target=\"_blank\">redux-log-slow-reducers</a> to do some performance benchmarking.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/reactjs/redux/issues/912\" target=\"_blank\">#912: Proposal: action filter utility</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/1303\" target=\"_blank\">#1303: Redux Performance with Large Store and frequent updates</a></li> <li><a href=\"http://stackoverflow.com/questions/35667775/state-in-redux-react-app-has-a-property-with-the-name-of-the-reducer/35674297\" target=\"_blank\">Stack Overflow: State in Redux app has the name of the reducer</a></li> <li><a href=\"http://stackoverflow.com/questions/34494866/how-does-redux-deals-with-deeply-nested-models/34495397\" target=\"_blank\">Stack Overflow: How does Redux deal with deeply nested models?</a></li> </ul>  <h3 id=\"performance-clone-state\">Do I have to deep-clone my state in a reducer? Isn’t copying my state going to be slow?</h3> <p>Immutably updating state generally means making shallow copies, not deep copies. Shallow copies are much faster than deep copies, because fewer objects and fields have to be copied, and it effectively comes down to moving some pointers around.</p> <p>However, you <em>do</em> need to create a copied and updated object for each level of nesting that is affected. Although that shouldn’t be particularly expensive, it’s another good reason why you should keep your state normalized and shallow if possible.</p> <blockquote> <p>Common Redux misconception: you need to deeply clone the state. Reality: if something inside doesn’t change, keep its reference the same!</p> </blockquote> <h4 id=\"further-information\">Further information</h4> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/reactjs/redux/issues/454\" target=\"_blank\">#454: Handling big states in reducer</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/758\" target=\"_blank\">#758: Why can't state be mutated?</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/994\" target=\"_blank\">#994: How to cut the boilerplate when updating nested entities?</a></li> <li><a href=\"https://twitter.com/dan_abramov/status/688087202312491008\" target=\"_blank\">Twitter: common misconception - deep cloning</a></li> <li><a href=\"http://www.zsoltnagy.eu/cloning-objects-in-javascript/\" target=\"_blank\">Cloning Objects in JavaScript</a></li> </ul>  <h3 id=\"performance-update-events\">How can I reduce the number of store update events?</h3> <p>Redux notifies subscribers after each successfully dispatched action (i.e. an action reached the store and was handled by reducers). In some cases, it may be useful to cut down on the number of times subscribers are called, particularly if an action creator dispatches multiple distinct actions in a row. There are a number of community add-ons that provide batching of subscription notifications when multiple actions are dispatched, such as <a href=\"https://github.com/tappleby/redux-batched-subscribe\" target=\"_blank\">redux-batched-subscribe</a> and <a href=\"https://github.com/tshelburne/redux-batched-actions\" target=\"_blank\">redux-batched-actions</a>.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/reactjs/redux/issues/125\" target=\"_blank\">#125: Strategy for avoiding cascading renders</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/542\" target=\"_blank\">#542: Idea: batching actions</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/911\" target=\"_blank\">#911: Batching actions</a></li> <li><a href=\"https://github.com/reactjs/react-redux/issues/263\" target=\"_blank\">React Redux #263: Huge performance issue when dispatching hundreds of actions</a></li> </ul>  <h3 id=\"performance-state-memory\">Will having “one state tree” cause memory problems? Will dispatching many actions take up memory?</h3> <p>First, in terms of raw memory usage, Redux is no different than any other JavaScript library. The only difference is that all the various object references are nested together into one tree, instead of maybe saved in various independent model instances such as in Backbone. Second, a typical Redux app would probably have somewhat <em>less</em> memory usage than an equivalent Backbone app because Redux encourages use of plain JavaScript objects and arrays rather than creating instances of Models and Collections. Finally, Redux only holds onto a single state tree reference at a time. Objects that are no longer referenced in that tree will be garbage collected, as usual.</p> <p>Redux does not store a history of actions itself. However, the Redux DevTools do store actions so they can be replayed, but those are generally only enabled during development, and not used in production.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Documentation</strong></p> <ul> <li><a href=\"#\">Docs: Async Actions</a></li> </ul> <p><strong>Discussions</strong></p> <ul> <li><a href=\"http://stackoverflow.com/questions/35627553/is-there-any-way-to-commit-the-state-in-redux-to-free-memory/35634004\" target=\"_blank\">Stack Overflow: Is there any way to \"commit\" the state in Redux to free memory?</a></li> <li><a href=\"https://www.reddit.com/r/reactjs/comments/47m9h5/whats_the_best_place_to_keep_the_initial_state/\" target=\"_blank\">Reddit: What's the best place to keep initial state?</a></li> </ul> <h2 id=\"react-redux\">React Redux</h2>  <h3 id=\"react-not-rerendering\">Why isn’t my component re-rendering, or my mapStateToProps running?</h3> <p>Accidentally mutating or modifying your state directly is by far the most common reason why components do not re-render after an action has been dispatched. Redux expects that your reducers will update their state “immutably”, which effectively means always making copies of your data, and applying your changes to the copies. If you return the same object from a reducer, Redux assumes that nothing has been changed, even if you made changes to its contents. Similarly, React Redux tries to improve performance by doing shallow equality reference checks on incoming props in <code>shouldComponentUpdate</code>, and if all references are the same, returns <code>false</code> to skip actually updating your original component.</p> <p>It’s important to remember that whenever you update a nested value, you must also return new copies of anything above it in your state tree. If you have <code>state.a.b.c.d</code>, and you want to make an update to <code>d</code>, you would also need to return new copies of <code>c</code>, <code>b</code>, <code>a</code>, and <code>state</code>. This <a href=\"http://arqex.com/wp-content/uploads/2015/02/trees.png\" target=\"_blank\">state tree mutation diagram</a> demonstrates how a change deep in a tree requires changes all the way up.</p> <p>Note that “updating data immutably” does <em>not</em> mean that you must use <a href=\"https://facebook.github.io/immutable-js/\" target=\"_blank\">Immutable.js</a>, although that is certainly an option. You can do immutable updates to plain JS objects and arrays using several different approaches:</p> <ul> <li>Copying objects using functions like <code>Object.assign()</code> or <code>_.extend()</code>, and array functions such as <code>slice()</code> and <code>concat()</code>\n</li> <li>The array spread operator in ES6, and the similar object spread operator that is proposed for a future version of JavaScript</li> <li>Utility libraries that wrap immutable update logic into simpler functions</li> </ul> <h4 id=\"further-information\">Further information</h4> <p><strong>Documentation</strong></p> <ul> <li><a href=\"troubleshooting\">Troubleshooting</a></li> <li><a href=\"https://github.com/reactjs/react-redux/blob/master/docs/troubleshooting.md\" target=\"_blank\">React Redux: Troubleshooting</a></li> <li><a href=\"recipes/usingobjectspreadoperator\">Recipes: Using the Object Spread Operator</a></li> </ul> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/reactjs/redux/issues/1262\" target=\"_blank\">#1262: Immutable data + bad performance</a></li> <li><a href=\"https://github.com/reactjs/react-redux/issues/235\" target=\"_blank\">React Redux #235: Predicate function for updating component</a></li> <li><a href=\"https://github.com/reactjs/react-redux/issues/291\" target=\"_blank\">React Redux #291: Should mapStateToProps be called every time an action is dispatched?</a></li> <li><a href=\"http://stackoverflow.com/questions/35592078/cleaner-shorter-way-to-update-nested-state-in-redux\" target=\"_blank\">Stack Overflow: Cleaner/shorter way to update nested state in Redux?</a></li> <li><a href=\"https://gist.github.com/amcdnl/7d93c0c67a9a44fe5761#gistcomment-1706579\" target=\"_blank\">Gist: state mutations</a></li> <li><a href=\"http://reactkungfu.com/2015/08/pros-and-cons-of-using-immutability-with-react-js/\" target=\"_blank\">Pros and Cons of Using Immutability with React</a></li> </ul>  <h3 id=\"react-rendering-too-often\">Why is my component re-rendering too often?</h3> <p>React Redux implements several optimizations to ensure your actual component only re-renders when actually necessary. One of those is a shallow equality check on the combined props object generated by the <code>mapStateToProps</code> and <code>mapDispatchToProps</code> arguments passed to <code>connect</code>. Unfortunately, shallow equality does not help in cases where new array or object instances are created each time <code>mapStateToProps</code> is called. A typical example might be mapping over an array of IDs and returning the matching object references, such as:</p> <pre data-language=\"js\">const mapStateToProps = (state) =&gt; {\n  return {\n    objects: state.objectIds.map(id =&gt; state.objects[id])\n  }\n}\n</pre> <p>Even though the array might contain the exact same object references each time, the array itself is a different reference, so the shallow equality check fails and React Redux would re-render the wrapped component.</p> <p>The extra re-renders could be resolved by saving the array of objects into the state using a reducer, caching the mapped array using <a href=\"https://github.com/reactjs/reselect\" target=\"_blank\">Reselect</a>, or implementing <code>shouldComponentUpdate</code> in the component by hand and doing a more in-depth props comparison using a function such as <code>_.isEqual</code>. Be careful to not make your custom <code>shouldComponentUpdate()</code> more expensive than the rendering itself! Always use a profiler to check your assumptions about performance.</p> <p>For non-connected components, you may want to check what props are being passed in. A common issue is having a parent component re-bind a callback inside its render function, like <code><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Child</span> <span class=\"token attr-name\">onClick</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span>{this.handleClick.bind(this)}</span> <span class=\"token punctuation\">/&gt;</span></span></code>. That creates a new function reference every time the parent re-renders. It’s generally good practice to only bind callbacks once in the parent component’s constructor.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Discussions</strong></p> <ul> <li><a href=\"http://stackoverflow.com/questions/34782249/can-a-react-redux-app-really-scale-as-well-as-say-backbone-even-with-reselect\" target=\"_blank\">Stack Overflow: Can a React Redux app scale as well as Backbone?</a></li> <li><a href=\"https://medium.com/@esamatti/react-js-pure-render-performance-anti-pattern-fb88c101332f\" target=\"_blank\">React.js pure render performance anti-pattern</a></li> <li><a href=\"http://benchling.engineering/deep-dive-react-perf-debugging/\" target=\"_blank\">A Deep Dive into React Perf Debugging</a></li> </ul>  <h3 id=\"react-mapstate-speed\">How can I speed up my <code>mapStateToProps</code>?</h3> <p>While React Redux does work to minimize the number of times that your <code>mapStateToProps</code> function is called, it’s still a good idea to ensure that your <code>mapStateToProps</code> runs quickly and also minimizes the amount of work it does. The common recommended approach is to create memoized “selector” functions using <a href=\"https://github.com/reactjs/reselect\" target=\"_blank\">Reselect</a>. These selectors can be combined and composed together, and selectors later in a pipeline will only run if their inputs have changed. This means you can create selectors that do things like filtering or sorting, and ensure that the real work only happens if needed.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Documentation</strong></p> <ul> <li><a href=\"recipes/computingderiveddata\">Recipes: Computed Derived Data</a></li> </ul> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/reactjs/redux/issues/815\" target=\"_blank\">#815: Working with Data Structures</a></li> <li><a href=\"https://github.com/reactjs/reselect/issues/47\" target=\"_blank\">Reselect #47: Memoizing Hierarchical Selectors</a></li> </ul>  <h3 id=\"react-props-dispatch\">Why don’t I have <code>this.props.dispatch</code> available in my connected component?</h3> <p>The <code>connect()</code> function takes two primary arguments, both optional. The first, <code>mapStateToProps</code>, is a function you provide to pull data from the store when it changes, and pass those values as props to your component. The second, <code>mapDispatchToProps</code>, is a function you provide to make use of the store’s <code>dispatch</code> function, usually by creating pre-bound versions of action creators that will automatically dispatch their actions as soon as they are called.</p> <p>If you do not provide your own <code>mapDispatchToProps</code> function when calling <code>connect()</code>, React Redux will provide a default version, which simply returns the <code>dispatch</code> function as a prop. That means that if you <em>do</em> provide your own function, <code>dispatch</code> is <em>not</em> automatically provided. If you still want it available as a prop, you need to explicitly return it yourself in your <code>mapDispatchToProps</code> implementation.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Documentation</strong></p> <ul> <li><a href=\"https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options\" target=\"_blank\">React Redux API: connect()</a></li> </ul> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://github.com/reactjs/react-redux/issues/89\" target=\"_blank\">React Redux #89: can i wrap multi actionCreators into one props with name?</a></li> <li><a href=\"https://github.com/reactjs/react-redux/issues/145\" target=\"_blank\">React Redux #145: consider always passing down dispatch regardless of what mapDispatchToProps does</a></li> <li><a href=\"https://github.com/reactjs/react-redux/issues/255\" target=\"_blank\">React Redux #255: this.props.dispatch is undefined if using mapDispatchToProps</a></li> <li><a href=\"#\" target=\"_blank\">Stack Overflow: How to get simple dispatch from this.props using connect w/ Redux?</a></li> </ul>  <h3 id=\"react-multiple-components\">Should I only connect my top component, or can I connect multiple components in my tree?</h3> <p>Early Redux documentation advised that you should only have a few connected components near the top of your component tree. However, time and experience has shown that that generally requires a few components to know too much about the data requirements of all their descendants, and forces them to pass down a confusing number of props.</p> <p>The current suggested best practice is to categorize your components as “presentational” or “container” components, and extract a connected container component wherever it makes sense:</p> <blockquote> <p>Emphasizing “one container component at the top” in Redux examples was a mistake. Don’t take this as a maxim. Try to keep your presentation components separate. Create container components by connecting them when it’s convenient. Whenever you feel like you’re duplicating code in parent components to provide data for same kinds of children, time to extract a container. Generally as soon as you feel a parent knows too much about “personal” data or actions of its children, time to extract a container.</p> </blockquote> <p>In general, try to find a balance between understandable data flow and areas of responsibility with your components.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Documentation</strong></p> <ul> <li><a href=\"basics/usagewithreact\">Basics: Usage with React</a></li> </ul> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\" target=\"_blank\">Presentational and Container Components</a></li> <li><a href=\"https://twitter.com/dan_abramov/status/668585589609005056\" target=\"_blank\">Twitter: emphasizing “one container” was a mistake</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/419\" target=\"_blank\">#419: Recommended usage of connect</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/756\" target=\"_blank\">#756: container vs component?</a></li> <li><a href=\"https://github.com/reactjs/redux/issues/1176\" target=\"_blank\">#1176: Redux+React with only stateless components</a></li> <li><a href=\"http://stackoverflow.com/questions/34992247/can-a-dumb-component-use-render-redux-container-component\" target=\"_blank\">Stack Overflow: can a dumb component use a Redux container?</a></li> </ul> <h2 id=\"miscellaneous\">Miscellaneous</h2>  <h3 id=\"miscellaneous-real-projects\">Are there any larger, “real” Redux projects?</h3> <p>The Redux “examples” folder has several sample projects of varying complexity, including a “real-world” example. While many companies are using Redux, most of their applications are proprietary and not available. A large number of Redux-related projects can be found on Github, such as <a href=\"https://github.com/andrewngu/sound-redux\" target=\"_blank\">SoundRedux</a>.</p> <h4 id=\"further-information\">Further information</h4> <p><strong>Documentation</strong></p> <ul> <li><a href=\"introduction/examples\">Introduction: Examples</a></li> </ul> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://www.reddit.com/r/reactjs/comments/496db2/large_open_source_reactredux_projects/\" target=\"_blank\">Reddit: Large open source react/redux projects?</a></li> <li><a href=\"https://news.ycombinator.com/item?id=10710240\" target=\"_blank\">HN: Is there any huge web application built using Redux?</a></li> </ul>  <h3 id=\"miscellaneous-authentication\">How can I implement authentication in Redux?</h3> <p>Authentication is essential to any real application. When going about authentication you must keep in mind that nothing changes with how you should organize your application and you should implement authentication in the same way you would any other feature. It is relatively straightforward:</p> <ol> <li>\n<p>Create action constants for <code>LOGIN_SUCCESS</code>, <code>LOGIN_FAILURE</code>, etc.</p> </li> <li>\n<p>Create action creators that take in credentials, a flag that signifies whether authentication succeeded, a token, or an error message as the payload.</p> </li> <li>\n<p>Create an async action creator with Redux Thunk middleware or any middleware you see fit to fire a network request to an API that returns a token if the credentials are valid. Then save the token in the local storage or show a response to the user if it failed. You can perform these side effects from the action creators you wrote in the previous step.</p> </li> <li>\n<p>Create a reducer that returns the next state for each possible authentication case (<code>LOGIN_SUCCESS</code>, <code>LOGIN_FAILURE</code>, etc).</p> </li> </ol> <h4 id=\"further-information\">Further information</h4> <p><strong>Discussions</strong></p> <ul> <li><a href=\"https://auth0.com/blog/2016/01/04/secure-your-react-and-redux-app-with-jwt-authentication/\" target=\"_blank\">Authentication with JWT by Auth0</a></li> <li><a href=\"https://medium.com/@MattiaManzati/tips-to-handle-authentication-in-redux-2-introducing-redux-saga-130d6872fbe7\" target=\"_blank\">Tips to Handle Authentication in Redux</a></li> <li><a href=\"https://github.com/joshgeller/react-redux-jwt-auth-example\" target=\"_blank\">react-redux-jwt-auth-example</a></li> <li><a href=\"https://github.com/lynndylanhurley/redux-auth\" target=\"_blank\">redux-auth</a></li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; 2015&ndash;2016 Dan Abramov<br>Licensed under the MIT License.<br>\n    <a href=\"http://redux.js.org/docs/FAQ.html\" class=\"_attribution-link\">http://redux.js.org/docs/FAQ.html</a>\n  </p>\n</div>\n"}
{"commonjs":"<h1>CommonJS Notes</h1> <ul class=\"index mono\"> <li class=\"hbox\">\n<a href=\"#intro\">Introduction</a>\n</li> <li class=\"hbox\">\n<a href=\"#manualconversion\">Manual Conversion</a>\n</li> <li class=\"hbox\">\n<a href=\"#autoconversion\">Conversion Tool</a>\n</li> <li class=\"hbox\">\n<a href=\"#exports\">Setting Exported Value</a>\n</li> <li class=\"hbox\">\n<a href=\"#altsyntax\">Alternative Syntax</a>\n</li> <li class=\"hbox\">\n<a href=\"#packages\">Loading Modules from CommonJS Packages</a>\n</li> <li class=\"hbox\">\n<a href=\"#optimize\">Optimization Tool</a>\n</li> </ul>   <h2 id=\"intro\">Introduction</h2> <p><a href=\"http://www.commonjs.org/\">CommonJS</a> defines <a href=\"http://wiki.commonjs.org/wiki/Modules/1.1.1\">a module format</a>. Unfortunately, it was defined without giving browsers equal footing to other JavaScript environments. Because of that, there are CommonJS spec proposals for <a href=\"http://wiki.commonjs.org/wiki/Modules/Transport\">Transport formats</a> and an <a href=\"http://wiki.commonjs.org/wiki/Modules/Async/A\">asynchronous require</a>.</p> <p>RequireJS tries to keep with the spirit of CommonJS, with using string names to refer to dependencies, and to avoid modules defining global objects, but still allow coding a module format that works well natively in the browser. RequireJS implements the <a href=\"http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\">Asynchronous Module Definition</a> (formerly Transport/C) proposal.</p> <p>If you have modules that are in the traditional CommonJS module format, then you can easily convert them to work with RequireJS. Not all modules will convert cleanly to the new format. Types of modules that may not convert well:</p> <ul> <li>Modules that use conditional code to do a require call, like if(someCondition) require('a1') else require('a2');</li> <li>Some types of circular dependencies.</li> </ul>  <h2 id=\"manualconversion\">Manual Conversion</h2> <p>If you just have a few modules to convert, then all you need to do is wrap the module in this code:</p> <pre>define(function(require, exports, module) {\n    //Put traditional CommonJS module content here\n});\n</pre> <p><strong>IMPORTANT</strong>: The function arguments should always be listed as <strong>require, exports, module</strong>, with those exact names and in that exact order, otherwise chaos will ensue. You can leave off exports and module from the list, but if they are needed, they need to be specified in the exact order illustrated here.</p>   <h2 id=\"autoconversion\">Conversion Tool</h2> <p>If you have many modules to convert, the <a href=\"https://github.com/requirejs/r.js\">r.js project</a> has a converter tool built into the r.js file. Give it the path to the directory you want to convert and an output directory:</p> <pre>node r.js -convert path/to/commonjs/modules/ path/to/output\n</pre> <p>There are a small number of CommonJS modules do not work well as define()-wrapped modules. See the <a href=\"https://github.com/requirejs/r.js\">r.js README</a></p> for more information.   <h2 id=\"exports\">Setting Exported Value</h2> <p>There are some CommonJS systems, mainly Node, that allow setting the exported value by assigning the exported value as module.exports. That idiom is supported by RequireJS, but there is another, easier way -- just return the value from the function passed to <strong>define</strong>:</p> <pre>define(function (require) {\n    var foo = require('foo');\n\n    //Define this module as exporting a function\n    return function () {\n        foo.doSomething();\n    };\n});\n</pre> <p>With this approach, then you normally do not need the exports and module function arguments, so you can leave them off the module definition.</p>   <h2 id=\"altsyntax\">Alternative Syntax</h2> <p>Instead of using require() to get dependencies inside the function passed to define(), you can also specify them via a dependency array argument to define(). The order of the names in the dependency array match the order of arguments passed to the definition function passed to define(). So the above example that uses the module <strong>foo</strong>:</p> <pre>define(['foo'], function (foo) {\n    return function () {\n        foo.doSomething();\n    };\n});\n</pre> <p>See the <a href=\"index\">API docs</a> for more information on that syntax.</p>   <h2 id=\"packages\">Loading Modules from CommonJS Packages</h2> <p>Modules in CommonJS packages can be loaded by RequireJS by setting up the RequireJS configuration to know about the location and package attributes. See the <a href=\"api#packages\">packages API section</a> for more information.</p>   <h2 id=\"optimize\">Optimization Tool</h2> <p>RequireJS has an optimization tool that can combine module definitions together into optimized bundles for browser delivery. It works as a command-line tool that you use as part of code deployment. See the <a href=\"optimization\">optimization docs</a> for more information.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; jQuery Foundation and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://requirejs.org/docs/commonjs.html\" class=\"_attribution-link\">https://requirejs.org/docs/commonjs.html</a>\n  </p>\n</div>\n","dojo":"<h1>How to use RequireJS with Dojo</h1> <p>As of Dojo 1.8, Dojo has converted their modules to AMD modules. However, Dojo uses some loader plugins, and the loader plugin APIs are still in draft mode for AMD. So while some modules from Dojo can be used with RequireJS, it will be difficult to use all of Dojo. It is best to use Dojo's AMD loader until <a href=\"http://bugs.dojotoolkit.org/ticket/15616\">ticket 15616</a> has been resolved.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; jQuery Foundation and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://requirejs.org/docs/dojo.html\" class=\"_attribution-link\">https://requirejs.org/docs/dojo.html</a>\n  </p>\n</div>\n","optimization":"<h1>RequireJS Optimizer</h1> <ul class=\"index mono\"> <li class=\"hbox\">\n<a href=\"#requirements\">Requirements</a>\n</li> <li class=\"hbox\">\n<a href=\"#download\">Download</a>\n</li> <li class=\"hbox\">\n<a href=\"#setup\">Example setup</a>\n</li> <li class=\"hbox\">\n<a href=\"#basics\">Basics</a>\n</li> <li class=\"hbox\">\n<a href=\"#onejs\">Optimizing one JavaScript file</a>\n</li> <li class=\"hbox\">\n<a href=\"#shallow\">Shallow exclusions for fast development</a>\n</li> <li class=\"hbox\">\n<a href=\"#empty\">empty: paths for network/CDN resources</a>\n</li> <li class=\"hbox\">\n<a href=\"#onecss\">Optimizing one CSS file</a>\n</li> <li class=\"hbox\">\n<a href=\"#wholeproject\">Optimizing a whole project</a>\n</li> <li class=\"hbox\">\n<a href=\"#wholemultipage\">Optimizing a multi-page project</a>\n</li> <li class=\"hbox\">\n<a href=\"#turbo\">Turbo options</a>\n</li> <li class=\"hbox\">\n<a href=\"#hasjs\">Integration with has.js</a>\n</li> <li class=\"hbox\">\n<a href=\"#sourcemaps\">Source maps</a>\n</li> <li class=\"hbox\">\n<a href=\"#options\">All configuration options</a>\n</li> <li class=\"hbox\">\n<a href=\"#deployment\">Deployment techniques</a>\n</li> <li class=\"hbox\">\n<a href=\"#pitfalls\">Common pitfalls</a>\n</li> </ul> <p>RequireJS has an optimization tool that does the following</p> <ul class=\"serif\"> <li>Combines related scripts together into build layers and minifies them via <a href=\"https://github.com/mishoo/UglifyJS\">UglifyJS</a> (the default) or <a href=\"https://developers.google.com/closure/compiler/\">Closure Compiler</a> (an option when using Java).</li> <li>Optimizes CSS by inlining CSS files referenced by @import and removing comments.</li> </ul> <p>The optimizer is part of the <a href=\"https://github.com/requirejs/r.js\">r.js adapter for Node and Nashorn</a>, and it is designed to be run as part of a build or packaging step after you are done with development and are ready to deploy the code for your users.</p> <p>The optimizer will only combine modules that are specified in arrays of string literals that are passed to top-level require and define calls, or the require('name') string literal calls in a <a href=\"whyamd#sugar\">simplified CommonJS wrapping</a>. So, it will not find modules that are loaded via a variable name:</p> <pre>var mods = someCondition ? ['a', 'b'] : ['c', 'd'];\nrequire(mods);</pre> <p>but 'a' and 'b' will be included if specified like so:</p> <pre>require(['a', 'b']);</pre> <p>or:</p> <pre>define(['a', 'b'], function (a, b) {});</pre> <p>This behavior allows dynamic loading of modules even after optimization. You can always explicitly add modules that are not found via the optimizer's static analysis by using the <strong>include</strong> option.</p>   <h2 id=\"requirements\"> Requirements  </h2> <p>The optimizer can be run using Node, Java with Rhino or Nashorn, or in the browser. The requirements for each option:</p>\n\n<ul> <li>\n<strong>Node:</strong> (preferred) <a href=\"http://nodejs.org\">Node</a> 0.4.0 or later.</li> <li>\n<strong>Java:</strong> <a href=\"http://java.com/\">Java 1.6</a> or later.</li> <li>\n<strong>Browser:</strong> as of 2.1.2, the optimizer can run in a web browser that has <a href=\"http://dev.opera.com/articles/view/javascript-array-extras-in-detail/\">array extras</a>. While the optimizer options are the same as shown below, it is called via JavaScript instead of command line options. It is also only good for generating optimized single files, not a directory optimization. See <a href=\"https://github.com/requirejs/r.js/blob/master/tests/browser/r.html\">the browser example</a>. This option is really only useful for providing web-based custom builds of your library.</li> </ul> <p>For command line use, Node is the preferred execution environment. The optimizer runs <strong>much faster</strong> with Node.</p> <p>All the example commands in this page assume Node usage, and running on a Linux/OS X command line. See the <a href=\"https://github.com/requirejs/r.js\">r.js README</a> for how to run it in Java.</p>   <h2 id=\"download\">Download</h2> <p>1) You can download the tool on <a href=\"https://requirejs.org/docs/download.html#rjs\">the download page</a>.</p> <p>2) If you are using Node with NPM, you can install r.js globally as part of the \"requirejs\" package in NPM:</p> <pre>&gt; npm install -g requirejs\n&gt; r.js -o app.build.js\n</pre> <p>If on Windows, you may need to type <code>r.js.cmd</code> instead of <code>r.js</code>. Or, you can use <a href=\"http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/doskey.mspx?mfr=true\">DOSKEY</a>:</p> <pre>DOSKEY r.js=r.js.cmd $*</pre> <p>If you want to install requirejs locally in a project as an npm package, instead of globally:</p> <pre>&gt; npm install requirejs\n</pre> <p>With this local install, you can run the optimizer by running the <code>r.js</code> or <code>r.js.cmd</code> file found in the project's <code>node_modules/.bin</code> directory. </p>\n<p>With the local install, you can also <a href=\"node#optimizer\">use the optimizer via a function call</a> inside a node program.</p> <p>The rest of this page assumes that r.js is just downloaded manually from the download page. It is normally the clearest, most portable way to use the optimizer.</p>   <h2 id=\"setup\">Example setup</h2> <p>The examples in this page will assume you downloaded and saved r.js in a directory that is a sibling to your project directory. The optimizer that is part of r.js can live anywhere you want, but you will likely need to adjust the paths accordingly in these examples.</p> <p>Example setup:</p> <ul> <li>appdirectory <ul> <li>main.html</li> <li>css <ul> <li>common.css</li> <li>main.css</li> </ul>\n</li> <li>scripts <ul> <li>require.js</li> <li>main.js</li> <li>one.js</li> <li>two.js</li> <li>three.js</li> </ul>\n</li> </ul>\n</li> <li>r.js (The r.js optimizer from <a href=\"https://requirejs.org/docs/download.html#rjs\">download page</a>)</li> </ul> <p>main.html has script tags for require.js and loads main.js via a require call, like so:</p> <pre>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;My App&lt;/title&gt;\n        &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/main.css\"&gt;\n        &lt;script data-main=\"scripts/main\" src=\"scripts/require.js\"&gt;&lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;My App&lt;/h1&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</pre> <p>main.js loads one.js, two.js and three.js via a require call:</p> <pre>require([\"one\", \"two\", \"three\"], function (one, two, three) {\n});\n</pre> <p>main.css has content like the following:</p> <pre>@import url(\"common.css\");\n\n.app {\n    background: transparent url(../../img/app.png);\n}\n</pre>   <h2 id=\"basics\"> Basics  </h2> <p><strong id=\"commandargs\">Command line arguments are interchangeable with a build profile properties</strong></p> <p>You can either specify options on the command line:</p> <pre>node r.js -o baseUrl=. paths.jquery=some/other/jquery name=main out=main-built.js\n</pre> <p>or in a build profile. In a <strong>build.js</strong>, the same command line arguments can be specified like so:</p> <pre>({\n    baseUrl: \".\",\n    paths: {\n        jquery: \"some/other/jquery\"\n    },\n    name: \"main\",\n    out: \"main-built.js\"\n})\n</pre> <p>then just pass the build profile's file name to the optimizer:</p> <pre>node r.js -o build.js\n</pre> <p>Command line arguments take precedence over build profile settings, and you can mix them together:</p> <pre>node r.js -o build.js optimize=none\n</pre> <p>There is a <strong>limitation</strong> on the command line argument syntax. Dots are viewed as object property separators, to allow something like <code>paths.jquery=lib/jquery</code> to be transformed to the following in the optimizer:</p> <pre>paths: {\n    jquery: 'lib/jquery'\n}\n</pre> <p>but this means you cannot set the value for a paths property of \"core/jquery.tabs\" to a value. This would not work: <code>paths.core/jquery.tabs=empty:</code>, since it would result in this incorrect structure:</p> <pre>paths: {\n    'core/jquery': {\n        tabs: 'empty:'\n    }\n}\n</pre> <p>If you need to set a path like the \"core/jquery.tabs\" one, use a build.js file with the build options specified as a JavaScript object instead of using command line arguments.</p> <p>For a list of all options, see <a href=\"#options\">all configuration options</a>.</p> <p><strong id=\"optionpaths\">Relative path resolution rules:</strong>:</p> <p>In general, if it is a path, it is relative to the build.js file used to hold the build options, or if just using command line arguments, relative to the current working directory. Example of properties that are file paths: <strong>appDir</strong>, <strong>dir</strong>, <strong>mainConfigFile</strong>, <strong>out</strong>, <strong>wrap.startFile</strong>, <strong>wrap.endFile</strong>.</p> <p>For <strong>baseUrl</strong>, it is relative to <strong>appDir</strong>. If no appDir, then baseUrl is relative to the build.js file, or if just using command line arguments, the current working directory.</p> <p>For <strong>paths</strong> and <strong>packages</strong>, they are relative to <strong>baseUrl</strong>, just as they are for require.js.</p> <p>For properties that are module IDs, they should be module IDs, and not file paths. Examples are <strong>name</strong>, <strong>include</strong>, <strong>exclude</strong>, <strong>excludeShallow</strong>, <strong>deps</strong>. </p>\n<p><strong id=\"mainConfigFile\">Config settings in your main JS module that is loaded in the browser at runtime <strong>are not read by default</strong> by the optimizer</strong></p> <p>This is because the config settings for a build can be very different, with multiple optimization targets. So a separate set of config options need to be specified for the optimizer.</p> <p>In version 1.0.5+ of the optimizer, the <strong><a href=\"https://github.com/requirejs/r.js/blob/master/build/example.build.js#L27\">mainConfigFile</a></strong> option can be used to specify the location of the runtime config. If specified with the path to your main JS file, the first <code>requirejs({}), requirejs.config({}), require({}), or require.config({})</code> found in that file will be parsed out and used as part of the configuration options passed to the optimizer:</p> <pre>mainConfigFile: 'path/to/main.js'\n</pre> <p>The precedence for config: command line, build profile, mainConfigFile. In other words, the mainConfigFile configuration has the lowest priority.</p>   <h2 id=\"onejs\"> Optimizing one JavaScript file  </h2> <p>Use the above example setup, if you just wanted to optimize main.js, you could use this command, from inside the <strong>appdirectory/scripts</strong> directory:</p> <pre>node ../../r.js -o name=main out=main-built.js baseUrl=.\n</pre> <p>This will create a file called <strong>appdirectory/scripts/main-built.js</strong> that will include the contents of main.js, one.js, two.js and three.js.</p> <p>Normally you should <strong>not</strong> save optimized files with your pristine project source. Normally you would save them to a copy of your project, but to make this example easier it is saved with the source. Change the <strong>out=</strong> option to any directory you like, that has a copy of your source. Then, you can change the main-built.js file name to just main.js so the HTML page will load the optimized version of the file.</p> <p>If you want to include require.js with the main.js source, you can use this kind of command:</p> <pre>node ../../r.js -o baseUrl=. paths.requireLib=../../require name=main include=requireLib out=main-built.js\n</pre> <p>Since \"require\" is a reserved dependency name, you create a \"requireLib\" dependency and map it to the require.js file.</p> <p>Once that optimization is done, you can change the script tag to reference \"main-built.js\" instead of \"require.js\", and your optimized project will only need to make one script request.</p> <p>If you want to wrap your built file so it can be used in pages that do not have an AMD loader like RequireJS, see the <a href=\"https://requirejs.org/docs/faq-optimization.html\">Optimization FAQ</a>.</p>   <h2 id=\"shallow\">Shallow exclusions for fast development </h2> <p>You can use the <a href=\"#onejs\">one JavaScript file optimization</a> approach to make your development experience faster. By optimizing all the modules in your project into one file, except the one you are currently developing, you can reload your project quickly in the browser, but still give you the option of fine grained debugging in a module.</p> <p>You can do this by using the <strong>excludeShallow</strong> option. Using the <a href=\"#example\">example setup</a> above, assume you are currently building out or debugging two.js. You could use this optimization command:</p> <pre>node ../../r.js -o name=main excludeShallow=two out=main-built.js baseUrl=.\n</pre> <p>If you do not want the main-build.js file minified, pass <strong>optimize=none</strong> in the command above.</p> <p>Then configure the HTML page to load the main-built.js file instead of main.js by configuring the path used for \"main\" to be \"main-built\":</p> <pre>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;My App&lt;/title&gt;\n        &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/main.css\"&gt;\n        &lt;script src=\"scripts/require.js\"&gt;&lt;/script&gt;\n        &lt;script&gt;\n            require.config({\n                paths: {\n                    //Comment out this line to go back to loading\n                    //the non-optimized main.js source file.\n                    \"main\": \"main-built\"\n                }\n            });\n            require([\"main\"]);\n        &lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;My App&lt;/h1&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</pre> <p>Now, when this page is loaded, the require() for \"main\" will load the main-built.js file. Since excludeShallow told it just to exclude two.js, two.js will still be loaded as a separate file, allowing you to see it as a separate file in the browser's debugger, so you can set breakpoints and better track its individual changes.</p>   <h2 id=\"empty\">empty: paths for network/CDN resources</h2> <p>You may have a script you want to load from a <a href=\"http://en.wikipedia.org/wiki/Content_delivery_network\">Content Delivery Network (CDN)</a> or any other server on a different domain.</p> <p>The optimizer cannot load network resources, so if you want it included in the build, be sure to create a <a href=\"api#config-paths\">paths config</a> to map the file to a module name. Then, for running the optimizer, download the CDN script and pass a paths config to the optimizer that maps the module name to the local file path.</p> <p>However, it is more likely that you do not want to include that resource in the build. If the script does not have any dependencies, or you do not want to include its dependencies or will be including them in another way, then you can use the special <strong>'empty:' scheme</strong> in the paths config to just skip the file when doing an optimization.</p> <p>In your main.js file, create a paths config that gives the script a module name. This can be done even if the script does not define a module via a call to define(). paths config are just used to map short module/script IDs to an URL. This allows you to use a different paths config for the optimization. In main.js:</p> <pre>requirejs.config({\n    paths: {\n        'jquery': 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min'\n    }\n});\n\nrequire(['jquery'], function ($) {\n});\n</pre> <p>Then, when running the optimizer, use 'empty:' for the paths config:</p> <pre>node ../../r.js -o name=main out=main-built.js baseUrl=. paths.jquery=empty:\n</pre> <p>Or, in a <a href=\"#wholeproject\">build profile</a>:</p> <pre>({\n    baseUrl: \".\",\n    name: \"main\",\n    out: \"main-built.js\",\n    paths: {\n        jquery: \"empty:\"\n    }\n})\n</pre>   <h2 id=\"onecss\">Optimizing one CSS file</h2> <p>Use the above example setup, if you just wanted to optimize main.css, you could use this command, from inside the <strong>appdirectory/css</strong> directory:</p> <pre>node ../../r.js -o cssIn=main.css out=main-built.css\n</pre> <p>This will create a file called <strong>appdirectory/css/main-build.css</strong> that will include the contents of main.css, have the url() paths properly adjusted, and have comments removed.</p> <p>See the notes for the <a href=\"#onejs\">Optimizing one JavaScript file</a> about avoiding saving optimized files in your pristine source tree. It is only done here to make the example simpler.</p> <span class=\"note\">Note: The url() path fixing will always fix the paths relative to the <strong>cssIn</strong> build option path, not the <strong>out</strong> build option.</span>   <h2 id=\"wholeproject\">Optimizing a whole project</h2> <p>The optimizer can take care of optimizing all the CSS and JS files in your project by using a build profile.</p> <p>Create a build profile, call it app.build.js, and put it in the <strong>scripts</strong> directory. The app.build.js file can live anywhere, but just be sure to adjust the paths accordingly in the example below -- all paths will be relative to where the app.build.js is located. Example app.build.js:</p> <pre>({\n    appDir: \"../\",\n    baseUrl: \"scripts\",\n    dir: \"../../appdirectory-build\",\n    modules: [\n        {\n            name: \"main\"\n        }\n    ]\n})\n</pre> <p>This build profile tells RequireJS to copy all of <strong>appdirectory</strong> to a sibling directory called <strong>appdirectory-build</strong> and apply all the optimizations in the <strong>appdirectory-build</strong> directory. It is strongly suggested you use a different output directory than the source directory -- otherwise bad things will likely happen as the optimizer overwrites your source.</p> <p>RequireJS will use <strong>baseUrl</strong> to resolve the paths for any module names. The <strong>baseUrl</strong> should be relative to <strong>appDir</strong>.</p> <p>In the <strong>modules</strong> array, specify the module names that you want to optimize, in the example, \"main\". \"main\" will be mapped to <strong>appdirectory/scripts/main.js</strong> in your project. The build system will then trace the dependencies for main.js and inject them into the <strong>appdirectory-build/scripts/main.js</strong> file.</p> <p>It will also optimize any CSS files it finds inside <strong>appdirectory-build</strong>.</p> <p>To run the build, run this command from inside the <strong>appdirectory/scripts</strong> directory:</p> <pre>node ../../r.js -o app.build.js\n</pre> <p>Once the build is done, you can use <strong>appdirectory-build</strong> as your optimized project, ready for deployment.</p>   <h2 id=\"wholemultipage\">Optimizing a multi-page project</h2> <p><a href=\"https://github.com/requirejs/example-multipage\">requirejs/example-multipage</a> is an example of a project that has multiple pages, but shares a common configuration and a common optimized build layer.</p>   <h2 id=\"turbo\">Turbo options</h2> <p>The default for the optimizer is to do the safest, most robust set of actions that avoid surprises after a build. However, depending on your project setup, you may want to turn off some of these features to get faster builds:</p> <ul> <li>The biggest time drain is minification. If you are just doing builds as part of a dev workflow, then set <strong>optimize</strong> to <code>\"none\"</code>.</li> <li>If doing a whole project optimization, but only want to minify the build layers specified in <strong>modules</strong> options and not the rest of the JS files in the build output directory, you can set <strong>skipDirOptimize</strong> to <code>true</code>.</li> <li>Normally each run of a whole project optimization will delete the output build directory specified by <strong>dir</strong> for cleanliness. Some build options, like <strong>onBuildWrite</strong>, will modify the output directory in a way that is hazardous to do twice over the same files. However, if you are doing simple builds with no extra file transforms besides build layer minification, then you can set <strong>keepBuildDir</strong> to <code>true</code> to keep the build directory between runs. Then, only files that have changed between build runs will be copied.</li> </ul> <p>As of version 2.1.2, there are some speed shortcuts the optimizer will take by default if <strong>optimize</strong> is set to <code>\"none\"</code>. However, if you are using <code>\"none\"</code> for <strong>optimize</strong> and you are planning to minify the built files after the optimizer runs, then you should turn set <strong>normalizeDirDefines</strong> to <code>\"all\"</code> so that define() calls are normalized correctly to withstand minification. If you are doing minification via the <strong>optimize</strong> option, then you do not need to worry about setting this option.</p>   <h2 id=\"hasjs\">Integration with has.js</h2> <p><a href=\"https://github.com/phiggins42/has.js\">has.js</a> is a great tool to that adds easy feature detection for your project. There is some optimizer support for optimizing code paths for has.js tests.</p> <p>If your code uses tests like the following:</p> <pre>\nif (has(\"someThing\")) {\n    //use native someThing\n} else {\n    //do some workaround\n}\n</pre> <p>You can define a <b>has</b> object in the build config with true or false values for some has() tests, and the optimizer will replace the has() test with the true or false value.</p> <p>If your build profile looked like so:</p> <pre>\n({\n    baseUrl: \".\",\n    name: \"hasTestModule\",\n    out: \"builds/hasTestModule.js\",\n    has: {\n        someThing: true\n    }\n})\n</pre> <p>Then the optimizer will transform the above code sample to:</p> <pre>\nif (true) {\n    //use native someThing\n} else {\n    //do some workaround\n}\n</pre> <p>Then, if you use the default optimize setting of \"uglify\" in r.js 0.26.0 or later, or if the <b>optimize</b> setting is set to \"closure\" (when <a href=\"https://github.com/requirejs/r.js\">run under Java</a>), the minifier will optimize out the dead code branch! So you can do custom builds of your code that are optimized for a set of has() tests.</p>   <h2 id=\"sourcemaps\">Source maps</h2> <p>Version 2.1.6 and higher have experimental support for <a href=\"http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/\">source maps</a>. It works for mapping minified, bundled code to unminified, separate modules and only when <strong>optimize</strong> is set to <code>\"uglify2\"</code>. optimize set to <code>\"closure\"</code> allows only mapping minified, bundled code to unminified bundled code (closure only available when running under Java with Rhino). The unminified files will show up in the developer tools with a \".src.js\" file extension.</p> <p>To enable the source map generation, set <strong>generateSourceMaps</strong> to <code>true</code>. Since the minifier needs to have full control over the minified file to generate the source map, the <strong>preserveLicenseComments</strong> should be explicitly set to <code>false</code>. <a href=\"https://requirejs.org/docs/errors.html#sourcemapcomments\">There is is a way to get some license comments in the minified source though</a>.</p> <p>The optimizer has supported <a href=\"https://blog.getfirebug.com/2009/08/11/give-your-eval-a-name-with-sourceurl/\">sourceURL</a> (by setting <strong>useSourceUrl</strong> to <code>true</code>), for debugging combined modules as individual files. However, that only works with non-minified code. Source maps translate a minified file to a non-minified version. It does not make sense to use useSourceUrl with generateSourceMaps since useSourceUrl needs the source values as strings, which prohibits the useful minification done in combination with generateSourceMaps.</p>   <h2 id=\"options\">All configuration options</h2> <p>There is an <a href=\"https://github.com/requirejs/r.js/blob/master/build/example.build.js\">example.build.js</a> file in the requirejs/build directory that details all of the allowed optimizer configuration options.</p>   <h2 id=\"deployment\">Deployment techniques</h2> <p>The r.js optimizer is designed to offer some primitives that can be used for different deployment scenarios by adding other code on top of it. See the <a href=\"https://github.com/requirejs/r.js/wiki/Deployment-Techniques\">deployment techniques wiki page</a> for ideas on how to use the optimizer in that fashion.</p>   <h2 id=\"pitfalls\">Common pitfalls</h2> <p>If you are having trouble with the examples below, here are some common pitfalls that might be the source of the problem:</p> <p><strong>Do not specify the output directory to within the source area for your JavaScript</strong></p> <p>For instance, if your baseUrl is 'js' and your build output goes into 'js/build', there will likely be problems with extra, nested files generated on each optimization run. This guidance is only for optimizations that are not single file optimizations.</p> <p><strong>Avoid optimization names that are outside the baseUrl</strong></p> <p>For instance, if your baseUrl is 'js', and your optimization targets:</p> <pre>name: '../main'</pre> <p>the optimization could overwrite or place files outside the output directory. For those cases, create a <strong>paths</strong> config to map that file to a local name, like:</p> <pre>paths: {\n    main: '../main'\n}\n</pre> <p>then use name:</p> <pre>name: 'main'</pre> <p>for the optimization target.</p> <p><strong>Note the build limitations of shim config.</strong> In particular, you cannot load dependencies for shimmed libraries from a CDN. See the <a href=\"api#config-shim\">shim config section</a> for more information.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; jQuery Foundation and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://requirejs.org/docs/optimization.html\" class=\"_attribution-link\">https://requirejs.org/docs/optimization.html</a>\n  </p>\n</div>\n","jquery":"<h1>How to use RequireJS with jQuery</h1> <ul class=\"index mono\"> <li class=\"hbox\"> <a href=\"#intro\">Introduction</a> </li> <li class=\"hbox\"> <a href=\"#globalvars\">Global Functions</a> </li> <li class=\"hbox\"> <a href=\"#modulename\">Module Name</a> </li> <li class=\"hbox\"> <a href=\"#shimconfig\">Example using shim config</a> </li> <li class=\"hbox\"> <a href=\"#cdnconfig\">Example loading jquery from a CDN</a> </li> <li class=\"hbox\"> <a href=\"#noconflictmap\">Mapping Modules to use noConflict</a> </li> <li class=\"hbox\"> <a href=\"#oldexample\">The previous example with a concatenated require-jquery file</a> </li> </ul>   <h2 id=\"intro\"> Introduction  </h2> <p>While RequireJS loads jQuery just like any other dependency, jQuery's wide use and extensive plugin ecosystem mean you'll likely have other scripts in your project that also depend on jQuery. You might approach your jQuery RequireJS configuration differently depending on whether you are starting a new project or whether you are adapting existing code.</p>  <h2 id=\"globalvars\"> Global Functions  </h2> <p>jQuery registers itself as the global variables \"$\" and \"jQuery\", even when it detects AMD/RequireJS. The AMD approach advises against the use of global functions, but the decision to turn off these jQuery globals hinges on whether you have non-AMD code that depends on them. jQuery has a <a href=\"http://api.jquery.com/jQuery.noConflict/\">noConflict function</a> that supports releasing control of the global variables and this can be automated in your requirejs.config, as we will see <a href=\"#noconflictmap\">later</a>.</p>   <h2 id=\"modulename\"> Module Name  </h2> <p>jQuery defines <a href=\"api#modulename\">named AMD module</a> 'jquery' (all lower case) when it detects AMD/RequireJS. To reduce confusion, we recommend using 'jquery' as the module name in your requirejs.config. </p>\n<p>Example:</p> <pre>requirejs.config({\n    baseUrl: 'js/lib',\n    paths: {\n        // the left side is the module ID,\n        // the right side is the path to\n        // the jQuery file, relative to baseUrl.\n        // Also, the path should NOT include\n        // the '.js' file extension. This example\n        // is using jQuery 1.9.0 located at\n        // js/lib/jquery-1.9.0.js, relative to\n        // the HTML page.\n        jquery: 'jquery-1.9.0'\n    }\n});\n</pre> <p>The other (recommended) solution is to just name the file 'jquery.js' and place it in the baseUrl directory. Then the above paths entry is not needed.</p> <p>You can avoid lots of configuration lines by placing the files according to the default ID-to-path convention of <code>baseUrl + moduleID + '.js'</code>. The examples below show how to set baseUrl to be the directory for third-party, library code, and use one extra paths config for your app code.</p> <p>So to reiterate, you will likely get an error if you refer to jQuery with another module name, like <code>'lib/jquery'</code>. <strong>This example will not work</strong>:</p> <pre>\n    // THIS WILL NOT WORK\n    define(['lib/jquery'], function ($) {...});\n</pre> <p>It will not work, since jQuery registers itself with the name of 'jquery' and not 'lib/jquery'. In general, explicitly naming modules in the define() call are discouraged, but <a href=\"https://github.com/requirejs/requirejs/wiki/Updating-existing-libraries#anon\">jQuery has some special constraints</a>.</p>   <h2 id=\"shimconfig\"> Example using shim config  </h2> <p>This example shows how to use the <a href=\"api#config-shim\">shim config</a> to specify dependencies for jQuery plugins that do not call <a href=\"api#define\">define()</a>. This example is useful if you have an existing jQuery project you want to convert and do not want to modify the sources of the jQuery plugins to call define().</p> <h4><a class=\"download\" href=\"http://github.com/requirejs/example-jquery-shim\">Example using jQuery with shim config</a></h4>   <h2 id=\"cdnconfig\"> Example loading jquery from a CDN  </h2> <p>This is an example on how to load an optimize your code while loading jQuery from a <a href=\"http://en.wikipedia.org/wiki/Content_delivery_network\">Content Delivery Network</a> (CDN). This example requires all your jQuery plugins to call <a href=\"api#define\">define()</a> to properly express their dependencies. <a href=\"api#config-shim\">Shim config</a> does not work after optimization builds with CDN resources.</p> <h4><a class=\"download\" href=\"http://github.com/requirejs/example-jquery-cdn\">Example using jQuery from a CDN</a></h4>   <h2 id=\"noconflictmap\"> Mapping Modules to use noConflict  </h2> <p>If <strong>all of your modules</strong> (including any third party jQuery plugins or library code that depend on jQuery) are AMD compatible and you want to avoid having $ or jQuery in the global namespace when they call <code>requirejs(['jquery'])</code>, you can use the <a href=\"api#config-map\">map config</a> to map the use of jQuery to a module that calls noConflict and returns that value of jQuery for the 'jquery' module ID.</p> <p>You can use this example with the CDN example above -- the shim example will not work since shimmed libraries need a global jQuery.</p> <pre>requirejs.config({\n    // Add this map config in addition to any baseUrl or\n    // paths config you may already have in the project.\n    map: {\n      // '*' means all modules will get 'jquery-private'\n      // for their 'jquery' dependency.\n      '*': { 'jquery': 'jquery-private' },\n\n      // 'jquery-private' wants the real jQuery module\n      // though. If this line was not here, there would\n      // be an unresolvable cyclic dependency.\n      'jquery-private': { 'jquery': 'jquery' }\n    }\n});\n\n// and the 'jquery-private' module, in the\n// jquery-private.js file:\ndefine(['jquery'], function (jq) {\n    return jq.noConflict( true );\n});\n</pre> <p>This means that any module which uses jQuery will need to use the AMD return value rather than depending on the global $:</p> <pre>\nrequirejs(['jquery'], function( $ ) {\n    console.log( $ ) // OK\n});\n\nrequirejs(['jquery'], function( jq ) {\n    console.log( jq ) // OK\n});\n\nrequirejs(['jquery'], function( ) {\n    console.log( $ ) // UNDEFINED!\n});\n</pre>   <h2 id=\"oldexample\"> The previous example with a concatenated require-jquery file  </h2> <p> Previously, we've been pointing to an example using a special require-jquery file, which consisted of require.js and jQuery concatenated. This is no longer the recommended way to use jQuery with require.js, but if you're looking for the (no longer maintained) example, <a href=\"https://github.com/requirejs/require-jquery\">you can find require-jquery here</a>. </p>   <div id=\"footer\" class=\"mono\"> <span class=\"line\">Latest Release: <a href=\"http://requirejs.org/docs/download.html\">2.2.0</a></span> <span class=\"line\">Open source: <a href=\"https://github.com/requirejs/requirejs/blob/master/LICENSE\">new BSD or MIT licensed</a></span> <span class=\"line\">web design by <a href=\"http://andychung.me/\">Andy Chung</a> Â© 2011-2015</span> </div><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; jQuery Foundation and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://requirejs.org/docs/jquery.html\" class=\"_attribution-link\">https://requirejs.org/docs/jquery.html</a>\n  </p>\n</div>\n","node":"<h1>RequireJS in Node</h1> <ul class=\"index mono\"> <li class=\"hbox\"> <a href=\"#1\">Doesn't Node already have a module loader?</a> </li> <li class=\"hbox\"> <a href=\"#2\">Can I use server modules written in the CommonJS module format?</a> </li> <li class=\"hbox\"> <a href=\"#3\">How do I use it?</a> </li> </ul>   <h2 id=\"1\"> Doesn't Node already have a module loader?  </h2> <p>Yes <a href=\"http://nodejs.org\">Node</a> does. That loader uses the CommonJS module format. The CommonJS module format is <a href=\"why\">non-optimal for the browser</a>, and I do not agree with <a href=\"http://tagneto.blogspot.com/2010/03/commonjs-module-trade-offs.html\">some of the trade-offs made in the CommonJS module format</a>. By using RequireJS on the server, you can use one format for all your modules, whether they are running server side or in the browser. That way you can preserve the speed benefits and easy debugging you get with RequireJS in the browser, and not have to worry about extra translation costs for moving between two formats.</p> <p>If you want to use define() for your modules but still run them in Node without needing to run RequireJS on the server, see <a href=\"#nodeModules\">the section below</a> about using <a href=\"https://github.com/jrburke/amdefine\">amdefine</a>.</p>   <h2 id=\"2\"> Can I use Node modules already written in the CommonJS module format? </h2> <p>Yes! The Node adapter for RequireJS, called r.js, will use Node's implementation of require and Node's search paths if the module is not found with the configuration used by RequireJS, so you can continue to use your existing Node-based modules without having to do changes to them.</p> <p>RequireJS will use its <a href=\"api#config\">Configuration Options</a> first to find modules. If RequireJS cannot find the module with its configuration, it is assumed to be a module that uses Node's type of modules and configuration. So, only configure module locations with RequireJS if they use the RequireJS API. For modules that expect Node's APIs and configuration/paths, just install them with a Node package manager, like <a href=\"http://npmjs.org/\">npm</a>, and do not configure their locations with RequireJS.</p> <p><strong>Best practice</strong>: Use npm to install Node-only packages/modules into the projects <strong>node_modules</strong> directory, but do not configure RequireJS to look inside the node_modules directory. Also avoid using relative module IDs to reference modules that are Node-only modules. So, <strong>do not</strong> do something like <strong>require(\"./node_modules/foo/foo\")</strong>.</p> <p>Other notes:</p> <ul> <li>RequireJS in Node can only load modules that are on the local disk -- fetching modules across http, for instance, is not supported at this time.</li> <li>RequireJS config options like map, packages, paths are only applied if RequireJS loads the module. If RequireJS needs to ask the node module system, the original ID is passed to Node. If you need a node module to work with a map config, inline define() calls work, as shown in <a href=\"https://groups.google.com/forum/#!msg/requirejs/ur_UQLr04rc/sSpM8y87VNMJ\">this email list thread.</a>\n</li> </ul>   <h2 id=\"3\"> How do I use it?  </h2> <p>There are two ways to get the Node adapter:</p> <h3 id=\"npm\">npm</h3> <p>Use <a href=\"http://npmjs.org\">npm</a> to install it:</p> <pre>npm install requirejs\n</pre> <p>This option will install the latest release.</p> <h3 id=\"rjs\">Download r.js</h3> <p>If you prefer to not use npm, you can get r.js directly:</p> <ul> <li>Download r.js from the <a href=\"https://requirejs.org/docs/download.html#rjs\">the download page</a> and place it in your project.</li> <li>Get the source from the <a href=\"https://github.com/requirejs/r.js\">r.js repo</a> and either generate the r.js via \"node dist.js\", or grab a snapshot from the <strong>dist</strong> directory.</li> </ul> <h3 id=\"usage\">Usage\n</h3>\n<p>These instructions assume an npm installation of 'requirejs'. If you are using the r.js file directly, replace require('requirejs') with require('./path/to/r.js'). Basic usage is:</p> <ul> <li>require('requirejs')</li> <li>Pass the main js file's \"require\" function in the configuration to requirejs.</li> </ul> <p>Example:</p> <pre>var requirejs = require('requirejs');\n\nrequirejs.config({\n    //Pass the top-level main.js/index.js require\n    //function to requirejs so that node modules\n    //are loaded relative to the top-level JS file.\n    nodeRequire: require\n});\n\nrequirejs(['foo', 'bar'],\nfunction   (foo,   bar) {\n    //foo and bar are loaded according to requirejs\n    //config, but if not found, then node's require\n    //is used to load the module.\n});\n</pre> <p>Be sure to read the <a href=\"#2\">notes in section 2</a> about configuring RequireJS so that it can load node-only modules installed via npm.</p> <p>To see a more complete example that loads a module via RequireJS but uses Node-native modules for other things, see the <a href=\"https://github.com/requirejs/r.js/tree/master/tests/node/embedded\">embedded test</a> in the r.js repo.</p> <p><strong>Note:</strong> <code>requirejs([], function() {})</code> will call the function callback asynchronously in RequireJS 2.1+ (for earlier versions it was synchronously called). However, when running in Node, module loading will be loaded using sync IO calls, and loader plugins should resolve calls to their load method synchronously. This allows sync uses of the requirejs module in node to work via requirejs('stringValue') calls: </p>\n<pre>//Retrieves the module value for 'a' synchronously\nvar a = requirejs('a')</pre> <h3 id=\"nodeModules\">Building node modules with AMD or RequireJS</h3> <p>If you want to code a module so that it works with RequireJS and in Node, without requiring users of your library in Node to use RequireJS, then you can use the <a href=\"https://github.com/jrburke/amdefine\">amdefine</a> package to do this:</p> <pre>if (typeof define !== 'function') {\n    var define = require('amdefine')(module);\n}\n\ndefine(function(require) {\n    var dep = require('dependency');\n\n    //The value returned from the function is\n    //used as the module export visible to Node.\n    return function () {};\n});\n</pre> <p>The RequireJS optimizer, as of version 1.0.3, will strip out the use of 'amdefine' above, so it is safe to use this module for your web-based projects too. Just be sure to use <strong>the exact 'amdefine' if() test and contents as shown above</strong>. Differences in spaces/line breaks are allowed. See the <a href=\"https://github.com/jrburke/amdefine\">amdefine project</a> for more information.</p> <p>If you want to use RequireJS directly to code your module, and then export a module value to node so that it can be used in other Node programs without requiring that app to use RequireJS, you can use the approach listed in the next example.</p> <p>It is best to set the baseUrl specifically to the directory containing the module, so that it works properly when nested inside a node_modules heirarchy. Use the synchronous <code>requirejs('moduleId')</code> to fetch the module using the config and rules in requirejs, then use Node's module.exports to export your module value:</p> <pre>var requirejs = require('requirejs');\n\nrequirejs.config({\n    //Use node's special variable __dirname to\n    //get the directory containing this file.\n    //Useful if building a library that will\n    //be used in node but does not require the\n    //use of node outside\n    baseUrl: __dirname,\n\n    //Pass the top-level main.js/index.js require\n    //function to requirejs so that node modules\n    //are loaded relative to the top-level JS file.\n    nodeRequire: require\n});\n\n//foo and bar are loaded according to requirejs\n//config, and if found, assumed to be an AMD module.\n//If they are not found via the requirejs config,\n//then node's require is used to load the module,\n//and if found, the module is assumed to be a\n//node-formatted module. Note: this synchronous\n//style of loading a module only works in Node.\nvar foo = requirejs('foo');\nvar bar = requirejs('bar');\n\n//Now export a value visible to Node.\nmodule.exports = function () {};\n</pre> <h3 id=\"optimizer\">Using the optimizer as a node module</h3> <p>The node module also exposes the RequireJS Optimizer as an <strong>optimize</strong> method for using the <a href=\"optimization\">RequireJS optimizer</a> via a function call instead of a command line tool:</p> <pre>var requirejs = require('requirejs');\n\nvar config = {\n    baseUrl: '../appDir/scripts',\n    name: 'main',\n    out: '../build/main-built.js'\n};\n\nrequirejs.optimize(config, function (buildResponse) {\n    //buildResponse is just a text output of the modules\n    //included. Load the built file for the contents.\n    //Use config.out to get the optimized file contents.\n    var contents = fs.readFileSync(config.out, 'utf8');\n}, function(err) {\n    //optimization err callback\n});\n</pre> <p>This allows you to build other optimization workflows, like <a href=\"https://github.com/requirejs/r.js/tree/master/build/tests/http\">a web builder</a> that can be used if you prefer to always develop with the \"one script file included before the &lt;/body&gt; tag\" approach. The optimizer running in Node is fairly fast, but for larger projects that do not want to regenerate the build for every browser request, but just if you modify a script that is part of the build. You could use Node's fs.watchFile() to watch files and then trigger the build when a file changes.</p> <h3 id=\"feedback\">Feedback</h3> <p>If you find you have a problem, and want to report it, use the <a href=\"http://github.com/requirejs/r.js/issues\">r.js GitHub Issues page</a>.</p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; jQuery Foundation and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://requirejs.org/docs/node.html\" class=\"_attribution-link\">https://requirejs.org/docs/node.html</a>\n  </p>\n</div>\n","why":"<h1>Why Web Modules?</h1> <ul class=\"index mono\"> <li class=\"hbox\"> <a href=\"#1\">The Problem</a> </li> <li class=\"hbox\"> <a href=\"#2\">Solution</a> </li> <li class=\"hbox\"> <a href=\"#3\">Script loading APIs</a> </li> <li class=\"hbox\"> <a href=\"#4\">Async vs Sync</a> </li> <li class=\"hbox\"> <a href=\"#5\">Script loading: XHR</a> </li> <li class=\"hbox\"> <a href=\"#6\">Script loading: Web Workers</a> </li> <li class=\"hbox\"> <a href=\"#7\">Script loading: document.write()</a> </li> <li class=\"hbox\"> <a href=\"#8\">Script loading: head.appendchild(script)</a> </li> <li class=\"hbox\"> <a href=\"#9\">Function wrapping</a> </li> </ul> <p>This page discusses why modules on the web are useful and the mechanisms that can be used on the web today to enable them. There is a separate page that talks about <a href=\"whyamd\">the design forces</a> for the particular function wrapped format used by RequireJS.</p>   <h2 id=\"1\"> The Problem  </h2> <ul> <li>Web sites are turning into Web apps</li> <li>Code complexity grows as the site gets bigger</li> <li>Assembly gets harder</li> <li>Developer wants discrete JS files/modules</li> <li>Deployment wants optimized code in just one or a few HTTP calls</li> </ul>   <h2 id=\"2\">Solution</h2> <p>Front-end developers need a solution with:</p> <ul> <li>Some sort of #include/import/require</li> <li>Ability to load nested dependencies</li> <li>Ease of use for developer but then backed by an optimization tool that helps deployment</li> </ul>   <h2 id=\"3\">Script Loading APIs</h2> <p>First thing to sort out is a script loading API. Here are some candidates:</p> <ul> <li>Dojo: dojo.require(\"some.module\")</li> <li>LABjs: $LAB.script(\"some/module.js\")</li> <li>CommonJS: require(\"some/module\")</li> </ul> <p>All of them map to loading some/path/some/module.js. Ideally we could choose the CommonJS syntax, since it is likely to get more common over time, and we want to reuse code.</p> <p>We also want some sort of syntax that will allow loading plain JavaScript files that exist today -- a developer should not have to rewrite all of their JavaScript to get the benefits of script loading.</p> <p>However, we need something that works well in the browser. The CommonJS require() is a synchronous call, it is expected to return the module immediately. This does not work well in the browser.</p>   <h2 id=\"4\">Async vs Sync</h2> <p>This example should illustrate the basic problem for the browser. Suppose we have an Employee object and we want a Manager object to derive from the Employee object. <a href=\"https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Details_of_the_Object_Model#Creating_the_hierarchy\">Taking this example</a>, we might code it up like this using our script loading API:</p> <pre>var Employee = require(\"types/Employee\");\n\nfunction Manager () {\n    this.reports = [];\n}\n\n//Error if require call is async\nManager.prototype = new Employee();\n</pre> <p>As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?</p>   <h2 id=\"5\">Script Loading: XHR</h2> <p>It is tempting to use XMLHttpRequest (XHR) to load the scripts. If XHR is used, then we can massage the text above -- we can do a regexp to find require() calls, make sure we load those scripts, then use eval() or script elements that have their body text set to the text of the script loaded via XHR.</p> <p>Using eval() to evaluate the modules is bad:</p> <ul> <li>Developers have been taught that eval() is bad.</li> <li>Some environments do not allow eval().</li> <li>It is harder to debug. Firebug and WebKit's inspector have an //@ sourceURL= convention, which helps give a name to evaled text, but this support is not universal across browsers.</li> <li>eval context is different across browsers. You might be able to use execScript in IE to help this, but it means more moving parts.</li> </ul> <p>Using script tags with body text set to file text is bad:</p> <ul> <li>While debugging, the line number you get for an error does not map to the original source file.</li> </ul> <p>XHR also has issues with cross-domain requests. Some browsers now have cross-domain XHR support, but it is not universal, and IE decided to create a different API object for cross-domain calls, XDomainRequest. More moving parts and more things to get wrong. In particular, you need to be sure to not send any non-standard HTTP headers or there may be another \"preflight\" request done to make sure the cross-domain access is allowed.</p> <p>Dojo has used an XHR-based loader with eval() and, while it works, it has been a source of frustration for developers. Dojo has an xdomain loader but it requires the modules to be modified via a build step to use a function wrapper, so that script src=\"\" tags can be used to load the modules. There are many edge cases and moving parts that create a tax on the developer.</p> <p>If we are creating a new script loader, we can do better.</p>   <h2 id=\"6\">Script Loading: Web Workers</h2> <p>Web Workers might be another way to load scripts, but:</p> <ul> <li>It does not have strong cross browser support</li> <li>It is a message-passing API, and the scripts likely want to interact with the DOM, so it means just using the worker to fetch the script text, but pass the text back to the main window then use eval/script with text body to execute the script. This has all of the problems as XHR mentioned above.</li> </ul>   <h2 id=\"7\">Script Loading: document.write()</h2> <p>document.write() can be used to load scripts -- it can load scripts from other domains and it maps to how browsers normally consume scripts, so it allows for easy debugging.</p> <p>However, in the <a href=\"#4\">Async vs Sync example</a> we cannot just execute that script directly. Ideally we could know the require() dependencies before we execute the script, and make sure those dependencies are loaded first. But we do not have access to the script before it is executed.</p> <p>Also, document.write() does not work after page load. A great way to get perceived performance for your site is loading code on demand, as the user needs it for their next action.</p> <p>Finally, scripts loaded via document.write() will block page rendering. When looking at reaching the very best performance for your site, this is undesirable.</p>   <h2 id=\"8\">Script Loading: head.appendChild(script)</h2> <p>We can create scripts on demand and add them to the head:</p> <pre>var head = document.getElementsByTagName('head')[0],\n    script = document.createElement('script');\n\nscript.src = url;\nhead.appendChild(script);\n</pre> <p>There is a bit more involved than just the above snippet, but that is the basic idea. This approach has the advantage over document.write in that it will not block page rendering and it works after page load.</p> <p>However, it still has the <a href=\"#4\">Async vs Sync example</a> problem: ideally we could know the require() dependencies before we execute the script, and make sure those dependencies are loaded first.</p>   <h2 id=\"9\">Function Wrapping</h2> <p>So we need to know the dependencies and make sure we load them before executing our script. The best way to do that is construct our module loading API with function wrappers. Like so:</p> <pre>define(\n    //The name of this module\n    \"types/Manager\",\n\n    //The array of dependencies\n    [\"types/Employee\"],\n\n    //The function to execute when all dependencies have loaded. The\n    //arguments to this function are the array of dependencies mentioned\n    //above.\n    function (Employee) {\n        function Manager () {\n            this.reports = [];\n        }\n\n        //This will now work\n        Manager.prototype = new Employee();\n\n        //return the Manager constructor function so it can be used by\n        //other modules.\n        return Manager;\n    }\n);\n</pre> <p>And this is the syntax used by RequireJS. There is also a simplified syntax if you just want to load some plain JavaScript files that do not define modules:</p> <pre>require([\"some/script.js\"], function() {\n    //This function is called after some/script.js has loaded.\n});\n</pre> <p>This type of syntax was chosen because it is terse and allows the loader to use head.appendChild(script) type of loading.</p> <p>It differs from the normal CommonJS syntax out of necessity to work well in the browser. There have been suggestions that the normal CommonJS syntax could be used with head.appendChild(script) type of loading if a server process transforms the modules to a transport format that has a function wrapper.</p> <p>I believe it is important to not force the use of a runtime server process to transform code:</p> <ul> <li>It makes debugging weird, line numbers will be off vs. the source file since the server is injecting a function wrapper.</li> <li>It requires more gear. Front-end development should be possible with static files.</li> </ul> <p>More details on the design forces and use cases for this function wrapping format, called Asynchronous Module Definition (AMD), can be found on the <a href=\"whyamd\">Why AMD?</a> page. </p><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; jQuery Foundation and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://requirejs.org/docs/why.html\" class=\"_attribution-link\">https://requirejs.org/docs/why.html</a>\n  </p>\n</div>\n","plugins":"<h1>Plugins</h1> <ul class=\"index mono\"> <li class=\"hbox\">\n<a href=\"#intro\">Intro</a>\n</li> <li class=\"hbox\">\n<a href=\"#names\">Plugin Names</a>\n</li> <li class=\"hbox\">\n<a href=\"#api\">API</a>\n</li> <ul> <li class=\"hbox\">\n<a href=\"#apiload\">load</a>\n</li> <li class=\"hbox\">\n<a href=\"#apinormalize\">normalize</a>\n</li> <li class=\"hbox\">\n<a href=\"#apiwrite\">write</a>\n</li> <li class=\"hbox\">\n<a href=\"#apionlayerend\">onLayerEnd</a>\n</li> <li class=\"hbox\">\n<a href=\"#apiwritefile\">writeFile</a>\n</li> <li class=\"hbox\">\n<a href=\"#apipluginbuilder\">pluginBuilder</a>\n</li> </ul> </ul>   <h2 id=\"intro\"> Intro  </h2> <p>RequireJS allows you to write loader plugins that can load different types of resources as dependencies, and even include the dependencies in optimized builds.</p> <p>Examples of existing loader plugins are the <a href=\"api#text\">text!</a> and <a href=\"api#i18n\">i18n!</a> plugins. The text! plugin handles loading text, and the i18n plugin handles loading a JavaScript object that is made up from objects from a few different modules. The object contains localized strings.</p> <p>The RequireJS wiki has a longer <a href=\"https://github.com/requirejs/requirejs/wiki/Plugins\">list of plugins</a>.</p>   <h2 id=\"names\"> Plugin Names  </h2> <p>Loader plugins are just another module, but they implement a specific API. Loader plugins can also participate in the optimizer optimizations, allowing the resources they load to be inlined in an optimized build.</p> <p><b>Note</b>: the plugin and its dependencies should be able to run in non-browser environments like Node and Nashorn. If they cannot, you should use an alternate <a href=\"#apipluginbuilder\">plugin builder</a> module that can run in those environments so that they can participate in optimization builds.</p> <p>You can reference your plugin by putting its module name before a ! in the dependency. For instance, if you create a plugin with the name \"foo.js\", you would use it like so:</p> <pre>\nrequire(['foo!something/for/foo'], function (something) {\n    //something is a reference to the resource\n    //'something/for/foo' that was loaded by foo.js.\n});\n</pre> <p>So, the plugin's module name comes before the ! separator. The part after the ! separator is called the <b>resource name</b>. The resource name may look like a normal module name. The plugin's module name can be any valid module name, so for instance, you could use a relative indicator:</p> <pre>\nrequire(['./foo!something/for/foo'], function (something) {\n});\n</pre> <p>Or, if it was inside a package or directory, say bar/foo.js:</p> <pre>\nrequire(['bar/foo!something/for/foo'], function (something) {\n});\n</pre>   <h2 id=\"api\"> API  </h2> <p>RequireJS will load the plugin module first, then pass the rest of the dependency name to a load() method on the plugin. There are also some methods to help with module name normalization and for making use of the plugin as part of the <a href=\"optimization\">optimizer</a>.</p> <p>The complete Plugin API:</p> <ul> <li>\n<b><a href=\"#apiload\">load</a></b>: A function that is called to load a resource. This is the only mandatory API method that needs to be implemented for the plugin to be useful.</li> <li>\n<b><a href=\"#apinormalize\">normalize</a></b>: A function to normalize the resource name. This is useful in providing optimal caching and optimization, but only needed if the resource name is not a module name.</li> <li>\n<b><a href=\"#apiwrite\">write</a></b>: used by the optimizer to indicate when the plugin should write out a representation of the resource in the optimized file.</li> <li>\n<b><a href=\"#apipluginbuilder\">pluginBuilder</a></b>: A module name string for a module that should be used in the optimizer to do optimization work. That module is used instead of the plugin module when the optimizer runs.</li> </ul> <h3 id=\"apiload\"> load: function (name, parentRequire, onload, config)  </h3> <p>load is a function, and it will be called with the following arguments:</p> <ul> <li>\n<b>name</b>: String. The name of the resource to load. This is the part after the ! separator in the name. So, if a module asks for 'foo!something/for/foo', the foo module's load function will receive 'something/for/foo' as the name.</li> <li>\n<b>parentRequire</b>: Function. A local \"require\" function to use to load other modules. This function will resolve relative module names relative to the module name that asked for this plugin resource. If the loader plugin wants to <code>require()</code> something relative to its own ID, it can ask for a <code>require</code> in its own <code>define</code> call. This require function has some utilities on it: <ul> <li>\n<b>parentRequire.toUrl(moduleResource)</b>:where moduleResource is a module name plus an extension. For instance \"view/templates/main.html\". It will return a full path to the resource, obeying any RequireJS configuration.</li> <li>\n<b>parentRequire.defined(moduleName)</b>: Returns true if the module has already been loaded and defined. Used to be called require.isDefined before RequireJS 0.25.0.</li> <li>\n<b>parentRequire.specified(moduleName)</b>: Returns true if the module has already been requested or is in the process of loading and should be available at some point.</li> </ul>\n</li> <li>\n<b>onload</b>: Function. A function to call with the value for name. This tells the loader that the plugin is done loading the resource. <b>onload.error()</b> can be called, passing an error object to it, if the plugin detects an error condition that means the resource will fail to load correctly.</li> <li>\n<b>config</b>: Object. A configuration object. This is a way for the optimizer and the web app to pass configuration information to the plugin. The i18n! plugin uses this to get the current locale, if the web app wants to force a specific locale. The optimizer will set an <b>isBuild</b> property in the config to true if this plugin (or pluginBuilder) is being called as part of an optimizer build.</li> </ul> <p>An example plugin that does not do anything interesting, just does a normal require to load a JS module:</p> <pre>\ndefine({\n    load: function (name, req, onload, config) {\n        //req has the same API as require().\n        req([name], function (value) {\n            onload(value);\n        });\n    }\n});\n</pre> <p>Some plugins may need to evaluate some JavaScript that was retrieved as text, and use that evaluated JavaScript as the value for the resource. There is a function off the onload() argument, <strong>onload.fromText()</strong>, that can be used to evaluate the JavaScript. eval() is used by RequireJS to evaluate that JavaScript, and RequireJS will do the right work for any anonymous define() call in the evaluated text, and use that define() module as the value for the resource.</p> <p>Arguments for onload.fromText() (RequireJS 2.1.0 and later):</p> <ul> <li>\n<b>text</b>: String. The string of JavaScript to evaluate.</li> </ul> <p>An example plugin's load function that uses onload.fromText():</p> <pre>\ndefine({\n    load: function (name, req, onload, config) {\n        var url = req.toUrl(name + '.customFileExtension'),\n            text;\n\n        //Use a method to load the text (provide elsewhere)\n        //by the plugin\n        fetchText(url, function (text) {\n            //Transform the text as appropriate for\n            //the plugin by using a transform()\n            //method provided elsewhere in the plugin.\n            text = transform(text);\n\n            //Have RequireJS execute the JavaScript within\n            //the correct environment/context, and trigger the load\n            //call for this resource.\n            onload.fromText(text);\n        });\n    }\n});\n</pre> <p>Before RequireJS 2.1.0, onload.fromText accepted a moduleName as the first argument: <code>onload.fromText(moduleName, text)</code>, and the loader plugin had to manually call <code>require([moduleName], onload)</code> after the onload.fromText() call.</p> <p><b id=\"loadBuildInfo\">Build considerations</b>: The optimizer traces dependencies <b>synchronously</b> to simplify the optimization logic. This is different from how require.js in the browser works, and it means that only plugins that can satisfy their dependencies synchronously should participate in the optimization steps that allow inlining of loader plugin values. Otherwise, the plugin should just call load() immediately if <code>config.isBuild</code> is true:</p> <pre>\ndefine({\n    load: function (name, req, onload, config) {\n        if (config.isBuild) {\n            //Indicate that the optimizer should not wait\n            //for this resource any more and complete optimization.\n            //This resource will be resolved dynamically during\n            //run time in the web browser.\n            onload();\n        } else {\n            //Do something else that can be async.\n        }\n    }\n});\n</pre> <p>Some plugins may do an async operation in the browser, but opt to complete the resource load synchronously when run in Node/Nashorn. This is what the text plugin does. If you just want to run AMD modules and load plugin dependencies using <a href=\"http://github.com/jrburke/amdefine\">amdefine</a> in Node, those also need to complete synchronously to match Node's synchronous module system.</p> <h3 id=\"apinormalize\"> normalize: function (name, normalize)  </h3> <p><b>normalize</b> is called to normalize the name used to identify a resource. Some resources could use relative paths, and need to be normalized to the full path. normalize is called with the following arguments:</p> <ul> <li>\n<b>name</b>: String. The resource name to normalize.</li> <li>\n<b>normalize</b>: Function. A function that can be called to normalize a regular module name.</li> </ul> <p>An example: suppose there is an <b>index!</b> plugin that will load a module name given an index. This is a contrived example, just to illustrate the concept. A module may reference an index! resource like so:</p> <pre>\ndefine(['index!2?./a:./b:./c'], function (indexResource) {\n    //indexResource will be the module that corresponds to './c'.\n});\n</pre> <p>In this case, the normalized names the './a', './b', and './c' will be determined relative to the module asking for this resource. Since RequireJS does not know how to inspect the 'index!2?./a:./b:./c' to normalize the names for './a', './b', and './c', it needs to ask the plugin. This is the purpose of the normalize call.</p> <p>By properly normalizing the resource name, it allows the loader to cache the value effectively, and to properly build an optimized build layer in the optimizer.</p> <p>The <b>index!</b> plugin could be written like so:</p> <pre>\n(function () {\n\n    //Helper function to parse the 'N?value:value:value'\n    //format used in the resource name.\n    function parse(name) {\n        var parts = name.split('?'),\n            index = parseInt(parts[0], 10),\n            choices = parts[1].split(':'),\n            choice = choices[index];\n\n        return {\n            index: index,\n            choices: choices,\n            choice: choice\n        };\n    }\n\n    //Main module definition.\n    define({\n        normalize: function (name, normalize) {\n            var parsed = parse(name),\n                choices = parsed.choices;\n\n            //Normalize each path choice.\n            for (i = 0; i </pre> <p>You do not need to implement normalize if the resource name is just a regular module name. For instance, the text! plugin does not implement normalize because the dependency names look like 'text!./some/path.html'.</p> <p>If a plugin does not implement normalize, then the loader will try to normalize the resource name using the normal module name rules.</p> <h3 id=\"apiwrite\"> write: function (pluginName, moduleName, write)  </h3> <p><b>write</b> is only used by the optimizer, and it only needs to be implemented if the plugin can output something that would belong in an optimized layer. It is called with the following arguments:</p> <ul> <li>\n<b>pluginName</b>: String. The <b>normalized</b> name for the plugin. Most plugins will not be authored with a name (they will be anonymous plugins) so it is useful to know the normalized name for the plugin module for use in the optimized file.</li> <li>\n<b>moduleName</b>: String. The <b>normalized</b> resource name.</li> <li>\n<b>write</b>: Function. A function to be called with a string of output to write to the optimized file. This function also contains a property function, <b>write.asModule(moduleName, text)</b>. asModule can be used to write out a module that may have an anonymous define call in there that needs name insertion or/and contains implicit require(\"\") dependencies that need to be pulled out for the optimized file. asModule is useful for text transform plugins, like a CoffeeScript plugin.</li> </ul> <p>The text! plugin implements write, to write out a string value for the text file that it loaded. A snippet from that file:</p> <pre>\nwrite: function (pluginName, moduleName, write) {\n    //The text plugin keeps a map of strings it fetched\n    //during the build process, in a buildMap object.\n    if (moduleName in buildMap) {\n        //jsEscape is an internal method for the text plugin\n        //that is used to make the string safe\n        //for embedding in a JS string.\n        var text = jsEscape(buildMap[moduleName]);\n        write(\"define('\" + pluginName + \"!\" + moduleName  +\n              \"', function () { return '\" + text + \"';});\\n\");\n    }\n}\n</pre> <h3 id=\"apionlayerend\"> onLayerEnd: function (write, data)  </h3> <p><b>onLayerEnd</b> is only used by the optimizer, and is only supported in 2.1.0 or later of the optimizer. It is called after the modules for the layer have been written to the layer. It is useful to use if you need some code that should go at the end of the layer, or if the plugin needs to reset some internal state.</p> <p>One example: a plugin that needs to write out some utility functions at the beginning of a layer, as part of the first <a href=\"#apiwrite\">write</a> call, and the plugin needs to know when to reset the internal state to know when to write out the utilities for the next layer. If the plugin implements onLayerEnd, it can get notified when to reset its internal state.</p> <p>onLayerEnd is called with the following arguments:</p> <ul> <li>\n<b>write</b>: Function. A function to be called with a string of output to write to the optimized layer. <b>Modules should not be written out</b> in this call. They will not be normalized correctly for coexistence with other define() calls already in the file. It is useful only for writing out non-define() code.</li> <li>\n<b>data</b>: Object. Information about the layer. Only has two properties: <ul> <li>\n<b>name</b>: the module name of the layer. May be undefined.</li> <li>\n<b>path</b>: the file path of the layer. May be undefined, particularly if the output is just to a string that is consumed by another script.</li> </ul>\n</li> </ul> <h3 id=\"apiwritefile\"> writeFile: function (pluginName, name, parentRequire, write)  </h3> <p><b>writeFile</b> is only used by the optimizer, and it only needs to be implemented if the plugin needs to write out an alternate version of a dependency that is handled by the plugin. It is a bit expensive to scan all modules in a project to look for all plugin dependencies, so this writeFile method will only be called if <b>optimizeAllPluginResources: true</b> is in the build profile for the RequireJS optimizer. writeFile is called with the following arguments:</p> <ul> <li>\n<b>pluginName</b>: String. The <b>normalized</b> name for the plugin. Most plugins will not be authored with a name (they will be anonymous plugins) so it is useful to know the normalized name for the plugin module for use in the optimized file.</li> <li>\n<b>name</b>: String. The <b>normalized</b> resource name.</li> <li>\n<b>parentRequire</b>: Function. A local \"require\" function. The main use of this in writeFile is for calling parentRequire.toUrl() to generate file paths that are inside the build directory.</li> <li>\n<b>write</b>: Function. A function to be called with two arguments: <ul> <li>\n<b>fileName</b>: String. The name of the file to write. You can use parentRequire.toUrl() with a relative path to generate a file name that will be inside the build output directory.</li> <li>\n<b>text</b>: String. The contents of the file. Must be UTF-8 encoded.</li> </ul> This function also contains a property function, <b>write.asModule(moduleName, fileName, text)</b>. asModule can be used to write out a module that may have an anonymous define call in there that needs name insertion or/and contains implicit require(\"\") dependencies that need to be pulled out for the optimized file.</li> </ul> <p>See the <a href=\"https://github.com/requirejs/text\">text! plugin</a> for an example of writeFile.</p> <h3 id=\"apipluginbuilder\"> pluginBuilder  </h3> <p><b>pluginBuilder</b> can be a string that points to another module to use instead of the current plugin when the plugin is used as part of an optimizer build.</p> <p>A plugin could have very specific logic that depends on a certain environment, like the browser. However, when run inside the optimizer, the environment is very different, and the plugin may have a <b>write</b> plugin API implementation that it does not want to deliver as part of the normal plugin that is loaded in the browser. In those cases, specifying a pluginBuilder is useful.</p> <p>Some notes about using a pluginBuilder:</p> <ul> <li>Do not use named modules for the plugin or the pluginBuilder. The pluginBuilder text contents are used instead of the contents of the plugin file, but that will only work if the files do not call define() with a name.</li> <li>Plugins and pluginBuilders that run as part of the build process have a very limited environment. The optimizer runs in a few different JS environments. Be careful of the environment assumptions if you want the plugin to run as part of the optimizer.</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; jQuery Foundation and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://requirejs.org/docs/plugins.html\" class=\"_attribution-link\">https://requirejs.org/docs/plugins.html</a>\n  </p>\n</div>\n","whyamd":"<h1>Why AMD?</h1> <ul class=\"index mono\"> <li class=\"hbox\"> <a href=\"#purposes\">Module Purposes</a> </li> <li class=\"hbox\"> <a href=\"#today\">The Web Today</a> </li> <li class=\"hbox\"> <a href=\"#commonjs\">CommonJS</a> </li> <li class=\"hbox\"> <a href=\"#amd\">AMD</a> </li> <li class=\"hbox\"> <a href=\"#definition\">Module Definition</a> </li> <li class=\"hbox\"> <a href=\"#namedmodules\">Named Modules</a> </li> <li class=\"hbox\"> <a href=\"#sugar\">Sugar</a> </li> <li class=\"hbox\"> <a href=\"#commonjscompat\">CommonJS Compatibility</a> </li> <li class=\"hbox\"> <a href=\"#amdtoday\">AMD Used Today</a> </li> <li class=\"hbox\"> <a href=\"#youcando\">What You Can Do</a> </li> </ul> <p>This page talks about the design forces and use of the <a href=\"https://github.com/amdjs/amdjs-api/wiki/AMD\">Asynchronous Module Definition (AMD) API</a> for JavaScript modules, the module API supported by RequireJS. There is a different page that talks about <a href=\"why\">general approach to modules on the web</a>.</p>   <h2 id=\"purposes\"> Module Purposes  </h2> <p>What are JavaScript modules? What is their purpose?</p> <ul> <li>\n<strong>Definition</strong>: how to encapsulate a piece of code into a useful unit, and how to register its capability/export a value for the module.</li> <li>\n<strong>Dependency References</strong>: how to refer to other units of code.</li> </ul>   <h2 id=\"today\"> The Web Today  </h2> <pre>(function () {\n    var $ = this.jQuery;\n\n    this.myExample = function () {};\n}());\n</pre> <p>How are pieces of JavaScript code defined today?</p> <ul> <li>Defined via an immediately executed factory function.</li> <li>References to dependencies are done via global variable names that were loaded via an HTML script tag.</li> <li>The dependencies are very weakly stated: the developer needs to know the right dependency order. For instance, The file containing Backbone cannot come before the jQuery tag.</li> <li>It requires extra tooling to substitute a set of script tags into one tag for optimized deployment.</li> </ul> <p>This can be difficult to manage on large projects, particularly as scripts start to have many dependencies in a way that may overlap and nest. Hand-writing script tags is not very scalable, and it leaves out the capability to load scripts on demand.</p>   <h2 id=\"commonjs\"> CommonJS  </h2> <pre>var $ = require('jquery');\nexports.myExample = function () {};\n</pre> <p>The original <a href=\"http://groups.google.com/group/commonjs\">CommonJS (CJS) list</a> participants decided to work out a module format that worked with today's JavaScript language, but was not necessarily bound to the limitations of the browser JS environment. The hope was to use some stop-gap measures in the browser and hopefully influence the browser makers to build solutions that would enable their module format to work better natively. The stop-gap measures:</p> <ul> <li>Either use a server to translate CJS modules to something usable in the browser.</li> <li>Or use XMLHttpRequest (XHR) to load the text of modules and do text transforms/parsing in browser.</li> </ul> <p>The CJS module format only allowed one module per file, so a \"transport format\" would be used for bundling more than one module in a file for optimization/bundling purposes.</p> <p>With this approach, the CommonJS group was able to work out dependency references and how to deal with circular dependencies, and how to get some properties about the current module. However, they did not fully embrace some things in the browser environment that cannot change but still affect module design:</p> <ul> <li>network loading</li> <li>inherent asynchronicity</li> </ul> <p>It also meant they placed more of a burden on web developers to implement the format, and the stop-gap measures meant debugging was worse. eval-based debugging or debugging multiple files that are concatenated into one file have practical weaknesses. Those weaknesses may be addressed in browser tooling at some point in the future, but the end result: using CommonJS modules in the most common of JS environments, the browser, is non-optimal today.</p>   <h2 id=\"amd\"> AMD  </h2> <pre>define(['jquery'] , function ($) {\n    return function () {};\n});\n</pre> <p>The AMD format comes from wanting a module format that was better than today's \"write a bunch of script tags with implicit dependencies that you have to manually order\" and something that was easy to use directly in the browser. Something with good debugging characteristics that did not require server-specific tooling to get started. It grew out of Dojo's real world experience with using XHR+eval and wanting to avoid its weaknesses for the future.</p> <p>It is an improvement over the web's current \"globals and script tags\" because:</p> <ul> <li>Uses the CommonJS practice of string IDs for dependencies. Clear declaration of dependencies and avoids the use of globals.</li> <li>IDs can be mapped to different paths. This allows swapping out implementation. This is great for creating mocks for unit testing. For the above code sample, the code just expects something that implements the jQuery API and behavior. It does not have to be jQuery.</li> <li>Encapsulates the module definition. Gives you the tools to avoid polluting the global namespace.</li> <li>Clear path to defining the module value. Either use \"return value;\" or the CommonJS \"exports\" idiom, which can be useful for circular dependencies.</li> </ul> <p>It is an improvement over CommonJS modules because:</p> <ul> <li>It works better in the browser, it has the least amount of gotchas. Other approaches have problems with debugging, cross-domain/CDN usage, file:// usage and the need for server-specific tooling.</li> <li>Defines a way to include multiple modules in one file. In CommonJS terms, the term for this is a \"transport format\", and that group has not agreed on a transport format.</li> <li>Allows setting a function as the return value. This is really useful for constructor functions. In CommonJS this is more awkward, always having to set a property on the exports object. Node supports module.exports = function () {}, but that is not part of a CommonJS spec.</li> </ul>   <h2 id=\"definition\"> Module Definition  </h2> <p>Using JavaScript functions for encapsulation has been documented as the <a href=\"http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth\">module pattern</a>:</p> <pre>(function () {\n   this.myGlobal = function () {};\n}());\n</pre> <p>That type of module relies on attaching properties to the global object to export the module value, and it is difficult to declare dependencies with this model. The dependencies are assumed to be immediately available when this function executes. This limits the loading strategies for the dependencies.</p> <p>AMD addresses these issues by:</p> <ul> <li>Register the factory function by calling define(), instead of immediately executing it.</li> <li>Pass dependencies as an array of string values, do not grab globals.</li> <li>Only execute the factory function once all the dependencies have been loaded and executed.</li> <li>Pass the dependent modules as arguments to the factory function.</li> </ul> <pre>//Calling define with a dependency array and a factory function\ndefine(['dep1', 'dep2'], function (dep1, dep2) {\n\n    //Define the module value by returning a value.\n    return function () {};\n});\n</pre>   <h2 id=\"namedmodules\"> Named Modules  </h2> <p>Notice that the above module does not declare a name for itself. This is what makes the module very portable. It allows a developer to place the module in a different path to give it a different ID/name. The AMD loader will give the module an ID based on how it is referenced by other scripts.</p> <p>However, tools that combine multiple modules together for performance need a way to give names to each module in the optimized file. For that, AMD allows a string as the first argument to define():</p> <pre>//Calling define with module ID, dependency array, and factory function\ndefine('myModule', ['dep1', 'dep2'], function (dep1, dep2) {\n\n    //Define the module value by returning a value.\n    return function () {};\n});\n</pre> <p>You should avoid naming modules yourself, and only place one module in a file while developing. However, for tooling and performance, a module solution needs a way to identify modules in built resources.</p>   <h2 id=\"sugar\"> Sugar  </h2> <p>The above AMD example works in all browsers. However, there is a risk of mismatched dependency names with named function arguments, and it can start to look a bit strange if your module has many dependencies:</p> <pre>define([ \"require\", \"jquery\", \"blade/object\", \"blade/fn\", \"rdapi\",\n         \"oauth\", \"blade/jig\", \"blade/url\", \"dispatch\", \"accounts\",\n         \"storage\", \"services\", \"widgets/AccountPanel\", \"widgets/TabButton\",\n         \"widgets/AddAccount\", \"less\", \"osTheme\", \"jquery-ui-1.8.7.min\",\n         \"jquery.textOverflow\"],\nfunction (require,   $,        object,         fn,         rdapi,\n          oauth,   jig,         url,         dispatch,   accounts,\n          storage,   services,   AccountPanel,           TabButton,\n          AddAccount,           less,   osTheme) {\n\n});\n</pre> <p>To make this easier, and to make it easy to do a simple wrapping around CommonJS modules, this form of define is supported, sometimes referred to as \"simplified CommonJS wrapping\":</p> <pre>define(function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n</pre> <p>The AMD loader will parse out the require('') calls by using Function.prototype.toString(), then internally convert the above define call into this:</p> <pre>define(['require', 'dependency1', 'dependency2'], function (require) {\n    var dependency1 = require('dependency1'),\n        dependency2 = require('dependency2');\n\n    return function () {};\n});\n</pre> <p>This allows the loader to load dependency1 and dependency2 asynchronously, execute those dependencies, then execute this function.</p> <p>Not all browsers give a usable Function.prototype.toString() results. As of October 2011, the PS 3 and older Opera Mobile browsers do not. Those browsers are more likely to need an optimized build of the modules for network/device limitations, so just do a build with an optimizer that knows how to convert these files to the normalized dependency array form, like the <a href=\"optimization\">RequireJS optimizer</a>.</p> <p>Since the number of browsers that cannot support this toString() scanning is very small, it is safe to use this sugared form for all your modules, particularly if you like to line up the dependency names with the variables that will hold their module values.</p>   <h2 id=\"commonjscompat\"> CommonJS Compatibility  </h2> <p>Even though this sugared form is referred to as the \"simplified CommonJS wrapping\", it is not 100% compatible with CommonJS modules. However, the cases that are not supported would likely break in the browser anyway, since they generally assume synchronous loading of dependencies.</p> <p>Most CJS modules, around 95% based on my (thoroughly unscientific) personal experience, are perfectly compatible with the simplified CommonJS wrapping.</p> <p>The modules that break are ones that do a dynamic calculation of a dependency, anything that does not use a string literal for the require() call, and anything that does not look like a declarative require() call. So things like this fail:</p> <pre>//BAD\nvar mod = require(someCondition ? 'a' : 'b');\n\n//BAD\nif (someCondition) {\n    var a = require('a');\n} else {\n    var a = require('a1');\n}\n</pre> <p>These cases are handled by the <a href=\"https://github.com/amdjs/amdjs-api/wiki/require\">callback-require</a>, <code>require([moduleName], function (){})</code> normally present in AMD loaders.</p> <p>The AMD execution model is better aligned with how ECMAScript Harmony modules are being specified. The CommonJS modules that would not work in an AMD wrapper will also not work as a Harmony module. AMD's code execution behavior is more future compatible.</p> <h2>Verbosity vs. Usefulness</h2> <p>One of the criticisms of AMD, at least compared to CJS modules, is that it requires a level of indent and a function wrapping.</p> <p>But here is the plain truth: the perceived extra typing and a level of indent to use AMD does not matter. Here is where your time goes when coding:</p> <ul> <li>Thinking about the problem.</li> <li>Reading code.</li> </ul> <p>Your time coding is mostly spent thinking, not typing. While fewer words are generally preferable, there is a limit to that approach paying off, and the extra typing in AMD is not that much more.</p> <p>Most web developers use a function wrapper anyway, to avoid polluting the page with globals. Seeing a function wrapped around functionality is a very common sight and does not add to the reading cost of a module.</p> <p>There are also hidden costs with the CommonJS format:</p> <ul> <li>the tooling dependency cost</li> <li>edge cases that break in browsers, like cross-domain access</li> <li>worse debugging, a cost that continues to add up over time</li> </ul> <p>AMD modules require less tooling, there are fewer edge case issues, and better debugging support.</p> <p>What is important: being able to actually share code with others. AMD is the lowest energy pathway to that goal.</p> <p>Having a working, easy to debug module system that works in today's browsers means getting real world experience in making the best module system for JavaScript in the future.</p> <p>AMD and its related APIs, have helped show the following for any future JS module system:</p> <ul> <li>\n<strong>Returning a function as the module value</strong>, particularly a constructor function, leads to better API design. Node has module.exports to allow this, but being able to use \"return function (){}\" is much cleaner. It means not having to get a handle on \"module\" to do module.exports, and it is a clearer code expression.</li> <li>\n<strong>Dynamic code loading</strong> (done in AMD systems via <a href=\"https://github.com/amdjs/amdjs-api/wiki/require\">require([], function (){})</a>) is a basic requirement. CJS talked about it, had some proposals, but it was not fully embraced. Node does not have any support for this need, instead relying on the synchronous behavior of require(''), which is not portable to the web.</li> <li>\n<strong><a href=\"http://requirejs.org/docs/plugins.html\">Loader plugins</a></strong> are incredibly useful. It helps avoid the nested brace indenting common in callback-based programming.</li> <li>\n<strong>Selectively mapping one module</strong> to load from another location makes it easy to provide mock objects for testing.</li> <li>There should only be at most <strong>one IO action for each module</strong>, and it should be straightforward. Web browsers are not tolerant of multiple IO lookups to find a module. This argues against the multiple path lookups that Node does now, and avoiding the use of a package.json \"main\" property. Just use module names that map easily to one location based on the project's location, using a reasonable default convention that does not require verbose configuration, but allow for simple configuration when needed.</li> <li>It is best if there is an <strong>\"opt-in\" call</strong> that can be done so that older JS code can participate in the new system.</li> </ul> <p>If a JS module system cannot deliver on the above features, it is at a significant disadvantage when compared to AMD and its related APIs around <a href=\"https://github.com/amdjs/amdjs-api/wiki/require\">callback-require</a>, <a href=\"https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins\">loader plugins</a>, and paths-based module IDs.</p>   <h2 id=\"amdtoday\"> AMD Used Today  </h2> <p>As of mid-October 2011, AMD already has good adoption on the web:</p> <ul> <li>\n<a href=\"http://jquery.com/\">jQuery</a> 1.7</li> <li>\n<a href=\"http://dojotoolkit.org/\">Dojo</a> 1.7</li> <li><a href=\"http://uxebu.github.com/embedjs/\">EmbedJS</a></li> <li>\n<a href=\"http://enderjs.com/\">Ender</a>-associated modules like <a href=\"https://github.com/ded/bonzo\">bonzo</a>, <a href=\"https://github.com/ded/qwery\">qwery</a>, <a href=\"https://github.com/fat/bean\">bean</a> and <a href=\"https://github.com/ded/domready\">domready</a>\n</li> <li>Used by <a href=\"http://getfirebug.com/\">Firebug</a> 1.8+</li> <li>The simplified CommonJS wrapper can be used in <a href=\"https://addons.mozilla.org/en-US/developers/docs/sdk/1.1/\">Jetpack/Add-on SDK</a> for Firefox</li> <li>Used for parts of sites on <a href=\"http://www.bbc.co.uk/\">the BBC</a> (observed by looking at the source, not an official recommendation of AMD/RequireJS)</li> </ul>   <h2 id=\"youcando\"> What You Can Do  </h2> <p id=\"doapp\"><strong>If you write applications:</strong></p> <ul> <li>Give an AMD loader a try. You have some choices: <ul> <li><a href=\"http://requirejs.org\">RequireJS</a></li> <li><a href=\"https://github.com/cujojs/curl\">curl</a></li> <li><a href=\"https://github.com/zazl/lsjs\">lsjs</a></li> <li>\n<a href=\"http://dojotoolkit.org/\">Dojo</a> 1.7+</li> </ul>\n</li> <li>If you want to use AMD but still use the <strong>load one script at the bottom of the HTML page</strong> approach: <ul> <li>Use the <a href=\"http://requirejs.org/docs/optimization.html\">RequireJS optimizer</a> either in command line mode or as an <a href=\"https://github.com/requirejs/r.js/blob/master/build/tests/http/httpBuild.js\">HTTP service</a> with the <a href=\"https://github.com/requirejs/almond\">almond AMD shim</a>.</li> </ul>\n</li> </ul> <p id=\"dolib\"><strong>If you are a script/library author</strong>:</p> <ul> <li>\n<a href=\"https://github.com/umdjs/umd\">Optionally call define()</a> if it is available. The nice thing is you can still code your library without relying on AMD, just participate if it is available. This allows consumers of your modules to: <ul> <li>avoid dumping global variables in the page</li> <li>use more options for code loading, delayed loading</li> <li>use existing AMD tooling to optimize their project</li> <li>participate in a workable module system for JS in the browser today.</li> </ul>\n</li> </ul> <p id=\"doenv\"><strong>If you write code loaders/engines/environments for JavaScript:</strong></p> <ul> <li>Implement <a href=\"https://github.com/amdjs/amdjs-api/wiki/AMD\">the AMD API</a>. There is <a href=\"https://groups.google.com/group/amd-implement\">a discussion list</a> and <a href=\"https://github.com/amdjs/amdjs-tests\">compatibility tests</a>. By implementing AMD, you will reduce multi-module system boilerplate and help prove out a workable JavaScript module system on the web. This can be fed back into the ECMAScript process to build better native module support.</li> <li>Also support <a href=\"https://github.com/amdjs/amdjs-api/wiki/require\">callback-require</a> and <a href=\"https://github.com/amdjs/amdjs-api/wiki/Loader-Plugins\">loader plugins</a>. Loader plugins are a great way to reduce the nested callback syndrome that can be common in callback/async-style code.</li> </ul><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; jQuery Foundation and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://requirejs.org/docs/whyamd.html\" class=\"_attribution-link\">https://requirejs.org/docs/whyamd.html</a>\n  </p>\n</div>\n","index":"<h1>RequireJS API</h1>  <ul class=\"index mono\"> <li class=\"hbox\">\n<a href=\"#usage\">Usage</a>\n</li> <ul> <li class=\"hbox\">\n<a href=\"#jsfiles\">Load JavaScript Files</a>\n</li> <li class=\"hbox\">\n<a href=\"#data-main\">data-main Entry Point</a>\n</li> <li class=\"hbox\">\n<a href=\"#define\">Define a Module</a>\n</li> <ul> <li class=\"hbox\">\n<a href=\"#defsimple\">Simple Name/Value Pairs</a>\n</li> <li class=\"hbox\">\n<a href=\"#deffunc\">Definition Functions</a>\n</li> <li class=\"hbox\">\n<a href=\"#defdep\">Definition Functions with Dependencies</a>\n</li> <li class=\"hbox\">\n<a href=\"#funcmodule\">Define a Module as a Function</a>\n</li> <li class=\"hbox\">\n<a href=\"#cjsmodule\">Define a Module with Simplified CommonJS Wrapper</a>\n</li> <li class=\"hbox\">\n<a href=\"#modulename\">Define a Module with a name</a>\n</li> <li class=\"hbox\">\n<a href=\"#modulenotes\">Other Module Notes</a>\n</li> <li class=\"hbox\">\n<a href=\"#circular\">Circular Dependencies</a>\n</li> <li class=\"hbox\">\n<a href=\"#jsonp\">Specify a JSONP Service Dependency</a>\n</li> <li class=\"hbox\">\n<a href=\"#undef\">Undefining a Module</a>\n</li> </ul> </ul> <li class=\"hbox\">\n<a href=\"#mechanics\">Mechanics</a>\n</li> <li class=\"hbox\">\n<a href=\"#config\">Configuration Options</a>\n</li> <li class=\"hbox\">\n<a href=\"#advanced\">Advanced Usage</a>\n</li> <ul> <li class=\"hbox\">\n<a href=\"#packages\">Loading Modules from Packages</a>\n</li> <li class=\"hbox\">\n<a href=\"#multiversion\">Multiversion Support</a>\n</li> <li class=\"hbox\">\n<a href=\"#afterload\">Loading Code After Page Load</a>\n</li> <li class=\"hbox\">\n<a href=\"#webworker\">Web Worker Support</a>\n</li> <li class=\"hbox\">\n<a href=\"#rhino\">Rhino Support</a>\n</li> <li class=\"hbox\">\n<a href=\"#nashorn\">Nashorn Support</a>\n</li> <li class=\"hbox\">\n<a href=\"#errors\">Handling Errors</a>\n</li> </ul> <li class=\"hbox\">\n<a href=\"#plugins\">Loader Plugins</a>\n</li> <ul> <li class=\"hbox\">\n<a href=\"#text\">Specify a Text File Dependency</a>\n</li> <li class=\"hbox\">\n<a href=\"#pageload\">Page Load Event Support/DOM Ready</a>\n</li> <li class=\"hbox\">\n<a href=\"#i18n\">Define an I18N Bundle</a>\n</li> </ul> </ul>   <h2 id=\"usage\"> Usage  </h2> <h3 id=\"jsfiles\"> Load JavaScript Files  </h3> <p>RequireJS takes a different approach to script loading than traditional &lt;script&gt; tags. While it can also run fast and optimize well, the primary goal is to encourage modular code. As part of that, it encourages using <strong>module IDs</strong> instead of URLs for script tags.</p> <p>RequireJS loads all code relative to a <a href=\"#config-baseUrl\">baseUrl</a>. The baseUrl is normally set to the same directory as the script used in a data-main attribute for the top level script to load for a page. The <a href=\"#data-main\">data-main attribute</a> is a special attribute that require.js will check to start script loading. This example will end up with a baseUrl of <strong>scripts</strong>:</p> <pre>&lt;!--This sets the baseUrl to the \"scripts\" directory, and\n    loads a script that will have a module ID of 'main'--&gt;\n&lt;script data-main=\"scripts/main.js\" src=\"scripts/require.js\"&gt;&lt;/script&gt;\n</pre> <p>Or, baseUrl can be set manually via the <a href=\"#config\">RequireJS config</a>. If there is no explicit config and data-main is not used, then the default baseUrl is the directory that contains the HTML page running RequireJS.</p> <p>RequireJS also assumes by default that all dependencies are scripts, so it does not expect to see a trailing \".js\" suffix on module IDs. RequireJS will automatically add it when translating the module ID to a path. With the <a href=\"#config-paths\">paths config</a>, you can set up locations of a group of scripts. All of these capabilities allow you to use smaller strings for scripts as compared to traditional &lt;script&gt; tags.</p> <p>There may be times when you do want to reference a script directly and not conform to the \"baseUrl + paths\" rules for finding it. If a module ID has one of the following characteristics, the ID will not be passed through the \"baseUrl + paths\" configuration, and just be treated like a regular URL that is relative to the document:</p> <ul> <li>Ends in \".js\".</li> <li>Starts with a \"/\".</li> <li>Contains an URL protocol, like \"http:\" or \"https:\".</li> </ul> <p>In general though, it is best to use the baseUrl and \"paths\" config to set paths for module IDs. By doing so, it gives you more flexibility in renaming and configuring the paths to different locations for optimization builds.</p> <p>Similarly, to avoid a bunch of configuration, it is best to avoid deep folder hierarchies for scripts, and instead either keep all the scripts in baseUrl, or if you want to separate your library/vendor-supplied code from your app code, use a directory layout like this:</p> <ul> <li>www/ <ul> <li>index.html</li> <li>js/ <ul> <li>app/ <ul> <li>sub.js</li> </ul> </li> <li>lib/ <ul> <li>jquery.js</li> <li>canvas.js</li> </ul>\n</li> <li>app.js</li> <li>require.js</li> </ul>\n</li> </ul>\n</li> </ul> <p>in index.html:</p> <pre>&lt;script data-main=\"js/app.js\" src=\"js/require.js\"&gt;&lt;/script&gt;</pre> <p>and in app.js:</p> <pre>requirejs.config({\n    //By default load any module IDs from js/lib\n    baseUrl: 'js/lib',\n    //except, if the module ID starts with \"app\",\n    //load it from the js/app directory. paths\n    //config is relative to the baseUrl, and\n    //never includes a \".js\" extension since\n    //the paths config could be for a directory.\n    paths: {\n        app: '../app'\n    }\n});\n\n// Start the main app logic.\nrequirejs(['jquery', 'canvas', 'app/sub'],\nfunction   ($,        canvas,   sub) {\n    //jQuery, canvas and the app/sub module are all\n    //loaded and can be used here now.\n});\n</pre> <p>Notice as part of that example, vendor libraries like jQuery did not have their version numbers in their file names. It is recommended to store that version info in a separate text file if you want to track it, or if you use a tool like <a href=\"https://github.com/volojs/volo\">volo</a>, it will stamp the package.json with the version information but keep the file on disk as \"jquery.js\". This allows you to have the very minimal configuration instead of having to put an entry in the \"paths\" config for each library. For instance, configure \"jquery\" to be \"jquery-1.7.2\".</p> <p>Ideally the scripts you load will be modules that are defined by calling <a href=\"#define\">define()</a>. However, you may need to use some traditional/legacy \"browser globals\" scripts that do not express their dependencies via define(). For those, you can use the <a href=\"#config-shim\">shim config</a>. To properly express their dependencies.</p> <p>If you do not express the dependencies, you will likely get loading errors since RequireJS loads scripts asynchronously and out of order for speed.</p> <h3 id=\"data-main\"> data-main Entry Point  </h3> <p>The data-main attribute is a special attribute that require.js will check to start script loading:</p> <pre>&lt;!--when require.js loads it will inject another script tag\n    (with async attribute) for scripts/main.js--&gt;\n&lt;script data-main=\"scripts/main\" src=\"scripts/require.js\"&gt;&lt;/script&gt;\n</pre> <p>You will typically use a data-main script to <a href=\"#config\">set configuration options</a> and then load the first application module. Note: the script tag require.js generates for your data-main module includes the <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-async\">async attribute</a>. This means that <strong>you cannot assume that the load and execution of your data-main script will finish prior to other scripts referenced later in the same page.</strong></p> <p>For example, this arrangement will fail randomly when the require.config path for the 'foo' module has not been set prior to it being require()'d later:</p> <pre>&lt;script data-main=\"scripts/main\" src=\"scripts/require.js\"&gt;&lt;/script&gt;\n&lt;script src=\"scripts/other.js\"&gt;&lt;/script&gt;\n</pre> <pre>// contents of main.js:\nrequire.config({\n    paths: {\n        foo: 'libs/foo-1.1.3'\n    }\n});\n</pre> <pre>// contents of other.js:\n\n// This code might be called before the require.config() in main.js\n// has executed. When that happens, require.js will attempt to\n// load 'scripts/foo.js' instead of 'scripts/libs/foo-1.1.3.js'\nrequire(['foo'], function(foo) {\n\n});\n</pre> <p>If you want to do <code>require()</code> calls in the HTML page, then it is best to not use data-main. data-main is only intended for use when the page just has one main entry point, the data-main script. For pages that want to do inline <code>require()</code> calls, it is best to nest those inside a <code>require()</code> call for the configuration:</p> <pre>&lt;script src=\"scripts/require.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\nrequire(['scripts/config'], function() {\n    // Configuration loaded now, safe to do other require calls\n    // that depend on that config.\n    require(['foo'], function(foo) {\n\n    });\n});\n&lt;/script&gt;\n</pre> <h3 id=\"define\"> Define a Module  </h3> <p>A module is different from a traditional script file in that it defines a well-scoped object that avoids polluting the global namespace. It can explicitly list its dependencies and get a handle on those dependencies without needing to refer to global objects, but instead receive the dependencies as arguments to the function that defines the module. Modules in RequireJS are an extension of the <a href=\"http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth\">Module Pattern</a>, with the benefit of not needing globals to refer to other modules.</p> <p>The RequireJS syntax for modules allows them to be loaded as fast as possible, even out of order, but evaluated in the correct dependency order, and since global variables are not created, it makes it possible to <a href=\"#multiversion\">load multiple versions of a module in a page</a>.</p> <p>(If you are familiar with or are using CommonJS modules, then please also see <a href=\"commonjs\">CommonJS Notes</a> for information on how the RequireJS module format maps to CommonJS modules).</p> <p>There should only be <strong>one</strong> module definition per file on disk. The modules can be grouped into optimized bundles by the <a href=\"optimization\">optimization tool</a>.</p> <div class=\"subSection\"> <h4 id=\"defsimple\"> Simple Name/Value Pairs  </h4> <p>If the module does not have any dependencies, and it is just a collection of name/value pairs, then just pass an object literal to define():</p> <pre>//Inside file my/shirt.js:\ndefine({\n    color: \"black\",\n    size: \"unisize\"\n});\n</pre> </div> <div class=\"subSection\"> <h4 id=\"deffunc\"> Definition Functions  </h4> <p>If the module does not have dependencies, but needs to use a function to do some setup work, then define itself, pass a function to define():</p> <pre>//my/shirt.js now does setup work\n//before returning its module definition.\ndefine(function () {\n    //Do setup work here\n\n    return {\n        color: \"black\",\n        size: \"unisize\"\n    }\n});\n</pre> </div> <div href=\"#subSection\" class=\"subSection\"> <h4 id=\"defdep\">Definition Functions with Dependencies</h4> <p>If the module has dependencies, the first argument should be an array of dependency names, and the second argument should be a definition function. The function will be called to define the module once all dependencies have loaded. The function should return an object that defines the module. The dependencies will be passed to the definition function as function arguments, listed in the same order as the order in the dependency array:</p> <pre>//my/shirt.js now has some dependencies, a cart and inventory\n//module in the same directory as shirt.js\ndefine([\"./cart\", \"./inventory\"], function(cart, inventory) {\n        //return an object to define the \"my/shirt\" module.\n        return {\n            color: \"blue\",\n            size: \"large\",\n            addToCart: function() {\n                inventory.decrement(this);\n                cart.add(this);\n            }\n        }\n    }\n);\n</pre> <p>In this example, a my/shirt module is created. It depends on my/cart and my/inventory. On disk, the files are structured like this:</p> <ul> <li>my/cart.js</li> <li>my/inventory.js</li> <li>my/shirt.js</li> </ul> <p>The function call above specifies two arguments, \"cart\" and \"inventory\". These are the modules represented by the \"./cart\" and \"./inventory\" module names.</p> <p>The function is not called until the my/cart and my/inventory modules have been loaded, and the function receives the modules as the \"cart\" and \"inventory\" arguments.</p> <p>Modules that define globals are explicitly discouraged, so that multiple versions of a module can exist in a page at a time (see <strong>Advanced Usage</strong>). Also, the order of the function arguments should match the order of the dependencies.</p> <p>The return object from the function call defines the \"my/shirt\" module. By defining modules in this way, \"my/shirt\" does not exist as a global object.</p> </div> <div class=\"subSection\"> <h4 id=\"funcmodule\">Define a Module as a Function</h4> <p>Modules do not have to return objects. Any valid return value from a function is allowed. Here is a module that returns a function as its module definition:</p> <pre>//A module definition inside foo/title.js. It uses\n//my/cart and my/inventory modules from before,\n//but since foo/title.js is in a different directory than\n//the \"my\" modules, it uses the \"my\" in the module dependency\n//name to find them. The \"my\" part of the name can be mapped\n//to any directory, but by default, it is assumed to be a\n//sibling to the \"foo\" directory.\ndefine([\"my/cart\", \"my/inventory\"],\n    function(cart, inventory) {\n        //return a function to define \"foo/title\".\n        //It gets or sets the window title.\n        return function(title) {\n            return title ? (window.title = title) :\n                   inventory.storeName + ' ' + cart.name;\n        }\n    }\n);\n</pre> </div> <div class=\"subSection\"> <h4 id=\"cjsmodule\">Define a Module with Simplified CommonJS Wrapper</h4> <p>If you wish to reuse some code that was written in the traditional <a href=\"http://wiki.commonjs.org/wiki/Modules/1.1.1\">CommonJS module format</a> it may be difficult to re-work to the array of dependencies used above, and you may prefer to have direct alignment of dependency name to the local variable used for that dependency. You can use the <a href=\"commonjs\">simplified CommonJS wrapper</a> for those cases:</p> <pre>define(function(require, exports, module) {\n        var a = require('a'),\n            b = require('b');\n\n        //Return the module value\n        return function () {};\n    }\n);\n</pre> <p>This wrapper relies on Function.prototype.toString() to give a useful string value of the function contents. This does not work on some devices like the PS3 and some older Opera mobile browsers. Use the <a href=\"optimization\">optimizer</a> to pull out the dependencies in the array format for use on those devices.</p> <p>More information is available on the <a href=\"commonjs\">CommonJS page</a>, and in the <a href=\"whyamd#sugar\">\"Sugar\" section in the Why AMD page</a>. </p>\n</div> <div class=\"subSection\"> <h4 id=\"modulename\">Define a Module with a Name</h4> <p>You may encounter some define() calls that include a name for the module as the first argument to define():</p> <pre>    //Explicitly defines the \"foo/title\" module:\n    define(\"foo/title\",\n        [\"my/cart\", \"my/inventory\"],\n        function(cart, inventory) {\n            //Define foo/title object in here.\n       }\n    );\n</pre> <p>These are normally generated by the <a href=\"optimization\">optimization tool</a>. You can explicitly name modules yourself, but it makes the modules less portable -- if you move the file to another directory you will need to change the name. It is normally best to avoid coding in a name for the module and just let the optimization tool burn in the module names. The optimization tool needs to add the names so that more than one module can be bundled in a file, to allow for faster loading in the browser.</p> </div> <div class=\"subSection\"> <h4 id=\"modulenotes\">Other Module Notes</h4> <p id=\"modulenotes-onemodule\"><strong>One module per file.</strong>: Only one module should be defined per JavaScript file, given the nature of the module name-to-file-path lookup algorithm. You shoud only use the <a href=\"optimization\">optimization tool</a> to group multiple modules into optimized files.</p> <p id=\"modulenotes-relative\"><strong>Relative module names inside define()</strong>: For require(\"./relative/name\") calls that can happen inside a define() function call, be sure to ask for \"require\" as a dependency, so that the relative name is resolved correctly:</p> <pre>define([\"require\", \"./relative/name\"], function(require) {\n    var mod = require(\"./relative/name\");\n});\n</pre> <p>Or better yet, use the shortened syntax that is available for use with <a href=\"commonjs\">translating CommonJS</a> modules:</p> <pre>define(function(require) {\n    var mod = require(\"./relative/name\");\n});\n</pre> <p>This form will use Function.prototype.toString() to find the require() calls, and add them to the dependency array, along with \"require\", so the code will work correctly with relative paths.</p> <p>Relative paths are really useful if you are creating a few modules inside a directory, so that you can share the directory with other people or other projects, and you want to be able to get a handle on the sibling modules in that directory without having to know the directory's name.</p> <p id=\"modulenotes-relative-names\"><strong>Relative module names are relative to other names, not paths</strong>: The loader stores modules by their name and not by their path internally. So for relative name references, those are resolved relative to the module name making the reference, then that module name, or ID, is converted to a path if needs to be loaded. Example code for a 'compute' package that has a 'main' and 'extras' modules in it:</p> <pre>* lib/\n    * compute/\n        * main.js\n        * extras.js\n</pre> <p>where the main.js module looks like this:</p> <pre>define([\"./extras\"], function(extras) {\n    //Uses extras in here.\n});\n</pre> <p>If this was the paths config:</p> <pre>require.config({\n    baseUrl: 'lib',\n    paths: {\n      'compute': 'compute/main'\n    }\n});\n</pre> <p>And a <code>require(['compute'])</code> is done, then lib/compute/main.js will have the module name of 'compute'. When it asks for './extras', that is resolved relative to 'compute', so 'compute/./extras', which normalizes to just 'extras'. Since there is no paths config for that module name, the path generated will be for 'lib/extras.js', which is incorrect.</p> <p>For this case, <a href=\"#packages\">packages config</a> is a better option, since it allows setting the main module up as 'compute', but internally the loader will store the module with the ID of 'compute/main' so that the relative reference for './extras' works.</p> <p>Another option is to construct a module at lib/compute.js that is just <code>define(['./compute/main'], function(m) { return m; });</code>, then there is no need for paths or packages config.</p> <p>Or, do not set that paths or packages config and do the top level require call as <code>require(['compute/main'])</code>.</p> <p id=\"modulenotes-urls\"><strong>Generate URLs relative to module</strong>: You may need to generate an URL that is relative to a module. To do so, ask for \"require\" as a dependency and then use require.toUrl() to generate the URL:</p> <pre>define([\"require\"], function(require) {\n    var cssUrl = require.toUrl(\"./style.css\");\n});\n</pre> <p id=\"modulenotes-console\"><strong>Console debugging</strong>: If you need to work with a module you already loaded via a <code>require([\"module/name\"], function(){})</code> call in the JavaScript console, then you can use the require() form that just uses the string name of the module to fetch it:</p> <pre>require(\"module/name\").callSomeFunction()\n</pre> <p>Note this only works if \"module/name\" was previously loaded via the async version of require: <code>require([\"module/name\"])</code>. If using a relative path, like './module/name', those only work inside define</p> </div> <div class=\"subSection\"> <h4 id=\"circular\">Circular Dependencies</h4> <p>If you define a circular dependency (\"a\" needs \"b\" and \"b\" needs \"a\"), then in this case when \"b\"'s module function is called, it will get an undefined value for \"a\". \"b\" can fetch \"a\" later after modules have been defined by using the require() method (be sure to specify require as a dependency so the right context is used to look up \"a\"):</p> <pre>//Inside b.js:\ndefine([\"require\", \"a\"],\n    function(require, a) {\n        //\"a\" in this case will be null if \"a\" also asked for \"b\",\n        //a circular dependency.\n        return function(title) {\n            return require(\"a\").doSomething();\n        }\n    }\n);\n</pre> <p>Normally you should not need to use require() to fetch a module, but instead rely on the module being passed in to the function as an argument. Circular dependencies are rare, and usually a sign that you might want to rethink the design. However, sometimes they are needed, and in that case, use require() as specified above.</p> <p>If you are familiar with CommonJS modules, you could instead use <strong>exports</strong> to create an empty object for the module that is available immediately for reference by other modules. By doing this on both sides of a circular dependency, you can then safely hold on to the the other module. This only works if each module is exporting an object for the module value, not a function:</p> <pre>//Inside b.js:\ndefine(function(require, exports, module) {\n    //If \"a\" has used exports, then we have a real\n    //object reference here. However, we cannot use\n    //any of \"a\"'s properties until after \"b\" returns a value.\n    var a = require(\"a\");\n\n    exports.foo = function () {\n        return a.bar();\n    };\n});\n</pre> <p>Or, if you are using the dependency array approach, ask for the special <a href=\"https://github.com/requirejs/requirejs/wiki/Differences-between-the-simplified-CommonJS-wrapper-and-standard-AMD-define#wiki-magic\">'exports' dependency:</a></p> <pre>//Inside b.js:\ndefine(['a', 'exports'], function(a, exports) {\n    //If \"a\" has used exports, then we have a real\n    //object reference here. However, we cannot use\n    //any of \"a\"'s properties until after \"b\" returns a value.\n\n    exports.foo = function () {\n        return a.bar();\n    };\n});\n</pre> </div> <div class=\"subSection\"> <h4 id=\"jsonp\">Specify a JSONP Service Dependency</h4> <p><a href=\"http://en.wikipedia.org/wiki/JSON#JSONP\">JSONP</a> is a way of calling some services in JavaScript. It works across domains and it is an established approach to calling services that just require an HTTP GET via a script tag.</p> <p>To use a JSONP service in RequireJS, specify \"define\" as the callback parameter's value. This means you can get the value of a JSONP URL as if it was a module definition.</p> <p>Here is an example that calls a JSONP API endpoint. In this example, the JSONP callback parameter is called \"callback\", so \"callback=define\" tells the API to wrap the JSON response in a \"define()\" wrapper:</p> <pre>require([\"http://example.com/api/data.json?callback=define\"],\n    function (data) {\n        //The data object will be the API response for the\n        //JSONP data call.\n        console.log(data);\n    }\n);\n</pre> <p>This use of JSONP should be limited to JSONP services for initial application setup. If the JSONP service times out, it means other modules you define via define() may not get executed, so the error handling is not robust.</p> <p><strong>Only JSONP return values that are JSON objects are supported</strong>. A JSONP response that is an array, a string or a number will not work.</p> <p>This functionality should not be used for long-polling JSONP connections -- APIs that deal with real time streaming. Those kinds of APIs should do more script cleanup after receiving each response, and RequireJS will only fetch a JSONP URL once -- subsequent uses of the same URL as a dependency in a require() or define() call will get a cached value.</p> <p>Errors in loading a JSONP service are normally surfaced via timeouts for the service, since script tag loading does not give much detail into network problems. To detect errors, you can override requirejs.onError() to get errors. There is more information in the <a href=\"#errors\">Handling Errors</a> section.</p> </div> <div class=\"subSection\"> <h4 id=\"undef\">Undefining a Module</h4> <p>There is a global function, <b>requirejs.undef()</b>, that allows undefining a module. It will reset the loader's internal state to forget about the previous definition of the module.</p> <p><b>However</b>, it will not remove the module from other modules that are already defined and got a handle on that module as a dependency when they executed. So it is really only useful to use in error situations when no other modules have gotten a handle on a module value, or as part of any future module loading that may use that module. See the <a href=\"#errbacks\">errback section</a> for an example.</p> <p>If you want to do more sophisticated dependency graph analysis for undefining work, the semi-private <a href=\"https://github.com/requirejs/requirejs/wiki/Internal-API:-onResourceLoad\">onResourceLoad API</a> may be helpful.</p> </div>   <h2 id=\"mechanics\"> Mechanics  </h2> <p>RequireJS loads each dependency as a script tag, using head.appendChild().</p> <p>RequireJS waits for all dependencies to load, figures out the right order in which to call the functions that define the modules, then calls the module definition functions once the dependencies for those functions have been called. Note that the dependencies for a given module definition function could be called in any order, due to their sub-dependency relationships and network load order.</p> <p>Using RequireJS in a server-side JavaScript environment that has synchronous loading should be as easy as redefining require.load(). The build system does this, the require.load method for that environment can be found in build/jslib/requirePatch.js.</p> <p>In the future, this code may be pulled into the require/ directory as an optional module that you can load in your env to get the right load behavior based on the host environment.</p>   <h2 id=\"config\"> Configuration Options  </h2> <p>When using require() in the top-level HTML page (or top-level script file that does not define a module), a configuration object can be passed as the first option:</p> <pre>&lt;script src=\"scripts/require.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\n  require.config({\n    baseUrl: \"/another/path\",\n    paths: {\n        \"some\": \"some/v1.0\"\n    },\n    waitSeconds: 15\n  });\n  require( [\"some/module\", \"my/module\", \"a.js\", \"b.js\"],\n    function(someModule,    myModule) {\n        //This function will be called when all the dependencies\n        //listed above are loaded. Note that this function could\n        //be called before the page is loaded.\n        //This callback is optional.\n    }\n  );\n&lt;/script&gt;\n</pre> <p>You may also call require.config from your <a href=\"api#data-main\">data-main Entry Point</a>, but be aware that the data-main script is loaded asynchronously. Avoid other entry point scripts which wrongly assume that data-main and its require.config will always execute prior to their script loading.</p> <p>Also, you can define the config object as the global variable <code>require</code> <strong>before</strong> require.js is loaded, and have the values applied automatically. This example specifies some dependencies to load as soon as require.js defines require():</p> <pre>&lt;script&gt;\n    var require = {\n        deps: [\"some/module1\", \"my/module2\", \"a.js\", \"b.js\"],\n        callback: function(module1, module2) {\n            //This function will be called when all the dependencies\n            //listed above in deps are loaded. Note that this\n            //function could be called before the page is loaded.\n            //This callback is optional.\n        }\n    };\n&lt;/script&gt;\n&lt;script src=\"scripts/require.js\"&gt;&lt;/script&gt;\n</pre> <p><b>Note:</b> It is best to use <code>var require = {}</code> and do not use <code>window.require = {}</code>, it will not behave correctly in IE.</p> <p>There are <a href=\"https://github.com/requirejs/requirejs/wiki/Patterns-for-separating-config-from-the-main-module\">some patterns for separating the config from main module loading</a>.</p> <p>Supported configuration options:</p> <p id=\"config-baseUrl\"><strong><a href=\"#config-baseUrl\">baseUrl</a></strong>: the root path to use for all module lookups. So in the above example, \"my/module\"'s script tag will have a src=\"/another/path/my/module.js\". baseUrl is <strong>not</strong> used when loading plain .js files (indicated by a dependency string <a href=\"#jsfiles\">starting with a slash, has a protocol, or ends in .js</a>), those strings are used as-is, so a.js and b.js will be loaded from the same directory as the HTML page that contains the above snippet.</p> <p>If no baseUrl is explicitly set in the configuration, the default value will be the location of the HTML page that loads require.js. If a <strong>data-main</strong> attribute is used, that path will become the baseUrl.</p> <p>The baseUrl can be a URL on a different domain as the page that will load require.js. RequireJS script loading works across domains. The only restriction is on text content loaded by text! plugins: those paths should be on the same domain as the page, at least during development. The optimization tool will inline text! plugin resources so after using the optimization tool, you can use resources that reference text! plugin resources from another domain.</p> <p id=\"config-paths\"><strong><a href=\"#config-paths\">paths</a></strong>: path mappings for module names not found directly under baseUrl. The path settings are assumed to be relative to baseUrl, unless the paths setting starts with a \"/\" or has a URL protocol in it (\"like http:\"). Using the above sample config, \"some/module\"'s script tag will be src=\"/another/path/some/v1.0/module.js\".</p> <p>The path that is used for a module name should <strong>not</strong> include an extension, since the path mapping could be for a directory. The path mapping code will automatically add the .js extension when mapping the module name to a path. If <a href=\"#modulenotes-urls\">require.toUrl()</a> is used, it will add the appropriate extension, if it is for something like a text template.</p> <p>When run in a browser, <a href=\"#pathsfallbacks\">paths fallbacks</a> can be specified, to allow trying a load from a CDN location, but falling back to a local location if the CDN location fails to load.</p> <p id=\"config-bundles\"><strong><a href=\"#config-bundles\">bundles</a></strong>: Introduced in RequireJS 2.1.10: allows configuring multiple module IDs to be found in another script. Example:</p> <pre>requirejs.config({\n    bundles: {\n        'primary': ['main', 'util', 'text', 'text!template.html'],\n        'secondary': ['text!secondary.html']\n    }\n});\n\nrequire(['util', 'text'], function(util, text) {\n    //The script for module ID 'primary' was loaded,\n    //and that script included the define()'d\n    //modules for 'util' and 'text'\n});\n</pre> <p>That config states: modules 'main', 'util', 'text' and 'text!template.html' will be found by loading module ID 'primary'. Module 'text!secondary.html' can be found by loading module ID 'secondary'. </p> <p>This only sets up where to find a module inside a script that has multiple define()'d modules in it. It does not automatically bind those modules to the bundle's module ID. The bundle's module ID is just used for locating the set of modules.</p> <p>Something similar is possible with paths config, but it is much wordier, and the paths config route does not allow loader plugin resource IDs in its configuration, since the paths config values are path segments, not IDs.</p> <p>bundles config is useful if doing a build and that build target was not an existing module ID, or if you have loader plugin resources in built JS files that should not be loaded by the loader plugin. <strong>Note that the keys and values are module IDs</strong>, not path segments. They are absolute module IDs, not a module ID prefix like <a href=\"#config-paths\">paths config</a> or <a href=\"#config-map\">map config</a>. Also, bundle config is different from map config in that map config is a one-to-one module ID relationship, where bundle config is for pointing multiple module IDs to a bundle's module ID.</p> <p>As of RequireJS 2.2.0, the optimizer can generate the bundles config and insert it into the top level requirejs.config() call. See the <a href=\"https://github.com/requirejs/r.js/blob/98a9949480d68a781c8d6fc4ce0a07c16a2c8a2a/build/example.build.js#L641\">bundlesConfigOutFile</a> build config option for more details.</p> <p id=\"config-shim\"><strong><a href=\"#config-shim\">shim</a></strong>: Configure the dependencies, exports, and custom initialization for older, traditional \"browser globals\" scripts that do not use define() to declare the dependencies and set a module value.</p> <p>Here is an example. It requires RequireJS 2.1.0+, and assumes backbone.js, underscore.js and jquery.js have been installed in the baseUrl directory. If not, then you may need to set a paths config for them:</p> <pre>requirejs.config({\n    //Remember: only use shim config for non-AMD scripts,\n    //scripts that do not already call define(). The shim\n    //config will not work correctly if used on AMD scripts,\n    //in particular, the exports and init config will not\n    //be triggered, and the deps config will be confusing\n    //for those cases.\n    shim: {\n        'backbone': {\n            //These script dependencies should be loaded before loading\n            //backbone.js\n            deps: ['underscore', 'jquery'],\n            //Once loaded, use the global 'Backbone' as the\n            //module value.\n            exports: 'Backbone'\n        },\n        'underscore': {\n            exports: '_'\n        },\n        'foo': {\n            deps: ['bar'],\n            exports: 'Foo',\n            init: function (bar) {\n                //Using a function allows you to call noConflict for\n                //libraries that support it, and do other cleanup.\n                //However, plugins for those libraries may still want\n                //a global. \"this\" for the function will be the global\n                //object. The dependencies will be passed in as\n                //function arguments. If this function returns a value,\n                //then that value is used as the module export value\n                //instead of the object found via the 'exports' string.\n                //Note: jQuery registers as an AMD module via define(),\n                //so this will not work for jQuery. See notes section\n                //below for an approach for jQuery.\n                return this.Foo.noConflict();\n            }\n        }\n    }\n});\n\n//Then, later in a separate file, call it 'MyModel.js', a module is\n//defined, specifying 'backbone' as a dependency. RequireJS will use\n//the shim config to properly load 'backbone' and give a local\n//reference to this module. The global Backbone will still exist on\n//the page too.\ndefine(['backbone'], function (Backbone) {\n  return Backbone.Model.extend({});\n});\n</pre> <p>In RequireJS 2.0.*, the \"exports\" property in the shim config could have been a function instead of a string. In that case, it functioned the same as the \"init\" property as shown above. The \"init\" pattern is used in RequireJS 2.1.0+ so a string value for <code>exports</code> can be used for <a href=\"#config-enforceDefine\">enforceDefine</a>, but then allow functional work once the library is known to have loaded.</p> <p>For \"modules\" that are just jQuery or Backbone plugins that do not need to export any module value, the shim config can just be an array of dependencies:</p> <pre>requirejs.config({\n    shim: {\n        'jquery.colorize': ['jquery'],\n        'jquery.scroll': ['jquery'],\n        'backbone.layoutmanager': ['backbone']\n    }\n});\n</pre> <p>Note however if you want to get 404 load detection in IE so that you can use paths fallbacks or errbacks, then a string exports value should be given so the loader can check if the scripts actually loaded (a return from init is <strong>not</strong> used for <code>enforceDefine</code> checking):</p> <pre>requirejs.config({\n    shim: {\n        'jquery.colorize': {\n            deps: ['jquery'],\n            exports: 'jQuery.fn.colorize'\n        },\n        'jquery.scroll': {\n            deps: ['jquery'],\n            exports: 'jQuery.fn.scroll'\n        },\n        'backbone.layoutmanager': {\n            deps: ['backbone']\n            exports: 'Backbone.LayoutManager'\n        }\n    }\n});\n</pre> <p><b>Important notes for \"shim\" config:</b></p> <ul> <li>The shim config only sets up code relationships. To load modules that are part of or use shim config, a normal require/define call is needed. Setting shim by itself does not trigger code to load.</li> <li>Only use other \"shim\" modules as dependencies for shimmed scripts, or AMD libraries that have no dependencies and call define() after they also create a global (like jQuery or lodash). Otherwise, if you use an AMD module as a dependency for a shim config module, after a build, that AMD module may not be evaluated until after the shimmed code in the build executes, and an error will occur. The ultimate fix is to upgrade all the shimmed code to have optional AMD define() calls.</li> <li>If it is not possible to upgrade the shimmed code to use AMD define() calls, as of RequireJS 2.1.11, the optimizer has a <a href=\"https://github.com/requirejs/r.js/blob/b8a6982d2923ae8389355edaa50d2b7f8065a01a/build/example.build.js#L68\">wrapShim build option</a> that will try to automatically wrap the shimmed code in a define() for a build. This changes the scope of shimmed dependencies, so it is not guaranteed to always work, but, for example, for shimmed dependencies that depend on an AMD version of Backbone, it can be helpful.</li> <li>The init function will <strong>not</strong> be called for AMD modules. For example, you cannot use a shim init function to call jQuery's noConflict. See <a href=\"jquery#noconflictmap\">Mapping Modules to use noConflict</a> for an alternate approach to jQuery.</li> <li>Shim config is not supported when running AMD modules in node via RequireJS (it works for optimizer use though). Depending on the module being shimmed, it may fail in Node because Node does not have the same global environment as browsers. As of RequireJS 2.1.7, it will warn you in the console that shim config is not supported, and it may or may not work. If you wish to suppress that message, you can pass <code>requirejs.config({ suppress: { nodeShim: true }});</code>.</li> </ul> <p><b>Important optimizer notes for \"shim\" config</b>:</p> <ul> <li>You should use the <a href=\"optimization#mainConfigFile\">mainConfigFile build option</a> to specify the file where to find the shim config. Otherwise the optimizer will not know of the shim config. The other option is to duplicate the shim config in the build profile.</li> <li>Do not mix CDN loading with shim config in a build. Example scenario: you load jQuery from the CDN but use the shim config to load something like the stock version of Backbone that depends on jQuery. When you do the build, be sure to inline jQuery in the built file and do not load it from the CDN. Otherwise, Backbone will be inlined in the built file and it will execute before the CDN-loaded jQuery will load. This is because the shim config just delays loading of the files until dependencies are loaded, but does not do any auto-wrapping of define. After a build, the dependencies are already inlined, the shim config cannot delay execution of the non-define()'d code until later. define()'d modules do work with CDN loaded code after a build because they properly wrap their source in define factory function that will not execute until dependencies are loaded. So the lesson: shim config is a stop-gap measure for non-modular code, legacy code. define()'d modules are better.</li> <li>For local, multi-file builds, the above CDN advice also applies. For any shimmed script, its dependencies <strong>must</strong> be loaded before the shimmed script executes. This means either building its dependencies directly in the buid layer that includes the shimmed script, or loading its dependencies with a <code>require([], function (){})</code> call, then doing a nested <code>require([])</code> call for the build layer that has the shimmed script.</li> <li>If you are using uglifyjs to minify the code, <strong>do not</strong> set the uglify option <code>toplevel</code> to true, or if using the command line <strong>do not</strong> pass <code>-mt</code>. That option mangles the global names that shim uses to find exports.</li> </ul> <p id=\"config-map\"><strong><a href=\"#config-map\">map</a></strong>: For the given module prefix, instead of loading the module with the given ID, substitute a different module ID.</p> <p>This sort of capability is really important for larger projects which may have two sets of modules that need to use two different versions of 'foo', but they still need to cooperate with each other.</p> <p>This is not possible with the <a href=\"#multiversion\">context-backed multiversion support</a>. In addition, the <a href=\"#config-paths\">paths config</a> is only for setting up root paths for module IDs, not for mapping one module ID to another one.</p> <p>map example:</p> <pre>requirejs.config({\n    map: {\n        'some/newmodule': {\n            'foo': 'foo1.2'\n        },\n        'some/oldmodule': {\n            'foo': 'foo1.0'\n        }\n    }\n});\n</pre> <p>If the modules are laid out on disk like this:</p> <ul> <li>foo1.0.js</li> <li>foo1.2.js</li> <li>some/ <ul> <li>newmodule.js</li> <li>oldmodule.js</li> </ul> </li> </ul> <p>When 'some/newmodule' does `require('foo')` it will get the foo1.2.js file, and when 'some/oldmodule' does `require('foo')` it will get the foo1.0.js file.</p> <p>This feature only works well for scripts that are real AMD modules that call define() and register as anonymous modules. Also, <strong>only use absolute module IDs</strong> for map config. Relative IDs (like <code>'../some/thing'</code>) do not work.</p> <p>There is also support for a \"*\" map value which means \"for all modules loaded, use this map config\". If there is a more specific map config, that one will take precedence over the star config. Example:</p> <pre>\nrequirejs.config({\n    map: {\n        '*': {\n            'foo': 'foo1.2'\n        },\n        'some/oldmodule': {\n            'foo': 'foo1.0'\n        }\n    }\n});\n</pre> <p>Means that for any module except \"some/oldmodule\", when \"foo\" is wanted, use \"foo1.2\" instead. For \"some/oldmodule\" only, use \"foo1.0\" when it asks for \"foo\".</p> <p id=\"config-map-notes\"><strong>Note:</strong> when doing builds with map config, the map config needs to be fed to the optimizer, and the build output must still contain a requirejs config call that sets up the map config. The optimizer does not do ID renaming during the build, because some dependency references in a project could depend on runtime variable state. So the optimizer does not invalidate the need for a map config after the build.</p> <p id=\"config-moduleconfig\"><strong><a href=\"#config-moduleconfig\">config</a></strong>: There is a common need to pass configuration info to a module. That configuration info is usually known as part of the application, and there needs to be a way to pass that down to a module. In RequireJS, that is done with the <b>config</b> option for requirejs.config(). Modules can then read that info by asking for the special dependency \"module\" and calling <b>module.config()</b>. Example:</p> <pre>requirejs.config({\n    config: {\n        'bar': {\n            size: 'large'\n        },\n        'baz': {\n            color: 'blue'\n        }\n    }\n});\n\n//bar.js, which uses simplified CJS wrapping:\n//http://requirejs.org/docs/whyamd.html#sugar\ndefine(function (require, exports, module) {\n    //Will be the value 'large'\n    var size = module.config().size;\n});\n\n//baz.js which uses a dependency array,\n//it asks for the special module ID, 'module':\n//https://github.com/requirejs/requirejs/wiki/Differences-between-the-simplified-CommonJS-wrapper-and-standard-AMD-define#wiki-magic\ndefine(['module'], function (module) {\n    //Will be the value 'blue'\n    var color = module.config().color;\n});\n</pre> <p>For passing config to a <a href=\"#packages\">package</a>, target the main module in the package, not the package ID:</p> <pre>requirejs.config({\n    //Pass an API key for use in the pixie package's\n    //main module.\n    config: {\n        'pixie/index': {\n            apiKey: 'XJKDLNS'\n        }\n    },\n    //Set up config for the \"pixie\" package, whose main\n    //module is the index.js file in the pixie folder.\n    packages: [\n        {\n            name: 'pixie',\n            main: 'index'\n        }\n    ]\n});\n</pre> <p id=\"config-packages\"><strong><a href=\"#config-packages\">packages</a></strong>: configures loading modules from CommonJS packages. See the <a href=\"#packages\">packages topic</a> for more information.</p> <p id=\"config-nodeIdCompat\"><strong><a href=\"#config-nodeIdCompat\">nodeIdCompat</a></strong>: Node treats module ID <code>example.js</code> and <code>example</code> the same. By default these are two different IDs in RequireJS. If you end up using modules installed from npm, then you may need to set this config value to <code>true</code> to avoid resolution issues. This option only applies to treating the \".js\" suffix differently, it does not do any other node resolution and evaluation matching such as .json file handling (JSON handling needs a 'json!' loader plugin anyway). Available in 2.1.10 and greater.</p> <p id=\"config-waitSeconds\"><strong><a href=\"#config-waitSeconds\">waitSeconds</a></strong>: The number of seconds to wait before giving up on loading a script. Setting it to 0 disables the timeout. The default is 7 seconds.</p> <p id=\"config-context\"><strong><a href=\"#config-context\">context</a></strong>: A name to give to a loading context. This allows require.js to load multiple versions of modules in a page, as long as each top-level require call specifies a unique context string. To use it correctly, see the <a href=\"#multiversion\">Multiversion Support</a> section.</p> <p id=\"config-deps\"><strong><a href=\"#config-deps\">deps</a></strong>: An array of dependencies to load. Useful when require is defined as a config object before require.js is loaded, and you want to specify dependencies to load as soon as require() is defined. Using deps is just like doing a <code>require([])</code> call, but done as soon as the loader has processed the configuration. <strong>It does not block</strong> any other require() calls from starting their requests for modules, it is just a way to specify some modules to load asynchronously as part of a config block.</p> <p id=\"config-callback\"><strong><a href=\"#config-callback\">callback</a></strong>: A function to execute after <strong>deps</strong> have been loaded. Useful when require is defined as a config object before require.js is loaded, and you want to specify a function to require after the configuration's <strong>deps</strong> array has been loaded.</p> <p id=\"config-enforceDefine\"><strong><a href=\"#config-enforceDefine\">enforceDefine</a></strong>: If set to true, an error will be thrown if a script loads that does not call define() or have a shim exports string value that can be checked. See <a href=\"#ieloadfail\">Catching load failures in IE</a> for more information.</p> <p id=\"config-xhtml\"><strong><a href=\"#config-xhtml\">xhtml</a></strong>: If set to true, document.createElementNS() will be used to create script elements.</p> <p id=\"config-urlArgs\"><strong><a href=\"#config-urlArgs\">urlArgs</a></strong>: Extra query string arguments appended to URLs that RequireJS uses to fetch resources. Most useful to cache bust when the browser or server is not configured correctly. Example cache bust setting for urlArgs:</p> <pre>urlArgs: \"bust=\" +  (new Date()).getTime()\n</pre> <p>As of RequireJS 2.2.0, urlArgs can be a function. If a function, it will receive the module ID and the URL as parameters, and it should return a string that will be added to the end of the URL. Return an empty string if no args. Be sure to take care of adding the '?' or '&amp;' depending on the existing state of the URL. Example:</p> <pre>requirejs.config({\n    urlArgs: function(id, url) {\n        var args = 'v=1';\n        if (url.indexOf('view.html') !== -1) {\n            args = 'v=2'\n        }\n\n        return (url.indexOf('?') === -1 ? '?' : '&amp;') + args;\n    }\n});\n</pre> <p>During development it can be useful to use this, however <strong>be sure</strong> to remove it before deploying your code.</p> <p id=\"config-scriptType\"><strong><a href=\"#config-baseUrl\">scriptType</a></strong>: Specify the value for the type=\"\" attribute used for script tags inserted into the document by RequireJS. Default is \"text/javascript\". To use Firefox's JavaScript 1.8 features, use \"text/javascript;version=1.8\".</p> <p id=\"config-skipDataMain\"><strong><a href=\"#config-skipDataMain\">skipDataMain</a></strong>: Introduced in RequireJS 2.1.9: If set to <code>true</code>, skips the <a href=\"#data-main\">data-main attribute scanning</a> done to start module loading. Useful if RequireJS is embedded in a utility library that may interact with other RequireJS library on the page, and the embedded version should not do data-main loading.</p>   <h2 id=\"advanced\"> Advanced Usage  </h2> <h3 id=\"packages\">Loading Modules from Packages</h3> <p>RequireJS supports loading modules that are in a <a href=\"http://wiki.commonjs.org/wiki/Packages/1.1\">CommonJS Packages</a> directory structure, but some additional configuration needs to be specified for it to work. Specifically, there is support for the following CommonJS Packages features:</p> <ul> <li>A package can be associated with a module name/prefix.</li> <li>The package config can specify the following properties for a specific package: <ul> <li>\n<strong>name</strong>: The name of the package (used for the module name/prefix mapping)</li> <li>\n<strong>location</strong>: The location on disk. Locations are relative to the baseUrl configuration value, unless they contain a protocol or start with a front slash (/).</li> <li>\n<strong>main</strong>: The name of the module inside the package that should be used when someone does a require for \"packageName\". The default value is \"main\", so only specify it if it differs from the default. The value is relative to the package folder.</li> </ul>\n</li> </ul> <p><strong>IMPORTANT NOTES</strong></p> <ul> <li>While the packages can have the CommonJS directory layout, the modules themselves should be in a module format that RequireJS can understand. Exception to the rule: if you are using the r.js Node adapter, the modules can be in the traditional CommonJS module format. You can use the <a href=\"commonjs#autoconversion\">CommonJS converter tool</a> if you need to convert traditional CommonJS modules into the async module format that RequireJS uses.</li> <li>Only one version of a package can be used in a project context at a time. You can use RequireJS <a href=\"#multiversion\">multiversion support</a> to load two different module contexts, but if you want to use Package A and B in one context and they depend on different versions of Package C, then that will be a problem. This may change in the future.</li> </ul> <p>If you use a similar project layout as specified in the <a href=\"https://requirejs.org/docs/start.html\">Start Guide</a>, the start of your web project would look something like this (Node/Rhino-based projects are similar, just use the contents of the <strong>scripts</strong> directory as the top-level project directory):</p> <ul> <li>project-directory/ <ul> <li>project.html</li> <li>scripts/ <ul> <li>require.js</li> </ul>\n</li> </ul>\n</li> </ul> <p>Here is how the example directory layout looks with two packages, <strong>cart</strong> and <strong>store</strong>:</p> <ul> <li>project-directory/ <ul> <li>project.html</li> <li>scripts/ <ul> <li>cart/ <ul> <li>main.js</li> </ul>\n</li> <li>store/ <ul> <li>main.js</li> <li>util.js</li> </ul>\n</li> <li>main.js</li> <li>require.js</li> </ul>\n</li> </ul>\n</li> </ul> <p><strong>project.html</strong> will have a script tag like this:</p> <pre>&lt;script data-main=\"scripts/main\" src=\"scripts/require.js\"&gt;&lt;/script&gt;\n</pre> <p>This will instruct require.js to load scripts/main.js. <strong>main.js</strong> uses the \"packages\" config to set up packages that are relative to require.js, which in this case are the source packages \"cart\" and \"store\":</p> <pre>//main.js contents\n//Pass a config object to require\nrequire.config({\n    \"packages\": [\"cart\", \"store\"]\n});\n\nrequire([\"cart\", \"store\", \"store/util\"],\nfunction (cart,   store,   util) {\n    //use the modules as usual.\n});\n</pre> <p>A require of \"cart\" means that it will be loaded from <strong>scripts/cart/main.js</strong>, since \"main\" is the default main module setting supported by RequireJS. A require of \"store/util\" will be loaded from <strong>scripts/store/util.js</strong>.</p> <p>If the \"store\" package did not follow the \"main.js\" convention, and looked more like this:</p> <ul> <li>project-directory/ <ul> <li>project.html</li> <li>scripts/ <ul> <li>cart/ <ul> <li>main.js</li> </ul>\n</li> <li>store/ <ul> <li>store.js</li> <li>util.js</li> </ul>\n</li> <li>main.js</li> <li>package.json</li> <li>require.js</li> </ul>\n</li> </ul>\n</li> </ul> <p>Then the RequireJS configuration would look like so:</p> <pre>require.config({\n    packages: [\n        \"cart\",\n        {\n            name: \"store\",\n            main: \"store\"\n        }\n    ]\n});\n</pre> <p>To avoid verbosity, it is strongly suggested to always use packages that use \"main\" convention in their structure.</p> <h3 id=\"multiversion\">Multiversion Support</h3> <p>As mentioned in <a href=\"#config\">Configuration Options</a>, multiple versions of a module can be loaded in a page by using different \"context\" configuration options. require.config() returns a require function that will use the context configuration. Here is an example that loads two different versions of the alpha and beta modules (this example is taken from one of the test files):</p> <pre>&lt;script src=\"../require.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\nvar reqOne = require.config({\n  context: \"version1\",\n  baseUrl: \"version1\"\n});\n\nreqOne([\"require\", \"alpha\", \"beta\",],\nfunction(require,   alpha,   beta) {\n  log(\"alpha version is: \" + alpha.version); //prints 1\n  log(\"beta version is: \" + beta.version); //prints 1\n\n  setTimeout(function() {\n    require([\"omega\"],\n      function(omega) {\n        log(\"version1 omega loaded with version: \" +\n             omega.version); //prints 1\n      }\n    );\n  }, 100);\n});\n\nvar reqTwo = require.config({\n      context: \"version2\",\n      baseUrl: \"version2\"\n    });\n\nreqTwo([\"require\", \"alpha\", \"beta\"],\nfunction(require,   alpha,   beta) {\n  log(\"alpha version is: \" + alpha.version); //prints 2\n  log(\"beta version is: \" + beta.version); //prints 2\n\n  setTimeout(function() {\n    require([\"omega\"],\n      function(omega) {\n        log(\"version2 omega loaded with version: \" +\n            omega.version); //prints 2\n      }\n    );\n  }, 100);\n});\n&lt;/script&gt;\n</pre> <p>Note that \"require\" is specified as a dependency for the module. This allows the require() function that is passed to the function callback to use the right context to load the modules correctly for multiversion support. If \"require\" is not specified as a dependency, then there will likely be an error.</p> <h3 id=\"afterload\">Loading Code After Page Load</h3> <p>The example above in the <strong>Multiversion Support</strong> section shows how code can later be loaded by nested require() calls. </p> <h3 id=\"webworker\">Web Worker Support</h3> <p>As of release 0.12, RequireJS can be run inside a Web Worker. Just use importScripts() inside a web worker to load require.js (or the JS file that contains the require() definition), then call require.</p> <p>You will likely need to set the <strong>baseUrl</strong> <a href=\"#config\">configuration option</a> to make sure require() can find the scripts to load.</p> <p>You can see an example of its use by looking at one of the files used in <a href=\"http://github.com/requirejs/requirejs/blob/master/tests/workers.js\">the unit test</a>.</p> <h3 id=\"rhino\">Rhino Support</h3> <p>RequireJS can be used in Rhino via the <a href=\"https://requirejs.org/docs/download.html#rjs\">r.js adapter</a>. See <a href=\"https://github.com/requirejs/r.js/blob/master/README.html\">the r.js README</a> for more information.</p> <h3 id=\"nashorn\">Nashorn Support</h3> <p>As of RequireJS 2.1.16, RequireJS can be used in <a href=\"http://www.oracle.com/technetwork/articles/java/jf14-nashorn-2126515.html\">Nashorn</a>, Java 8+'s JavaScript engine, via the <a href=\"https://requirejs.org/docs/download.html#rjs\">r.js adapter</a>. See <a href=\"https://github.com/requirejs/r.js/blob/master/README.html\">the r.js README</a> for more information.</p> <h3 id=\"errors\">Handling Errors</h3> <p>The general class of errors are 404s for scripts (not found), network timeouts or errors in the scripts that are loaded. RequireJS has a few tools to deal with them: require-specific errbacks, a \"paths\" array config, and a global requirejs.onError.</p> <p>The error object passed to errbacks and the global requirejs.onError function will usually contain two custom properties:</p> <ul> <li>\n<strong>requireType</strong>: A string value with a general classification, like \"timeout\", \"nodefine\", \"scripterror\".</li> <li>\n<strong>requireModules</strong>: an array of module names/URLs that timed out.</li> </ul> <p>If you get an error with a requireModules, it probably means other modules that depend on the modules in that requireModules array are not defined.</p> <h4 id=\"ieloadfail\"> Catching load failures in IE  </h4> <p>Internet Explorer has a set of problems that make it difficult to detect load failures for errbacks/paths fallbacks:</p> <ul> <li>script.onerror does not work in IE 6-8. There is no way to know if loading a script generates a 404, worse, it triggers the onreadystatechange with a complete state even in a 404 case.</li> <li>script.onerror does work in IE 9+, but it has a bug where it does not fire script.onload event handlers right after execution of script, so it cannot support the standard method of allowing anonymous AMD modules. So script.onreadystatechange is still used. However, onreadystatechange fires with a complete state before the script.onerror function fires.</li> </ul> <p>So it is very difficult with IE to allow both anonymous AMD modules, which are a core benefit of AMD modules, and reliable detect errors.</p> <p>However, if you are in a project that you know uses define() to declare all of its modules, or it uses the <a href=\"#config-shim\">shim</a> config to specify string exports for anything that does not use define(), then if you set the <a href=\"#config-enforceDefine\">enforceDefine</a> config value to true, the loader can confirm if a script load by checking for the define() call or the existence of the shim's exports global value.</p> <p>So if you want to support Internet Explorer, catch load errors, and have modular code either through direct define() calls or shim config, always set <b>enforceDefine</b> to be true. See the next section for an example.</p> <p><b>NOTE</b>: If you do set enforceDefine: true, and you use data-main=\"\" to load your main JS module, then that main JS module <b>must call define()</b> instead of require() to load the code it needs. The main JS module can still call require/requirejs to set config values, but for loading modules it should use define().</p> <p>If you then also use <a href=\"https://github.com/requirejs/almond\">almond</a> to build your code without require.js, be sure to use the <a href=\"https://github.com/requirejs/r.js/blob/master/build/example.build.js#L413\">insertRequire</a> build setting to insert a require call for the main module -- that serves the same purpose of the initial require() call that data-main does.</p> <h4 id=\"errbacks\"> require([]) errbacks  </h4> <p>Errbacks, when used with <a href=\"#undef\">requirejs.undef()</a>, will allow you to detect if a module fails to load, undefine that module, reset the config to a another location, then try again.</p> <p>A common use case for this is to use a CDN-hosted version of a library, but if that fails, switch to loading the file locally:</p> <pre>requirejs.config({\n    enforceDefine: true,\n    paths: {\n        jquery: 'http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min'\n    }\n});\n\n//Later\nrequire(['jquery'], function ($) {\n    //Do something with $ here\n}, function (err) {\n    //The errback, error callback\n    //The error has a list of modules that failed\n    var failedId = err.requireModules &amp;&amp; err.requireModules[0];\n    if (failedId === 'jquery') {\n        //undef is function only on the global requirejs object.\n        //Use it to clear internal knowledge of jQuery. Any modules\n        //that were dependent on jQuery and in the middle of loading\n        //will not be loaded yet, they will wait until a valid jQuery\n        //does load.\n        requirejs.undef(failedId);\n\n        //Set the path to jQuery to local path\n        requirejs.config({\n            paths: {\n                jquery: 'local/jquery'\n            }\n        });\n\n        //Try again. Note that the above require callback\n        //with the \"Do something with $ here\" comment will\n        //be called if this new attempt to load jQuery succeeds.\n        require(['jquery'], function () {});\n    } else {\n        //Some other error. Maybe show message to the user.\n    }\n});\n</pre> <p>With `requirejs.undef()`, if you later set up a different config and try to load the same module, the loader will still remember which modules needed that dependency and finish loading them when the newly configured module loads.</p> <p><b>Note</b>: errbacks only work with callback-style require calls, not define() calls. define() is only for declaring modules.</p> <h4 id=\"pathsfallbacks\"> paths config fallbacks  </h4> <p>The above pattern for detecting a load failure, undef()ing a module, modifying paths and reloading is a common enough request that there is also a shorthand for it. The paths config allows array values:</p> <pre>requirejs.config({\n    //To get timely, correct error triggers in IE, force a define/shim exports check.\n    enforceDefine: true,\n    paths: {\n        jquery: [\n            'http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min',\n            //If the CDN location fails, load from this location\n            'lib/jquery'\n        ]\n    }\n});\n\n//Later\nrequire(['jquery'], function ($) {\n});\n</pre> <p>This above code will try the CDN location, but if that fails, fall back to the local lib/jquery.js location.</p> <p><b>Note</b>: paths fallbacks only work for exact module ID matches. This is different from normal paths config which can apply to any part of a module ID prefix segment. Fallbacks are targeted more for unusual error recovery, not a generic path search path solution, since those are inefficient in the browser.</p> <h4 id=\"requirejsonerror\"> Global requirejs.onError function  </h4> <p>To detect errors that are not caught by local errbacks, you can override requirejs.onError():</p> <pre>requirejs.onError = function (err) {\n    console.log(err.requireType);\n    if (err.requireType === 'timeout') {\n        console.log('modules: ' + err.requireModules);\n    }\n\n    throw err;\n};\n</pre>   <h2 id=\"plugins\"> Loader Plugins  </h2> <p>RequireJS supports <a href=\"plugins\">loader plugins</a>. This is a way to support dependencies that are not plain JS files, but are still important for a script to have loaded before it can do its work. The RequireJS wiki has <a href=\"https://github.com/requirejs/requirejs/wiki/Plugins\">a list of plugins</a>. This section talks about some specific plugins that are maintained alongside RequireJS:</p> <h3 id=\"text\">Specify a Text File Dependency</h3> <p>It is nice to build HTML using regular HTML tags, instead of building up DOM structures in script. However, there is no good way to embed HTML in a JavaScript file. The best that can be done is using a string of HTML, but that can be hard to manage, particularly for multi-line HTML.</p> <p>RequireJS has a plugin, text.js, that can help with this issue. It will automatically be loaded if the text! prefix is used for a dependency. See the <a href=\"https://github.com/requirejs/text\">text.js README</a> for more information.</p> <h3 id=\"pageload\">Page Load Event Support/DOM Ready</h3> <p>It is possible when using RequireJS to load scripts quickly enough that they complete before the DOM is ready. Any work that tries to interact with the DOM should wait for the DOM to be ready. For modern browsers, this is done by waiting for the DOMContentLoaded event.</p> <p>However, not all browsers in use support DOMContentLoaded. The domReady module implements a cross-browser method to determine when the DOM is ready. <a href=\"https://requirejs.org/docs/download.html#domReady\">Download the module</a> and use it in your project like so:</p> <pre>require(['domReady'], function (domReady) {\n  domReady(function () {\n    //This function is called once the DOM is ready.\n    //It will be safe to query the DOM and manipulate\n    //DOM nodes in this function.\n  });\n});\n</pre> <p>Since DOM ready is a common application need, ideally the nested functions in the API above could be avoided. The domReady module also implements the <a href=\"plugins\">Loader Plugin API</a>, so you can use the loader plugin syntax (notice the <b>!</b> in the domReady dependency) to force the require() callback function to wait for the DOM to be ready before executing. domReady will return the current document when used as a loader plugin:</p> <pre>require(['domReady!'], function (doc) {\n    //This function is called once the DOM is ready,\n    //notice the value for 'domReady!' is the current\n    //document.\n});\n</pre> <p><b>Note:</b> If the document takes a while to load (maybe it is a very large document, or has HTML script tags loading large JS files that block DOM completion until they are done), using domReady as a loader plugin may result in a RequireJS \"timeout\" error. If this a problem either increase the <a href=\"#config-waitSeconds\">waitSeconds</a> configuration, or just use domReady as a module and call domReady() inside the require() callback.</p> <h3 id=\"i18n\">Define an I18N Bundle</h3> <p>Once your web app gets to a certain size and popularity, localizing the strings in the interface and providing other locale-specific information becomes more useful. However, it can be cumbersome to work out a scheme that scales well for supporting multiple locales.</p> <p>RequireJS allows you to set up a basic module that has localized information without forcing you to provide all locale-specific information up front. It can be added over time, and only strings/values that change between locales can be defined in the locale-specific file.</p> <p>i18n bundle support is provided by the i18n.js plugin. It is automatically loaded when a module or dependency specifies the i18n! prefix (more info below). <a href=\"https://requirejs.org/docs/download.html#i18n\">Download the plugin</a> and put it in the same directory as your app's main JS file.</p> <p>To define a bundle, put it in a directory called \"nls\" -- the i18n! plugin assumes a module name with \"nls\" in it indicates an i18n bundle. The \"nls\" marker in the name tells the i18n plugin where to expect the locale directories (they should be immediate children of the nls directory). If you wanted to provide a bundle of color names in your \"my\" set of modules, create the directory structure like so:</p> <ul> <li>my/nls/colors.js</li> </ul> <p>The contents of that file should look like so:</p> <pre>//my/nls/colors.js contents:\ndefine({\n    \"root\": {\n        \"red\": \"red\",\n        \"blue\": \"blue\",\n        \"green\": \"green\"\n    }\n});\n</pre> <p>An object literal with a property of \"root\" defines this module. That is all you have to do to set the stage for later localization work.</p> <p>You can then use the above module in another module, say, in a my/lamps.js file:</p> <pre>//Contents of my/lamps.js\ndefine([\"i18n!my/nls/colors\"], function(colors) {\n    return {\n        testMessage: \"The name for red in this locale is: \" + colors.red\n    }\n});\n</pre> <p>The my/lamps module has one property called \"testMessage\" that uses colors.red to show the localized value for the color red.</p> <p>Later, when you want to add a specific translation to a file, say for the fr-fr locale, change my/nls/colors to look like so:</p> <pre>//Contents of my/nls/colors.js\ndefine({\n    \"root\": {\n        \"red\": \"red\",\n        \"blue\": \"blue\",\n        \"green\": \"green\"\n    },\n    \"fr-fr\": true\n});\n</pre> <p>Then define a file at my/nls/fr-fr/colors.js that has the following contents:</p> <pre>//Contents of my/nls/fr-fr/colors.js\ndefine({\n    \"red\": \"rouge\",\n    \"blue\": \"bleu\",\n    \"green\": \"vert\"\n});\n</pre> <p>RequireJS will use the browser's navigator.languages, navigator.language or navigator.userLanguage property to determine what locale values to use for my/nls/colors, so your app does not have to change. If you prefer to set the locale, you can use the <a href=\"#config-moduleconfig\">module config</a> to pass the locale to the plugin:</p> <pre>requirejs.config({\n    config: {\n        //Set the config for the i18n\n        //module ID\n        i18n: {\n            locale: 'fr-fr'\n        }\n    }\n});\n</pre> <p><strong>Note</strong> that RequireJS will always use a lowercase version of the locale, to avoid case issues, so all of the directories and files on disk for i18n bundles should use lowercase locales.</p> <p>RequireJS is also smart enough to pick the right locale bundle, the one that most closely matches the ones provided by my/nls/colors. For instance, if the locale is \"en-us\", then the \"root\" bundle will be used. If the locale is \"fr-fr-paris\" then the \"fr-fr\" bundle will be used.</p> <p>RequireJS also combines bundles together, so for instance, if the french bundle was defined like so (omitting a value for red):</p> <pre>//Contents of my/nls/fr-fr/colors.js\ndefine({\n    \"blue\": \"bleu\",\n    \"green\": \"vert\"\n});\n</pre> <p>Then the value for red in \"root\" will be used. This works for all locale pieces. If all the bundles listed below were defined, then RequireJS will use the values in the following priority order (the one at the top takes the most precedence):</p> <ul> <li>my/nls/fr-fr-paris/colors.js</li> <li>my/nls/fr-fr/colors.js</li> <li>my/nls/fr/colors.js</li> <li>my/nls/colors.js</li> </ul> <p>If you prefer to not include the root bundle in the top level module, you can define it like a normal locale bundle. In that case, the top level module would look like:</p> <pre>//my/nls/colors.js contents:\ndefine({\n    \"root\": true,\n    \"fr-fr\": true,\n    \"fr-fr-paris\": true\n});\n</pre> <p>and the root bundle would look like:</p> <pre>//Contents of my/nls/root/colors.js\ndefine({\n    \"red\": \"red\",\n    \"blue\": \"blue\",\n    \"green\": \"green\"\n});\n</pre><div class=\"_attribution\">\n  <p class=\"_attribution-p\">\n    &copy; jQuery Foundation and other contributors<br>Licensed under the MIT License.<br>\n    <a href=\"https://requirejs.org/docs/api.html\" class=\"_attribution-link\">https://requirejs.org/docs/api.html</a>\n  </p>\n</div>\n"}